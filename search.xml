<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11.14-11.26学习双周记</title>
    <url>/2024/07/11/11-14-11-26%E5%AD%A6%E4%B9%A0%E5%8F%8C%E5%91%A8%E8%AE%B0%EF%BC%9A/</url>
    <content><![CDATA[<p>11.14-11.26学习双周记：</p>
<p>最近事务稍多，且更多时间花在了写代码上<del>且略摆</del>，故学习的知识型内容较少</p>
<p>完成了pa1和081的lab1</p>
<hr>
<span id="more"></span>
<h4 id="小知识get"><a href="#小知识get" class="headerlink" title="小知识get:"></a>小知识get:</h4><h5 id="搜索引擎的小技巧：英文符号"><a href="#搜索引擎的小技巧：英文符号" class="headerlink" title="搜索引擎的小技巧：英文符号"></a>搜索引擎的小技巧：英文符号</h5><p>搜索引擎对符号的支持是很差的，甚至会被识别成通配符之类</p>
<p>正确的搜索符号的姿势是使用英文代替符号</p>
<p>e.g.（google）可以搜搜对比一下 </p>
<p>python __   和 python bundle的对比</p>
<p>* in bash 和 asterisk in bash的对比</p>
<p>常用特殊符号英文：</p>
<ul>
<li><p>? question mark</p>
</li>
<li><p>! exclamation mask</p>
</li>
<li><p>&#96; backtick	</p>
</li>
<li><p>$ dollar  	 </p>
</li>
<li><p>- hyphen  	</p>
</li>
<li><p># sharp or hash    	</p>
</li>
<li><p>~ tilde</p>
</li>
<li><p>&amp; ampersand   </p>
</li>
<li><p>* asterisk 	</p>
</li>
<li><p>_ underscore   </p>
</li>
<li><p>^ caret     </p>
</li>
<li><p>, comma</p>
</li>
<li><p>. dot  	</p>
</li>
<li><p>&#x2F; forward slash       </p>
</li>
<li><p>\ backslash    </p>
</li>
<li><p>&lt;&gt; angle bracket  	</p>
</li>
<li><p>[]  bracket     </p>
</li>
<li><p>()  brace</p>
</li>
<li><p>“” quotation mark</p>
</li>
</ul>
<h5 id="正则表达式错用让cpu占用率提升N倍（雾）"><a href="#正则表达式错用让cpu占用率提升N倍（雾）" class="headerlink" title="正则表达式错用让cpu占用率提升N倍（雾）"></a>正则表达式错用让cpu占用率提升N倍（雾）</h5><p><code>$(\d+)*^</code>  : 一个 <code>*</code> 是如何让算法复杂度从O(N)变成O(2^N^)的，匹配 1111111111111111111111111111a 直接爆炸</p>
<p><code>$(1+1+)+0^</code> : 同理 匹配 11111111111111111111111111111就寄了</p>
<p>原理：参考这个，写得真不错<a class="link"   href="https://houbb.github.io/2020/01/07/regex-and-dfa-02" >https://houbb.github.io/2020/01/07/regex-and-dfa-02 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>画个图就懂了</p>
<hr>
<h4 id="配置wsl的代理"><a href="#配置wsl的代理" class="headerlink" title="配置wsl的代理"></a>配置wsl的代理</h4><p>使用CFW，打开系统代理、允许局域网链接，使用此脚本</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转载自 https://www.cnblogs.com/jaycethanks/p/17360464.html</span></span><br><span class="line"><span class="comment"># 获取wsl虚拟机的ip， 并代理至windows 7890 端口</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;设定wsl网络代理到7890外网访问端口......&quot;</span> </span><br><span class="line">host_ip=$(<span class="built_in">cat</span> /etc/resolv.conf |grep <span class="string">&quot;nameserver&quot;</span> |<span class="built_in">cut</span> -f 2 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://<span class="variable">$host_ip</span>:7890&quot;</span></span><br><span class="line"><span class="comment"># curl 命令检查，并仅输出状态码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;尝试通过curl命令检查 google 是否可以访问......返回状态码为：&quot;</span></span><br><span class="line">curl -s -o /dev/null -w <span class="string">&quot;%&#123;http_code&#125;\n&quot;</span> https://www.google.com</span><br></pre></td></tr></table></figure></div>

<p>放到<code>~/.bashrc</code>下</p>
<p>再<code>source ~/.bashrc</code>即可</p>
<p>碎碎念：本来配置wsl代理主要就是为了解决代码补全在wsl之中（即vsc开启remote模式下）不可用的问题，结果配完之后看到这样的issue</p>
<blockquote>
<p> <strong><a class="link"   href="https://github.com/yxw820603" >yxw820603 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong> commented <a class="link"   href="https://github.com/THUDM/CodeGeeX2/issues/110#issuecomment-1751579150" >on Oct 7 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> • edited</p>
<p>经过简单测试，确定插件无法在Remote-SSH的情况下工作。</p>
</blockquote>
<p>不过codeium倒是折腾半天能用了，虽然也不知道为什么，wsl下的效果比起正常本机差不少……延迟很大</p>
<p>写码的时候还碰到一个很搞的事情</p>
<p><code>grep "-D"</code>会把”-D”解释成参数-D,””解释成字面量</p>
<p>想到的规避方法是敲个空格 <code>grep "[space]-D"</code></p>
<hr>
<h4 id="浅入理解断点和调试器"><a href="#浅入理解断点和调试器" class="headerlink" title="浅入理解断点和调试器"></a>浅入理解断点和调试器</h4><p>主要参考</p>
<p><a class="link"   href="https://events.static.linuxfound.org/sites/events/files/slides/slides_16.pdf" >https://events.static.linuxfound.org/sites/events/files/slides/slides_16.pdf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information" >https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在写知识之前，不如先问自己几个问题：</p>
<ul>
<li>debugger的实现原理是什么？</li>
<li>断点(breakpoint)和监视点(watchpoint)的区别？</li>
<li>断点有哪些实现方法？具体到gdb之中，它是怎么实现的？</li>
</ul>
<p>debugger的最基本原理，就是这样的代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Expected a program name as argument\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">run_target</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">run_debugger</span>(child_pid);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>debugger作为父进程，使用fork调出了需要debug的子进程，然后通过某种方法和子进程交互（操控子进程）</p>
<p>那么就引出了这样的问题：</p>
<ol>
<li>怎么操控的（允许操控的机制）</li>
<li>操控之后的控制流</li>
<li>已经控制了，debug信息从哪来（如果不做处理，高级语言编译之后是没有原来的代码行数、变量符号等信息的）</li>
</ol>
<p>又可以进一步总结出以下几点，</p>
<p>debug需要信息：</p>
<ol>
<li><p>在高级代码—&gt;汇编的过程之中，我们需要代码的一一对应关系，比如第几行的高级代码对应第几行（到第几行）的汇编代码</p>
</li>
<li><p>在汇编代码—&gt;可执行文件的过程之中，我们需要将有用的信息保存在可执行文件内</p>
</li>
</ol>
<p>debug需要断点：</p>
<ol start="3">
<li>需要有一种方法在gdb或者在可执行文件之中达成中断</li>
<li>进一步地，需要让gdb（父进程）能够控制、监视、改变子进程（被调试的进程）</li>
</ol>
<p>解决了这几个问题，理论上就能产生debugger</p>
<p>问题1，很遗憾，由于现代编译器的优化和现代编程语言的复杂性，源程序语言和编译完成的汇编，又或者说最后执行的机器指令很难完美对应，编译器开启对应的编译指令之后也只能做到近似（**不能完全相信back trace!**）但大体上还是对的。（也可以强制让编译器不优化）</p>
<p>下图转载： <code>gdb br</code>的失败例子</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/LlfdwUEMvmtT3S2.png"
                      alt="image-20231123221703870"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/nxWOHEMZNSKTa9G.png"
                      alt="image-20231123221731588"
                ></p>
<p>问题2，这就是为什么需要gcc <strong>-g</strong> 的理由，也是为什么可以不止于对内存地址设断点，还能对一个函数，一行源代码设断点的原因</p>
<blockquote>
<p>现代编译器在将高级代码转换为高级代码方面做得很好，其缩进和嵌套的控制结构以及任意类型的变量可以很好地转换为一大堆称为机器代码的位，其唯一目的是在目标 CPU 上尽可能快地运行。大多数 C 行被转换为多个机器代码指令。变量被推到各处 - 进入堆栈、寄存器或完全优化。<strong>结构和对象甚至不存在于生成的代码中 - 它们只是一个抽象</strong>，被转换为硬编码的偏移量到内存缓冲区中。</p>
<p>那么，当您要求调试器在某个函数的入口处中断时，调试器如何知道在哪里停止呢？当你向它询问变量的值时，它是如何找到要显示的内容的？<strong>答案是 - 调试信息</strong>。</p>
<p><strong>调试信息由编译器与机器代码一起生成。它是可执行程序和原始源代码之间关系的表示。这些信息被编码为预定义的格式，并与机器代码一起存储</strong>。多年来，为不同的平台和可执行文件发明了许多这样的格式。由于本文的目的不是调查这些格式的历史，而是展示它们的工作原理，因此我们必须确定一些事情。这将是 DWARF，它今天几乎无处不在地用作 Linux 和其他 Unix-y 平台上 ELF 可执行文件的调试信息格式。</p>
</blockquote>
<p>对应elf文件中的.debug_**段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/gCWjndKMXcq4Gyi.png"
                      alt="image-20231123223152372"
                ></p>
<p>如何进一步阅读?</p>
<p><code>objdump --dwarf=info</code></p>
<p>info可以换成别的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/DQtJcnh7CyRp9mK.png"
                      alt="image-20231123223310051"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/lypIGeNi9BZJ8Mc.png"
                      alt="image-20231123223328905"
                ></p>
<p>问题3、4</p>
<p>debug需要断点，需要某种可恢复的中断，怎么做？</p>
<ul>
<li>软件支持</li>
<li>硬件支持</li>
</ul>
<p>先讲硬件支持是怎么实现的。如果设备有实现硬件debug，它会在内存之中占据一段特殊的位置，使得这个硬件支持对cpu是可见的</p>
<p>（cpu也实现了debug的控制寄存器和控制单元）。而gdb在debug时，会先确定本机的架构和硬件信息，之后根据硬件信息去寻找相关的debug是否有硬件支持。</p>
<p>而这个硬件支持表现在能够硬件上单步执行，通过比较器设置断点，etc</p>
<blockquote>
<p>Gateway between re-purposed JTAG bit protocol and debug logic </p>
<p>Debug hardware often visible in a special memory address space </p>
<p>E.g. (gdb) stop requires writing 0x1 (Halt Request) to address 0x090 (Debugger Run Control Register) of the CPU debug unit. </p>
<ul>
<li><p>Shift 4 bits into IR </p>
</li>
<li><p>Shift 34 bits into DR </p>
</li>
<li><p>Shift 4 bits into IR </p>
</li>
<li><p>Shift 34 bits into DR </p>
</li>
<li><p>Shift 34 bits into DR</p>
</li>
</ul>
</blockquote>
<p>另一种就是软件支持，</p>
<p>首先是中断，当程序运行到断点的时候，它应该向gdb发出一个中断信号（比如SIGTRAP），之后gdb程序（父进程）接收到中断信号后，辨别出这个是断点产生的中断还是程序正常运行的中断，并加以处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/27/a1AtXh7PgYDwsCW.png"
                      alt="image-20231127222802586"
                ></p>
<p>然后是ptrace系统调用，这个系统调用允许一个进程去得到另一个进程的控制权，包括监视、改变、发送命令等</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_target</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* programname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;target started. will run &#x27;%s&#x27;\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allow tracing of this process */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace this process&#x27;s image with the given program */</span></span><br><span class="line">    <span class="built_in">execl</span>(programname, programname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而有了中断之后，一种简单的实现方法可能是这样的：</p>
<p>在指定的地址上设一个监视点w</p>
<p>首先，每次运行一条指令之后我都切换到debugger，比对一下pc和监视地址是否相同，如果相同，那么我就停止</p>
<p>这种切换的机制来源于：</p>
<ol>
<li>wait() 不止在子进程exit时才会退出，在子进程触发中断时也会返回，并保存一些中断信息</li>
<li>ptrace调用定义了一个特殊的request PTRACE_SINGLESTEP，会告诉OS启动被监控进程，但是一条指令后停止（pc+4），并产生中断通知父进程</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_debugger</span><span class="params">(<span class="type">pid_t</span> child_pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> wait_status;</span><br><span class="line">    <span class="type">unsigned</span> icounter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;debugger started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for child to stop on its first instruction */</span></span><br><span class="line">    <span class="built_in">wait</span>(&amp;wait_status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">WIFSTOPPED</span>(wait_status)) &#123;</span><br><span class="line">        icounter++;</span><br><span class="line">        <span class="comment">/* Make the child execute another instruction */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></span><br><span class="line">        <span class="built_in">wait</span>(&amp;wait_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;the child executed %u instructions\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们当然可以用这种单步执行比对pc的“监视点”方法实现断点，但这个方法的问题是，每执行一条指令都要不断切换进程，效率太低了</p>
<p>jyy介绍， gdb用了一种很神奇的方法： int 3（注意这个int不是integer 的int）偷龙转凤</p>
<p>int 3 是一个单字节x86指令，作用就是简单地发出一个中断SIGTRAP</p>
<p>单字节使得它能够替换到任何一条指令的开头，并且不会覆盖两条及以上的指令</p>
<p>在设置断点的时候，<strong>gdb可以将断点处的指令保存起来，之后替换它的首个字节为int 3</strong></p>
<blockquote>
<p><strong>Instruction at the given address is read, saved and replaced with a breakpoint:</strong> </p>
<p>​	- either a special instruction,   &#x2F;&#x2F; SIGTRAP, int 3</p>
<p>​	- or an undefined encoding.   &#x2F;&#x2F; SIGILL</p>
</blockquote>
<p>之后程序正常运行，执行到int 3时产生中断（SIGTRAP，int 3就是第三号TRAP，x86的调试器中断），而gdb程序作为父进程收到这个信号，达成中断（通过ptrace设置了中断的handler），之后也可以将原来的指令替换回来继续执行。</p>
<p>继续执行的细节：</p>
<p>实际上在有了ptrace的调用之后，每当被监控程序执行exec的时候，就会发出一个中断</p>
<blockquote>
<p>Indicates that this process is to be traced by its parent. Any signal (except SIGKILL) delivered to this process will cause it to stop and its parent to be notified via wait(). <strong>Also, all subsequent calls to exec() by this process will cause a SIGTRAP to be sent to it, giving the parent a chance to gain control before the new program begins execution</strong>. A process probably shouldn’t make this request if its parent isn’t expecting to trace it. (pid, addr, and data are ignored.)<br>指示此过程将由其父级跟踪。传递给此进程的任何信号（SIGKILL 除外）都会导致它停止，并通过 wait（） 通知其父级。此外，此进程对 exec（） 的所有后续调用都将导致向它发送 SIGTRAP，从而使父级有机会在新程序开始执行之前获得控制权。如果进程的父进程不希望跟踪它，则进程可能不应发出此请求。（PID、ADDR 和 DATA 将被忽略。</p>
</blockquote>
<p>小的自问自答环节：</p>
<p>Q：为什么gdb不是特权指令？它读寄存器值、内存值等是怎么实现的？</p>
<p>A：<strong>但install是特权指令（笑）</strong>，Linux之中，二进制文件是自动具备可执行的默认权限的（<strong>file mode</strong>），而不是像bash脚本那样需要sudo chmod +x 给予权限。</p>
<p>并且咨询gpt还得到一个有趣的事情：ptrace调用确实可以修改其他的进程，<strong>所以ptrace调用是需要root权限</strong>，但是，<strong>用户权限下，可以使用setuid或者setcap机制，是gdb能对特定的文件，具有特定系统调用的权限</strong></p>
<p>读寄存器值是使用了特定的中断，读内存是读的虚拟内存。</p>
<h4 id="对页表的进一步探讨"><a href="#对页表的进一步探讨" class="headerlink" title="对页表的进一步探讨"></a>对页表的进一步探讨</h4><p>在写知识之前，不如先问自己几个问题：</p>
<ul>
<li>为什么要引入多级页表？多级页表的原理和具体实现是什么？什么是页表目录（page table dir）？</li>
<li>页表的基址寄存器，在xv6中是什么？在页表还没有建立之前和建立页表，设置基址之时，内核代码是怎么运行的？</li>
<li>计算机的cache具体是在什么位置？它接受的和返回的是物理地址还是虚拟地址？</li>
<li>多进程下，内核栈在实际内存的哪里？有几个？又是如何保证多个内核栈不重叠的？</li>
</ul>
<h4 id="xv6的文件系统和系统调用"><a href="#xv6的文件系统和系统调用" class="headerlink" title="xv6的文件系统和系统调用"></a>xv6的文件系统和系统调用</h4><p>在写知识之前，不如先问自己几个问题：</p>
<ul>
<li><p>使用系统调用写一个ls的大体思路？</p>
</li>
<li><p>文件重命名，软硬链接究竟是什么？文件夹又是什么？</p>
</li>
<li><p>文件描述符和管道是怎么实现的？</p>
</li>
<li><p>系统调用是如何实现的</p>
</li>
<li><p>多进程下，内核栈在实际内存的哪里？有几个？又是如何保证多个内核栈不重叠的？</p>
</li>
<li><p>宏内核和微内核的利弊？</p>
</li>
</ul>
<p>文件系统部分：</p>
<p>Linux文件的核心标识是inode</p>
<p>名字之于inode号好比域名之于ip地址</p>
<p>是由文件所在的文件夹管理这一个 &lt;filename, inode number&gt;的map</p>
<p>这就又引出了文件夹是什么，实际上就是——什么也不是，它只是一个 记录了底下文件的&lt;filename, inode number&gt;的map数据</p>
]]></content>
  </entry>
  <entry>
    <title>2024sp学期总结</title>
    <url>/2024/07/11/2024sp%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本学期是转入软件工程专业的第一个学期。</p>
<p>在转入之前，我有很多美妙的幻想，无论是声明远扬的实验室和校内最好的本科教学，还是软件学院向来高标准严要求，被学长们交相赞誉“XX为数不多的值得读的专业”，而JYY的课程让我更是早早地期待起了这学期的讲课水平。</p>
<p>与此同时，老师的整了个全新的项目——挺新奇、也挺有挑战的一个课题，同时水源的开发也算是委派了第一个新人试水级别的任务，看似前途一片光明——在开学的前三周，我就在一种喜悦的充实感之中度过，总感觉真是大有可为，会是飞速成长的一个学期。</p>
<p>然而事实却给了我两个大嘴巴子——贪心不足蛇吞象，这也要那也要的结果就是都干不好——另一个原因也是我依然高估了自己的能力，低估了软院课程的工作量, 一学期2w行代码真不是说着玩的。</p>
<span id="more"></span>
<p>本学期上了哪些课呢？</p>
<ul>
<li>ICS2，计算机系统基础2，csapp剩下的全本+ostep的部分+许多Linux拓展，在原本的CSAPP Lab上也加了新的手写assembler和simulator。体系结构讲得很难，后面的系统讲得很广，总体上除了后几个lab文档确实不怎么样之外体验还是好的，能体验到许多新奇的东西——slab, vma, elf和动态链接的各种细节，等等等，但也就是这学期唯一的希望之光了。唯一一门有国外公开课水平的课，体感优于15213，和61c差不多（广度倒是远大于），差于NJU ICS。</li>
<li>ADS，高级数据结构，<strong>粪课</strong>。内容为radix tree，rbtree,splay tree等各种树+skiplist+bloomfilter+cuckoo hash+高阶图算法、并行图算法。有12个hw，不少带实验报告，4个lab和一个proj。他的讲课真的很烂，一度有让我产生“什么？这不是华五正统科班，这是带专，课程吸水变高变大”之感，又是签到狂魔和作业狂魔，给分还差，导致体验非常不好。lab和proj还算是这门课最后的良心——虽然是助教的功劳。一个Huffman压缩，一个基数树，一个HNSW（这个我是真喜欢），还有一个重量级LSM Tree。LSM tree真是一个好项目——虽然我写了很久（算上沟槽的实验报告在80个小时以上），但写完还是收获非常大，从c++17到db设计中的各种技巧和权衡乃至debug、写测试、管理项目的能力——从0开始手写一个支持键值分离、GC、持久化（还有选做的并行）等feature的LSM真是很磨练人。这门课最大的问题在于耗时间太多，且有些东西太过琐碎，虽然学了不少东西，但浪费的时间也是很多。</li>
<li>Web, 互联网应用开发。前端React+后端Spring Boot+JPA的手搓全栈开发课——很有培训班的风格。老师前半学期讲前端的时候挺无聊的，毕竟寒假自学过，后半学期对着《Database System Design》来讲的时候倒是很有意思，从JPA的底层讲到数据库范式、同步等机制，还是挺有意思，加上给分也好，算是一门还行的课。下学期还有他的Web2, 讲讲各种Redis，MQ，Cloud, 全局搜索之类的东西，还是可以期待一下。</li>
<li>math4cs：垃圾课，完全不知道在教什么。今年这门课发生了改革，把自动机的部分去掉了，导致整体更没法看。前半是信息论和凸优化的最基础的东西，后半又开倒车回到了线代——SVD,QR,LU,…,结果大作业又是train两个AI model，不知所云的课。</li>
<li>量子力学：沟槽的工科平台，软件工程的学生学牛魔量子力学。</li>
<li>电路实验：喜欢我大化实验+大物实验*2+电路实验吗</li>
<li>数电：学了吗？如学。在学期快结束的时候倒是感觉串起来还是比较新奇的，但和CS交界的部分也不超过之前学的计组，电路部分也不是很有意思。</li>
<li>红课：没啥好说的。</li>
<li>软件基础实践：也是补大一的课，现在再去写小朋友的lab还是简单的。</li>
</ul>
<p>实验室项目是一个在OpenHarmony上做基础设施移植的工作——可惜一个是自己时间太少，另一个是自己水平不够，导致项目的进度几乎和我没什么关系。新奇的事也有，例如玩开发板、完整的Linux环境、亲手装机、一些图形和库移植的知识……但总感觉迷迷糊糊的，挺细碎，其实也不知道后续有什么地方能用到。</p>
<p>这学期很可惜的就是081完全没动——鸽了又鸽，暂时可能不会动了，暑假也是先继续学开发和项目相关的、java、分布式之类，可能去学学写游戏玩。更觉得无力的是几乎完全没有刷过课——就是在ddl之中疲于奔命了，最后看着还算是比上学期好的成绩，也没啥波澜，<strong>这就结束了吗？</strong></p>
<p>现在的心情倒是挺正常的，但感觉本学期还是对我造成了一点创伤——以至于对于代码的兴趣都消退了些许，当兴趣变成“工作”或许就是如此，期中也常常深夜破防，得到的感想就是<strong>人还是不能把自己绷得太紧</strong>，或许有人喜欢这样，但我这样效率反而低下。</p>
<p>可以注意到的也是我本学期博客更新频率变低了好多——有时候连总结的时间都没有，无尽的ddl，唉，暑假打算慢慢补上来。</p>
<p>CS还有好多领域我还没探索过，这学期也认真思考了一些以后要走什么方向，也和一些学长吃饭聊天过。最后还是打算先试试游戏和后端——感觉对基架有点祛魅了，我还是更喜欢开发一点。</p>
<p>下学期，新的大二上，课少了不少，选了一门著名老师的云网融合+应用体系架构，也算是督促自己学分布式和Spring Cloud之类的东西，打算好好学学开发准备明年实习去了，毕竟新大二下一个几乎全空的学期对日常实习而言实在是难得。暑假也继续探索自己的兴趣点吧。没选镇系神课CSE，时间可能真不多了，尤其是对我这种在各个方向之间摇摆的人而言。</p>
<p>Anyway，这学期的破防都已经过去了，接下来是一个有无限可能的三个月暑假，todolist列了一箩筐，希望最后能完成50%吧。无论是力扣，计网、java还是6824、cs186都不是急于一时的，暑假和下学期慢慢做就行，更别提可能还有一个很重视的项目，先调调作息，放松身心，暑假学学cs，玩玩2077+黑猴，偶尔再找朋友出去玩一玩，生活总是有很多美好。</p>
<p>先学生活，再学知识，希望下学期开始健身+调作息，虽然也已经说了蛮多次了（笑）。少焦虑，多干活，把刷论坛的时间拿来学习和打游戏多好。</p>
]]></content>
  </entry>
  <entry>
    <title>Django-mosh</title>
    <url>/2024/07/11/Django-mosh/</url>
    <content><![CDATA[<p>Django mosh</p>
<p>shell django-admin</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin startproject &lt;proj name&gt; .</span><br></pre></td></tr></table></figure></div>

<p>run server</p>
<span id="more"></span>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></div>



<p>app 可以通过proj初始settings.py集成</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;new proj name&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>创建新app</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py startapp &lt;appname&gt;</span><br></pre></td></tr></table></figure></div>

<p>添加进路由</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;__debug__/&#x27;</span>, include(<span class="string">&#x27;debug_toolbar.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;playground&#x27;</span>, include(<span class="string">&#x27;playground.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>





<p>views: 类似Controller req-&gt;res, request handler</p>
<p>debug: django-debug-toolbar 配置方法文档</p>
<p>urlconf</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --- app added</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># URLconf</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">   path(<span class="string">&#x27;hello/&#x27;</span>, views.say_hello)  <span class="comment"># &#x27;/&#x27; is important</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- main proj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;__debug__/&#x27;</span>, include(<span class="string">&#x27;debug_toolbar.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;playground/&#x27;</span>, include(<span class="string">&#x27;playground.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>其中urlpatterns是一个内置路由变量</p>
<p>model 类似 entity</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    description = models.TextField()</span><br><span class="line">    <span class="comment"># 9999.99</span></span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    inventory = models.IntegerField()</span><br><span class="line">    last_update = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    email = models.EmailField(unique=<span class="literal">True</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>) <span class="comment"># nullable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>注意：</p>
<ul>
<li>没有id field django自动创建（如果没有指定主键）</li>
</ul>
<p>类似枚举和@JsonProperty</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">MEMBERSHIP_BRONZE = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">MEMBERSHIP_SILVER = <span class="string">&#x27;S&#x27;</span></span><br><span class="line">MEMBERSHIP_GOLD = <span class="string">&#x27;G&#x27;</span></span><br><span class="line">MEMBERSHIP_CHOICES = [</span><br><span class="line">    (MEMBERSHIP_BRONZE, <span class="string">&#x27;Bronze&#x27;</span>),</span><br><span class="line">    (MEMBERSHIP_SILVER, <span class="string">&#x27;Silver&#x27;</span>),</span><br><span class="line">    (MEMBERSHIP_GOLD, <span class="string">&#x27;Gold&#x27;</span>),</span><br><span class="line">]</span><br><span class="line">membership = models.CharField(max_length=<span class="number">1</span>, choices=MEMBERSHIP_CHOICES,</span><br><span class="line">                              default=MEMBERSHIP_BRONZE)</span><br></pre></td></tr></table></figure></div>

<p>其中’B’是实际存在数据库之中的值，’Bronze’是实际对上呈现的值</p>
<p>OneToOne Mapping</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>(models.Model):</span><br><span class="line">    city = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    customer = models.OneToOneField(Customer, on_delete=models.CASCADE, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div>

<p>on_delete可以设置多种级联，例如SETNULL,SETDEFAULT,PROTECT,CASCADE</p>
<p>django里面OneToOne默认是双向的，会自动在Customer之中生成address属性</p>
<p>OneToMany: db view，直接使用ForeignKey</p>
<p>e.g</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cart</span>(models.Model):</span><br><span class="line">    customer = models.OneToOneField(Customer, on_delete=models.CASCADE, primary_key=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>(models.Model):</span><br><span class="line">    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)</span><br><span class="line">    product = models.ForeignKey(Product, on_delete=models.CASCADE)</span><br><span class="line">    number = models.IntegerField()</span><br><span class="line">    added_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>ManyToMany</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promotion</span>(models.Model):</span><br><span class="line">    <span class="comment"># 促销, 和产品是多对多关系</span></span><br><span class="line">    description = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    discount = models.FloatField()</span><br><span class="line">    start_at = models.DateTimeField(null=<span class="literal">True</span>)</span><br><span class="line">    end_at = models.DateField(null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    description = models.TextField()</span><br><span class="line">    <span class="comment"># 9999.99</span></span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>)</span><br><span class="line">    inventory = models.IntegerField()</span><br><span class="line">    last_update = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line">    collection = models.ForeignKey(<span class="string">&#x27;Collection&#x27;</span>, on_delete=models.PROTECT)</span><br><span class="line">    promotion = models.ManyToManyField(<span class="string">&#x27;Promotion&#x27;</span>)  <span class="comment"># get by default &#x27;product_set&#x27; in promotion</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>处理循环依赖：</p>
<p>Collection类之中有一个feature product，同时product被Collection包含，解决方法为加上<code>&#39;&#39;</code></p>
<p>相当于留了解析符号，但会影响修改时的改动，所以一般不要用</p>
<p>解决django自动创建反向依赖导致的重名问题，一种是指定related_name，另一种直接指定为<code>&#39;+&#39;</code>意思是不生成反向依赖</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span>(models.Model):</span><br><span class="line">    feature_product = models.ForeignKey(<span class="string">&#x27;Product&#x27;</span>, on_delete=models.SET_NULL,null=<span class="literal">True</span>, related_name=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(models.Model):</span><br><span class="line">    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure></div>



<h4 id="泛型关系"><a href="#泛型关系" class="headerlink" title="泛型关系"></a>泛型关系</h4><p>如果我们想要有一个tag, 用于对任意物体打标签（因而需要与具体的store解耦），怎么做？</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericForeignKey</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tag</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TagItem</span>(models.Model):</span><br><span class="line">    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generic</span></span><br><span class="line">    <span class="comment"># Type, ID -&gt; content</span></span><br><span class="line">    content_type = models.ForeignKey(<span class="string">&#x27;contenttypes.ContentType&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey(<span class="string">&#x27;content_type&#x27;</span>, <span class="string">&#x27;object_id&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>也就是说content_type入库的实际上是一个序列化后的类型信息变量（例如string）,而object_id是int，运行时可以计算的结果content_obj？</p>
</blockquote>
<p>答: 是的，</p>
<p><code>content_type</code> 字段存储的是一个 <code>ContentType</code> 对象的 ID，这个对象代表了关联对象的类型。<code>ContentType</code> 是 Django 的一个内置模型，它存储了所有已注册模型的信息，包括模型的名字和它所在的应用的名字。</p>
<p><code>object_id</code> 字段存储的是关联对象的 ID。这个 ID 是关联对象在它所在的数据库表中的主键。</p>
<p><code>content_object</code> 是一个 <code>GenericForeignKey</code> 字段，它不会在数据库中创建对应的列，而是在运行时通过 <code>content_type</code> 和 <code>object_id</code> 的值去获取关联对象。访问 <code>content_object</code> 属性时，Django 会根据 <code>content_type</code> 和 <code>object_id</code> 的值去查询对应的对象，并返回这个对象。</p>
<p>练习：LikeItem</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericForeignKey</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LikeItem</span>(models.Model):</span><br><span class="line">    <span class="comment"># who likes what</span></span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE)</span><br><span class="line">    content_type = models.ForeignKey(<span class="string">&#x27;contenttypes.ContentType&#x27;</span>, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey(<span class="string">&#x27;content_type&#x27;</span>, <span class="string">&#x27;object_id&#x27;</span>)</span><br></pre></td></tr></table></figure></div>



<h4 id="migrations"><a href="#migrations" class="headerlink" title="migrations"></a>migrations</h4><p>应该让Django完成建库建表等操作</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure></div>

<p>migration是django自动生成的以库为单位的db修改操作的抽象，包含log等功能</p>
<p>修改entity之后也简单的重新运行migration就行（可能要改改文件名（生成的文件名类似git commit的hashID,是会出现在后续migration的depandency里面的））</p>
<p>migration只是创建了操作，之后使用如下入库</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></div>



<h4 id="slug"><a href="#slug" class="headerlink" title="slug"></a>slug</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">slug = models.SlugField(default=<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>slug是一个可以匹配字母数字下划线和连字符的动态路由, <strong>用于使一个东西对搜索引擎检索更加友好</strong></p>
<p>例如，如果想检索一篇博客<code>some-blog</code>，一个url为<code>myweb/blogs/some-blog</code>的子网页肯定比<code>myweb/blogs/1</code>容易检索</p>
<p>可以用<code>path(&#39;.../&lt;slug:slug&gt;&#39;)</code>来动态捕获slug路由参数</p>
<h4 id="meta-data"><a href="#meta-data" class="headerlink" title="meta data"></a>meta data</h4><p>可以在model.Model类的派生类之中定义一个内部类Meta，其中就可以修改表名字，增加索引等</p>
<p>由于django一般是“约定大于配置”的逻辑，如果你在一个地方改了，就要全改来保持统一性，所以改得比较少</p>
<p>有了这些migration文件之后，可以像git checkout一样回到db的某个状态</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migrate store &lt;migrate_no&gt;</span><br></pre></td></tr></table></figure></div>



<p>集成postgresql，看官方tutorial改settings.py</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.postgresql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;mosh_course&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;ayanami&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: os.environ.get(<span class="string">&#x27;POSTGRES_PASSWORD&#x27;</span>, <span class="string">&#x27;mosh_course&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: os.environ.get(<span class="string">&#x27;POSTGRES_HOST&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">5432</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>mock一些数据 <a class="link"   href="https://mockaroo.com/" >mockaroo.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 很好用</p>
<h4 id="查询（DAO）"><a href="#查询（DAO）" class="headerlink" title="查询（DAO）"></a>查询（DAO）</h4><p>django使用queryset进行查询，可以理解成java的stream</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">query_set = Customer.objects.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></div>

<p>query_set可以filter, order_by等链式调用得到新的query_set,并在最后一个“求值”的api上（例如切片，get等操作）通过实际query返回数据</p>
<p>也就是说它是lazy query的，注意query_set不保证非null，如果使用get没找到的话会抛出错误ObjectNotFoundException，一个简单的避免抛错的方法是使用<code>filter().first()</code>的形式，在filter返回空的情况下返回<code>None</code></p>
<p><code>filter</code>或者<code>get</code>可以传入一个特殊参数<code>pk</code>来指定主键是啥</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>只能传键值对，问题：</p>
<ul>
<li>表示小于？</li>
</ul>
<p>使用特殊的附加约定形式（类似JPA）<code>filter(&lt;something&gt;__st=5</code> ,其中<code>__st</code>的后缀作为特殊谓词标志</p>
<p>可以组合<code>filter(collection__id__range=(5, 10))</code>collection表中id为5～10的</p>
<p>常见的还有<code>__contains</code>, <code>___startwith</code></p>
<p>条件组合Q object和<code>|</code>,<code>~</code>,<code>&amp;</code></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">Poll.objects.get(</span><br><span class="line">    Q(question__startswith=<span class="string">&quot;Who&quot;</span>),</span><br><span class="line">    Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">2</span>)) | Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">6</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>基本等同于</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> polls <span class="keyword">WHERE</span> question <span class="keyword">LIKE</span> <span class="string">&#x27;Who%&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> (pub_date <span class="operator">=</span> <span class="string">&#x27;2005-05-02&#x27;</span> <span class="keyword">OR</span> pub_date <span class="operator">=</span> <span class="string">&#x27;2005-05-06&#x27;</span>)</span><br></pre></td></tr></table></figure></div>



<p>数据引用F Object，表示引用本表或者外键关联表里面的字段</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">Poll.objects.get(</span><br><span class="line">    Q(question__startswith=<span class="string">&quot;Who&quot;</span>),</span><br><span class="line">    who=F(question),  <span class="comment"># 本表的&#x27;who&#x27;字段 == 本表的 &#x27;question&#x27;字段</span></span><br><span class="line">    who=F(anothertable__question) <span class="comment"># 本表的&#x27;who&#x27;字段 == 本表的&#x27;anothertable&#x27;外键关联表的 &#x27;question&#x27;字段</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>



<h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><p><code>order_by</code></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">query_set = Customer.objects.order_by(<span class="string">&#x27;name&#x27;</span>) <span class="comment">#按照name字段升序</span></span><br><span class="line">query_set = Customer.objects.order_by(<span class="string">&#x27;-name&#x27;</span>) <span class="comment">#按照name字段降序</span></span><br></pre></td></tr></table></figure></div>



<h4 id="得到table的字段对象"><a href="#得到table的字段对象" class="headerlink" title="得到table的字段对象"></a>得到table的字段对象</h4><p>有不同的方法</p>
<ul>
<li><p><code>values</code>得到entity(object)</p>
</li>
<li><p><code>values_list</code>得到dict of tuple</p>
</li>
<li><p><code>only</code>和<code>defer</code>都是entity，只查询和延迟查询，但是有个注意点：不会动态检查是否存在某个属性，如果不存在会得到非常多的query -&gt; 性能大幅度降低</p>
</li>
</ul>
<h4 id="超级牛魔的一个设计"><a href="#超级牛魔的一个设计" class="headerlink" title="超级牛魔的一个设计"></a>超级牛魔的一个设计</h4><p>django默认 <strong>不</strong> 加载关联表</p>
<p>同时，他的更新也是 <strong>不</strong> 关联的——需要手动更新关联表内信息</p>
<p>如果表A有B的外键，然后加载了表A的all(),就会每一个表A的row都join查询一次表B</p>
<p><strong>加载关联表</strong>:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">all_A = A.objects.select_related(<span class="string">&#x27;B&#x27;</span>).<span class="built_in">all</span>() </span><br></pre></td></tr></table></figure></div>



<p>相关的一个api是prefetch，和select的区别在于select是一对一的时候用，prefetch是一对多的时候(一个A可能对应多个B的时候)用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">all_A = A.objects.prefetch_related(&#x27;B&#x27;).all() </span><br></pre></td></tr></table></figure></div>



<h4 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h4><p>传入一个键值对，值是某种Django定义的回调函数（如<code>Count(&#39;id&#39;)</code>，对id列计数）</p>
<p>（严格来说是django database function或者它的包装（使用<code>Func</code>api））</p>
<p>返回的是{键-回调计算结果} 的 dict</p>
<p>ExpressionWrapper &amp; Custom Manager</p>
<p>用到再说</p>
<p>django会缓存</p>
<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>create:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种方法，有intellisense，可以refactor</span></span><br><span class="line">    new_customer = Customer()</span><br><span class="line">    new_customer.birth_date = <span class="string">&quot;1990-01-01&quot;</span></span><br><span class="line">    new_customer.email = <span class="string">&quot;n7sZf@example.com&quot;</span></span><br><span class="line">    new_customer.save()</span><br><span class="line"><span class="comment"># 第二种，更短但没有</span></span><br><span class="line">	new_customer = Customer.objects.create(birth_date=<span class="string">&quot;1990-01-01&quot;</span>, email=<span class="string">&quot;n7sZf@example.com&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>update:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">new_customer = Customer.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">new_customer.birth_date = <span class="string">&quot;1990-01-01&quot;</span></span><br><span class="line">new_customer.email = <span class="string">&quot;n7sZf@example.com&quot;</span></span><br><span class="line">new_customer.save()</span><br><span class="line"><span class="comment"># 当然还有第二种update object.filter(pk=1).update()</span></span><br></pre></td></tr></table></figure></div>

<p>注意需要用get，也就是需要显式读</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">customer = Customer(pk=<span class="number">1</span>)</span><br><span class="line">customer.delete()</span><br><span class="line"><span class="comment"># 当然还有第二种delete object.filter(pk=1).delete()</span></span><br></pre></td></tr></table></figure></div>





<h4 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h4><p>现在有一个原子性问题，django是不关联更新的，所以我们要先更新order，再更新orderItem，这就带来了原子性问题</p>
<p>解决方法，使用 <code>with transaction.atomic():</code>包裹多次save()且需要保证原子性的地方</p>
<h4 id="The-Ultimate-Solution"><a href="#The-Ultimate-Solution" class="headerlink" title="The Ultimate Solution"></a>The Ultimate Solution</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">queryset = Customer.<span class="built_in">object</span>.raw(<span class="string">&#x27;SELECT * FROM store_product&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>注意这个queryset没有filter之类的方法了，退化了（悲，差@Query远甚）</p>
<h4 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h4><ol>
<li>custom 可以改改默认控制面板的列表名字，加上筛选和排序等等（ModelAdmin Options）</li>
</ol>
<p>这部分其实像前端的某种统计模块了</p>
<h4 id="RESTful-api"><a href="#RESTful-api" class="headerlink" title="RESTful api"></a>RESTful api</h4><p>1.”Controller”: router + json&#x2F;… sender</p>
<p>先加个<code>rest_framework</code>到INTSALLED_APPS</p>
<p>然后这样</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ok</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>路由还是在urlpatterns里面加</p>
<p>2.”DTO+Serializer”: serializer</p>
<p>有点像数据库的api, 对不同的基本类型调用了serializer，由于这个时候可以重新取变量名字（指定source属性即可）和选择丢掉的变量，就替代了@JsonProperty和@JsonIgnore之类的东西</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">customer_serializer</span>(serializers.Serializer):</span><br><span class="line">    <span class="built_in">id</span> = serializers.IntegerField()</span><br><span class="line">    first_name = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    last_name = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    phone = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    birth_date = serializers.DateField()</span><br></pre></td></tr></table></figure></div>

<p>之后可以这样，把object -&gt; serializer -&gt; serializer.data -&gt; dict&#x2F;json response</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_single_customer</span>(<span class="params">request, <span class="built_in">id</span>:<span class="built_in">int</span></span>):</span><br><span class="line">    queryset = Customer.objects.get(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    serializer = customer_serializer(queryset, many=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 如果传入一个iterable就可以many=True</span></span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># dynamic route customer/&#123;id&#125;</span></span><br><span class="line">    path(<span class="string">&#x27;customer/&lt;int:id&gt;/&#x27;</span>, views.get_single_customer),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>



<p>上面的代码不safe，get一个不正确id就炸了</p>
<p>safe写法如下，<code>get_object_or_404</code>只是<code>try except</code>然后返回一个<code>Response(status=404)</code>的语法糖</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_single_customer</span>(<span class="params">request, <span class="built_in">id</span>:<span class="built_in">int</span></span>):</span><br><span class="line">    queryset = get_object_or_404(Customer, pk=<span class="built_in">id</span>)</span><br><span class="line">    serializer = customer_serializer(queryset, many=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure></div>



<p>这个DTO的部分还能给Simplify一点, 例如加点间接计算量</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">first_name = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">   last_name = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">get_full_name</span>(<span class="params">self, customer:Customer</span>):</span><br><span class="line">       <span class="keyword">return</span> customer.first_name + <span class="string">&quot; &quot;</span> + customer.last_name</span><br><span class="line">   full_name = serializers.SerializerMethodField(<span class="string">&#x27;get_full_name&#x27;</span>)</span><br></pre></td></tr></table></figure></div>



<p>related object serialize</p>
<ul>
<li><code>serializers.PrimaryKeyRelatedField</code> 指定<code>queryset</code>（一般就直接<code>xxx.object.all()</code>就行）之后返回一个query后的id列表</li>
<li>也可以定义<code>__str__</code>后，<code>serializers.StringRelatedField</code></li>
<li>稍微复杂的<code>serializers.HyperlinkedRelatedField</code>可以把返回的变成一个list of url，例如 “…&#x2F;collections&#x2F;1”之类</li>
</ul>
<p><strong>如果想要对象套对象呢?</strong></p>
<p>自定义一个<code>NestObjSerializer</code>类，然后</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">nest_obj = NestObjSerializer()</span><br></pre></td></tr></table></figure></div>



<p>DTO的语法糖：modelSerializer</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">customer_serializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="comment"># id = serializers.IntegerField()</span></span><br><span class="line">    <span class="comment"># first_name = serializers.CharField(max_length=255)</span></span><br><span class="line">    <span class="comment"># last_name = serializers.CharField(max_length=255)</span></span><br><span class="line">    <span class="comment"># email = serializers.EmailField()</span></span><br><span class="line">    <span class="comment"># phone = serializers.CharField(max_length=255)</span></span><br><span class="line">    <span class="comment"># birth_date = serializers.DateField()</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Customer</span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;birth_date&#x27;</span>, <span class="string">&#x27;full_name&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_full_name</span>(<span class="params">self, customer:Customer</span>):</span><br><span class="line">        <span class="keyword">return</span> customer.first_name + <span class="string">&quot; &quot;</span> + customer.last_name</span><br><span class="line">    full_name = serializers.SerializerMethodField(<span class="string">&#x27;get_full_name&#x27;</span>)</span><br></pre></td></tr></table></figure></div>



<p>POST</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_customer</span>(<span class="params">request, <span class="built_in">id</span>:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        queryset = get_object_or_404(Customer, pk=<span class="built_in">id</span>)</span><br><span class="line">        serializer = customer_serializer(queryset, many=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        serializer = customer_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.validated_data)</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>raise_exception</code>相当于一个invalidate -&gt; return status.HTTP_404_BAD_REQUEST的分支</p>
<p>可以在serializer之中override validate方法(反序列化之后是一个Dict),例如</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">self, data</span>):</span><br><span class="line">    <span class="keyword">if</span> data[<span class="string">&#x27;password&#x27;</span>]!=data[<span class="string">&#x27;confirm_password&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> serializers.ValidationError(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></div>



<p>入库：最简单的方法是直接<code>serializer.save()</code></p>
<p>如果需要对POST传入的对象处理后再入库，可以override serializer的<code>create</code>和<code>update</code>方法</p>
<p>PUT的区别在与serializer多传入一个被更新的item做参数</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_customer</span>(<span class="params">request, <span class="built_in">id</span>:<span class="built_in">int</span></span>):</span><br><span class="line">    // ...</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;PUT&#x27;</span>:</span><br><span class="line">        serializer = customer_serializer(queryset, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.validated_data)</span><br></pre></td></tr></table></figure></div>

<p>DELETE: 对entity调用<code>delete()</code>，手动检查有没有依赖导致无法删除的情况，如果有可以返回一个405_method_not_allowed</p>
<h3 id="Advanced-API-concepts"><a href="#Advanced-API-concepts" class="headerlink" title="Advanced API concepts"></a>Advanced API concepts</h3><ul>
<li><p>Class-based Views</p>
</li>
<li><p>Generic Views</p>
</li>
<li><p>ViewSet</p>
</li>
<li><p>Nested Routers</p>
</li>
</ul>
<p>上面的再看</p>
<ul>
<li>filtering</li>
<li>sorting</li>
<li>paging</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sorted_customers</span>(<span class="params">request</span>):</span><br><span class="line">    queryset = Customer.objects.<span class="built_in">all</span>()</span><br><span class="line">    first_name = request.query_params.get(<span class="string">&#x27;first_name&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    last_name = request.query_params.get(<span class="string">&#x27;last_name&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> first_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        queryset = queryset.<span class="built_in">filter</span>(first_name=first_name)</span><br><span class="line">    <span class="keyword">if</span> last_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        queryset = queryset.<span class="built_in">filter</span>(last_name=last_name)</span><br><span class="line">    serializer = customer_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure></div>

<p>类视图下还可以引入外界库，django-filter进一步简化编码，并且引入GenericFilter</p>
<p>同时集成了可视化API，支持各种过滤组合</p>
<p>Search： restframework的 SearchFilter组件</p>
<p>Sort: restframework的 OrderingFilter组件</p>
<p>Pagination: restframework的 PageNumberPagination组件</p>
]]></content>
  </entry>
  <entry>
    <title>Go,Gin学习</title>
    <url>/2024/07/11/Go-Gin%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Go-Gin-Gorm学习"><a href="#Go-Gin-Gorm学习" class="headerlink" title="Go &amp; Gin &amp; Gorm学习"></a>Go &amp; Gin &amp; Gorm学习</h3><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><p>Learn go by test</p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><span id="more"></span>
<p><code>package</code>:类似<code>namespace</code>或者<code>module</code></p>
<p>循环</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(character <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> repeat <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++&#123;</span><br><span class="line">		repeat = repeat + character</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中<code>:=</code>是带初始值定义的语法糖，<code>var name type</code>是不带初始值的定义；go的循环只有for </p>
<p>测试示例</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRepeat</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	got:=Repeat(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	expect:=<span class="string">&quot;aaaaa&quot;</span></span><br><span class="line">	<span class="keyword">if</span> got!=expect&#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;got %q, expect %q&quot;</span>, got, expect)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<p>运行测试，如果有定义main函数（在<code>package main</code>之中），则可以直接<code>go run xx.go</code></p>
<p>go包内函数和成员变量的可见性是通过大小写区分的，大写对包外可见，小写不可见</p>
<p>test函数需要写成<code>TestXXX</code>的形式，同时文件名也要写成<code>whatfiles_test</code></p>
<p>基准测试benchmark，<code>BenchmarkXXX</code>函数名</p>
<p>strings库和相关函数</p>
<p>range迭代</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="comment">// index, element</span></span><br><span class="line">	<span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr&#123;</span><br><span class="line">		sum += ele</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -cover <span class="comment"># 测试测试覆盖率</span></span><br></pre></td></tr></table></figure></div>



<p>变长参数和append</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAll</span><span class="params">(arrs ...[]<span class="type">int</span>)</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">	ans:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, arr := <span class="keyword">range</span> arrs&#123;</span><br><span class="line">		ans = <span class="built_in">append</span>(ans, Sum(arr))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数指针(函数可以直接给变量)</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">checkSums := <span class="function"><span class="keyword">func</span><span class="params">(t testing.TB, got, want []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	t.Helper()</span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;got %v want %v&quot;</span>, got, want)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>集合切片：go支持类似python的切片</p>
<p>结构和方法（OOP）</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">   width <span class="type">float32</span></span><br><span class="line">   height <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float32</span></span><br><span class="line">	center_x <span class="type">float32</span></span><br><span class="line">	center_y <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>go不允许函数重载，类完全和结构体等价，类内函数（方法）如上定义</p>
<p>结构体可以嵌套，并且支持折叠调用（例如A.B.ccc, ccc是B的属性，B是A的属性，可以直接A.ccc）</p>
<p>go有interface</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span>&#123;</span><br><span class="line">	Area() <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试也方便</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	checkArea := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, shape Shape, expect <span class="type">float32</span>)</span></span>&#123;</span><br><span class="line">		diff := shape.Area() - expect</span><br><span class="line">		<span class="keyword">if</span> math.Abs(<span class="type">float64</span>(diff)) &gt; <span class="number">1e-6</span>&#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;expect %v, got %v, diff %v&quot;</span>, expect, shape.Area(), diff)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.Run(<span class="string">&quot;rectangles&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		rectangle := Rectangle&#123;<span class="number">12</span>, <span class="number">6</span>&#125;</span><br><span class="line">		checkArea(t, rectangle, <span class="number">72.0</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	t.Run(<span class="string">&quot;circles&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		circle := Circle&#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">		checkArea(t, circle, <span class="number">314.1592653589793</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>go之中接口解析是隐式的</strong>， 不需要显式implements xxx（interface），只需要确实有这个方法，就能成功编译</p>
<p>Best Practice:表结构测试, 使用<code>t.Run</code>和测试表和<code>#%v(打印结构)</code>来获得清晰的测试</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	checkArea := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, name <span class="type">string</span>, shape Shape, expect <span class="type">float32</span>)</span></span>&#123;</span><br><span class="line">		t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">			diff := shape.Area() - expect</span><br><span class="line">			<span class="keyword">if</span> math.Abs(<span class="type">float64</span>(diff)) &gt; <span class="number">1e-6</span>&#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;in %#v, expect %v, got %v, diff %v&quot;</span>, shape, expect, shape.Area(), diff)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	testTable:= []<span class="keyword">struct</span>&#123;</span><br><span class="line">	   name <span class="type">string</span></span><br><span class="line">       shape Shape</span><br><span class="line">	   expect <span class="type">float32</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;Rectangle&quot;</span>,shape: Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">10</span>&#125;, expect: <span class="number">100</span>&#125;,</span><br><span class="line">		&#123;name:<span class="string">&quot;Circle&quot;</span>, shape: Circle&#123;radius: <span class="number">10</span>&#125;, expect: <span class="number">314.1592653589793</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, test :=<span class="keyword">range</span> testTable&#123;</span><br><span class="line">		checkArea(t, test.name, test.shape, test.expect)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>指针和错误</p>
<p>go的函数默认都是值传递，而指针又由于语法糖表现得和引用（的语法）差不多</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Wallet)</span></span> Withdraw(amount Bitcoin) &#123;</span><br><span class="line">	w.balance -= amount</span><br><span class="line">&#125; <span class="comment">// 这是this-&gt;balance -= amount</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Wallet)</span></span> Withdraw(amount Bitcoin) &#123;</span><br><span class="line">	w.balance -= amount</span><br><span class="line">&#125; <span class="comment">// 这是w = (*this), w.balance -= amount</span></span><br></pre></td></tr></table></figure></div>

<p>go用返回值来表示一个函数可能抛出错误（其中返回值的类型为error）</p>
<p>如果这个error是nil（null的变体），那就是正常，否则是错误，例如</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Wallet)</span></span> Withdraw(amount Bitcoin) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> amount &gt; w.balance &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;oh no&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.balance -= amount</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>检测一个类是否实现了接口的全部方法：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ Interface = (*Class)(<span class="literal">nil</span>) <span class="comment">// 如果Class类的指针不能强制转换成接口，就没有全部实现 </span></span><br></pre></td></tr></table></figure></div>



<p>空接口：可以表示任何类型</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    m[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;Tom&quot;</span></span><br><span class="line">    m[<span class="string">&quot;age&quot;</span>]=<span class="number">18</span></span><br><span class="line">    m[<span class="string">&quot;parents&quot;</span>]=Persons&#123;A, B&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>map <code>map[key]value</code></p>
<ol>
<li>传递指针（所以不需要传递map的引用，直接传递就行）</li>
<li><code>var m map[string]string</code>后，m是nil，这不好。这<strong>不是</strong>空map</li>
</ol>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure></div>

<p>泛型</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    head, tail *element[T]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> element[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *element[T]</span><br><span class="line">    val  T</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lst *List[T])</span></span> Push(v T) &#123;</span><br><span class="line">    <span class="keyword">if</span> lst.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        lst.head = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">        lst.tail = lst.head</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lst.tail.next = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">        lst.tail = lst.tail.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>并发</p>
<ol>
<li>goroutine</li>
</ol>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentDownload</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	download := <span class="function"><span class="keyword">func</span> <span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Start Downloading %v.\n&quot;</span>, name)</span><br><span class="line">		time.Sleep(time.Second) <span class="comment">// simulate</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v finished.\n&quot;</span>, name)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> download(<span class="string">&quot;File&quot;</span>+fmt.Sprint(i))</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ConcurrentDownload(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，</p>
<ul>
<li><code>sync.WaitGroup</code>用于等待所有协程结束（其实是一个计数器，在计数为0的时候Wait()就不堵塞了，Add()加一，Done()减一）</li>
<li><code>go &lt;dosomething&gt;</code>起一个dosomething的协程</li>
</ul>
<ol start="2">
<li>channel</li>
</ol>
<p>并发协程的通信管道</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFib</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fib_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x := <span class="number">0</span></span><br><span class="line">		y := <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">			fib_chan &lt;- x</span><br><span class="line">			x, y = y, x + y</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(fib_chan)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> num := <span class="keyword">range</span> fib_chan&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, num)</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PrintFib(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，</p>
<ul>
<li>make是一个类似malloc的东西, 但他可以自动gc，并且可以分配channel管道</li>
<li><code>&lt;-</code>是一个运算符， 对chan使用，代表把右边的丢进chan</li>
<li>用make创建chan，可以有第二个参数，代表缓冲区大小<ul>
<li>如果没有，无缓冲，只有当接受和发送端都就绪才会开始发送</li>
<li>如果有，size为n，意味着有一个n个元素大小的缓冲区，发送端可以提前发送，缓冲区满之前不需要等待接收端</li>
</ul>
</li>
<li>chan支持range语法，range会沿着管道迭代直至关闭——管道只能被发送方关闭，接收方关闭管道后继续发送会panic</li>
</ul>
<p>用channel也可以进行这样的同步：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;working...&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    &lt;-done <span class="comment">// 在这里起到了类似wait()或者join()的效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以指定一个channel只可以接受&#x2F;发送</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="type">string</span>, pongs <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// pings只能发送，pongs只能接受</span></span><br><span class="line">    msg := &lt;-pings</span><br><span class="line">    pongs &lt;- msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ol start="3">
<li>select</li>
</ol>
<p>可以同时等待多个channel上的消息</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>select实现超时——一个协程干活，一个协程Sleep timeout秒，然后select两个协程</p>
<p>select实现非堵塞管道——一个default case，不接收东西</p>
<p>协程理解：</p>
<ul>
<li>轻量级线程，轻量级体现在是在用户态的堆上去模拟栈结构，在代码之中自己调度，而不是通过syscall陷入内核调度——其中非抢占式的实现（例如python的asyncio），通过yield等在阻塞时主动让出；抢占式的实现可以直接被调度器调度（例如goroutine）</li>
<li>也因为是在用户态的调度，<strong>协程实际上没有并行的功能，只是提供了一个非阻塞的执行流</strong>，多个协程在同一个线程上执行，也只占据cpu的一个核心</li>
<li>协程的用处在于，以一个轻量级的方式去完成堵塞的功能（例如IO， network），执行两个IO请求，cpu工作1ms，IO工作1s，如果是两个线程，cpu的1ms可以并行，但受限于线程创建回收调度开销和系统最大线程资源限制，实际损耗的时间很可能大于ms级别。而协程在cpu上需要依次运行两个1ms,但是同样不需要被IO堵塞</li>
<li>具体的实现方式而言，分为有栈协程和无栈协程，有栈协程有自己的一段模拟的栈空间，在切换时保存寄存器到栈里面；无栈协程使用状态机实现，在切换时记录状态机的状态。有栈协程开销更大，但表达力更强</li>
<li>ts里面的async&#x2F;await就是协程的包装，await就是记录状态的点，程序向下执行到await处暂停协程，等待await事件完成</li>
</ul>
<p>timer&amp;ticker 内置计时器, 可用于限流等</p>
<p>defer延迟做某件事，常见于模拟一种RAII，无论是何种方式退出都能正常执行</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    file, err := os.Create(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 确保文件在函数结束时被关闭,defer后的调用会在defer所在的函数结束后执行</span></span><br><span class="line"></span><br><span class="line">    _, err = file.Write(data)</span><br><span class="line">    <span class="keyword">return</span> err </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">defer</span> wg.Done()</span><br><span class="line">          worker(i)</span><br><span class="line">      &#125;()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>原子操作</li>
</ol>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ops atomic.Uint64</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">                ops.Add(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;ops:&quot;</span>, ops.Load()) <span class="comment">//50000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>mutex锁</li>
</ol>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    counters <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.counters++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>Useful API</p>
<p>Sort排序(<code>slices</code>) 第二个参数是谓词</p>
<p>自定义排序之中的内置类型的比较用<code>cmp.Compare()</code></p>
<p>例如</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">PersonCmp := <span class="function"><span class="keyword">func</span><span class="params">(a *Person, b *Person)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cmp.Compare(a.name, b.name)</span><br><span class="line">&#125;</span><br><span class="line">slices.SortFunc(Persons, PersonCmp)</span><br><span class="line">slices.Sort(ints)</span><br><span class="line">slices.isSorted(ints)</span><br></pre></td></tr></table></figure></div>



<p>go有内置<code>panic(msg string)</code>和<code>recover</code>(在defer内部，catch panic)</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recover 的返回值是调用 panic 时引发的错误。</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered. Error:\n&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">	mayPanic()</span><br></pre></td></tr></table></figure></div>



<p>字符串相关函数</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    s <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> p = fmt.Println</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p(<span class="string">&quot;Contains:  &quot;</span>, s.Contains(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;es&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;Count:     &quot;</span>, s.Count(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;t&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;HasPrefix: &quot;</span>, s.HasPrefix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;te&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;HasSuffix: &quot;</span>, s.HasSuffix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;st&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;Index:     &quot;</span>, s.Index(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;Join:      &quot;</span>, s.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;Repeat:    &quot;</span>, s.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>))</span><br><span class="line">    p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">    p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    p(<span class="string">&quot;Split:     &quot;</span>, s.Split(<span class="string">&quot;a-b-c-d-e&quot;</span>, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;ToLower:   &quot;</span>, s.ToLower(<span class="string">&quot;TEST&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;ToUpper:   &quot;</span>, s.ToUpper(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>正则：<code>regexp</code>包</p>
<p>JSON包，rand包</p>
<p>parse数字，</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    i, _ := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>, <span class="number">64</span>) <span class="comment">// 0:从字符串推断基数， 64:int64</span></span><br><span class="line">    d, _ := strconv.ParseInt(<span class="string">&quot;0x1c8&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    u, _ := strconv.ParseUint(<span class="string">&quot;789&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    k, _ := strconv.Atoi(<span class="string">&quot;135&quot;</span>)</span><br><span class="line">    _, e := strconv.Atoi(<span class="string">&quot;wat&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>文件IO，完全类似c</p>
<p>ReadFile读取整个文件，Read读取几个字节（用<code>make([]byte, size)</code>装),Seek有三种方式io.SeekStart, io.SeekCurrent, io.SeekEnd,bufio提供带缓冲IO</p>
<p>Write, WriteFile, Create, Flush, Sync, WriteString(in bufio)同理</p>
<p>删除文件os.Remove</p>
<p>文件路径<code>path/filepath</code>包，filepath.Join连接路径 Ext得到拓展名， Dir得到文件目录，Base得到文件名</p>
<p>文件夹 os.Mkdir, os.RemoveAll （等效于<code>rm -rf</code>）, os.Chdir, os.ReadDir(得到文件的集合)</p>
<p>WalkDir递归遍历</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">err = filepath.WalkDir(<span class="string">&quot;subdir&quot;</span>, visit)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(path <span class="type">string</span>, d fs.DirEntry, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot; &quot;</span>, path, d.IsDir())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>&#x2F;&#x2F;go:embed 在编译出的二进制文件之中包含</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed folder/single_file.txt</span></span><br><span class="line"><span class="keyword">var</span> fileString <span class="type">string</span>  <span class="comment">// 将folder/single_file.txt的内容放到fileString里面，并在编译时带上该txt</span></span><br></pre></td></tr></table></figure></div>

<p>os.Args 命令行参数</p>
<p>os.Getenv &#x2F; Setenv环境变量</p>
<hr>
<h4 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h4><p>start </p>
<p>r 指定一个wsgi应用实例</p>
<p>GET 路由响应</p>
<p>Run() 可以带一个参数，例如<code>Run(&quot;:9090&quot;)</code>这里使用默认8080</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>路由，GET，POST，PUT，DELETE，…</p>
<p>动态路由，</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;Hello %s&quot;</span>, name)</span><br><span class="line">&#125;) <span class="comment">// 匹配/user/ayanami</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>Query</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配users?name=xxx&amp;role=xxx，role可选</span></span><br><span class="line">r.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	role := c.DefaultQuery(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;%s is a %s&quot;</span>, name, role)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>POST</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">	password := c.DefaultPostForm(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;000000&quot;</span>) <span class="comment">// 可设置默认值</span></span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">		<span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>



<p>热更新：使用air (<a class="link"   href="https://github.com/air-verse/air/blob/master/README-zh_cn.md" >https://github.com/air-verse/air/blob/master/README-zh_cn.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p>重定向</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/redirect&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;/index&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>



<p>上传文件</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/upload1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">	<span class="comment">// c.SaveUploadedFile(file, dst)</span></span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;%s uploaded!&quot;</span>, file.Filename)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>



<p>ShouldBindJson, ShouldBindQuery, ShouldBindUri 将传入的json, xml, uri等尝试解析到某个结构体, 解析失败返回err</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> request dto.CourseDetailRequest</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBindUri(&amp;request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusNotFound, dto.BaseResponse&#123;Message: <span class="string">&quot;参数错误&quot;</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	course, err := service.GetCourseDetail(c, request.CourseID) <span class="comment">// 成功解析就可以用成员变量了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CourseDetailRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	CourseID <span class="type">int64</span> <span class="string">`uri:&quot;courseID&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>指定binding:”required”会拒绝空参数，自动校验</p>
<p>还可以在binding里面指定自定义验证器，具体看官方文档，参数比较多，完成表单验证功能，通过反射</p>
<p>文件上传和返回： FormFile和SaveUploadFile, 还有MaxMultipartMemory</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">	router.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">	router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 单文件, 这里的file实际上是FileHeader的类型，可以有file.Filename .Size得到一些基础信息</span></span><br><span class="line">		file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">		log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">		dst := <span class="string">&quot;./&quot;</span> + file.Filename</span><br><span class="line">		<span class="comment">// 上传文件至指定的完整文件路径</span></span><br><span class="line">		c.SaveUploadedFile(file, dst)</span><br><span class="line"></span><br><span class="line">		c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename))</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>中间件和分组路由</p>
<p>分组：管理路由</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>).Use(publicHandler)</span><br><span class="line">&#123;</span><br><span class="line">	v1.GET(<span class="string">&quot;/posts&quot;</span>, defaultHandler1)</span><br><span class="line">	v1.GET(<span class="string">&quot;/series&quot;</span>, defaultHandler2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>中间件：在请求到达路由的前后进行的一系列操作（例如jwt鉴权）</strong> <code>Use()</code>api</p>
<p>就是一个返回 <code>c *gin.Context</code>的func</p>
<p>Context：某种键值对</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置 example 变量</span></span><br><span class="line">		c.Set(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求前，Next()前</span></span><br><span class="line"></span><br><span class="line">		c.Next() <span class="comment">// 传递给下一个中间件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求后，回来的时候</span></span><br><span class="line">		latency := time.Since(t)</span><br><span class="line">		log.Print(latency)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取发送的 status</span></span><br><span class="line">		status := c.Writer.Status()</span><br><span class="line">		log.Println(status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上是洋葱模式</p>
<p>中间件嵌套 m1 before -&gt; m2 before -&gt; core -&gt; m2 after -&gt; m1 after</p>
<p>还有一个api是 c.Abort() 例如用户验证失败时，调用它阻止继续向下一层中间件传递</p>
<p>上一层Set了之后，下一层就可以从Context里面Get</p>
<p>日志：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 禁用控制台颜色，将日志写入文件时不需要控制台颜色。</span></span><br><span class="line">    gin.DisableConsoleColor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录到文件。</span></span><br><span class="line">    f, _ := os.Create(<span class="string">&quot;gin.log&quot;</span>)</span><br><span class="line">    gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要同时将日志写入文件和控制台，请使用以下代码。</span></span><br><span class="line">    <span class="comment">// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</span></span><br><span class="line"></span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.String(<span class="number">200</span>, <span class="string">&quot;pong&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>自定义日志：看文档</p>
<p>灵活度不够、日志拆分 go-logging, logrus(recommended)</p>
<p>成品日志包</p>
<h3 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h3><p>这个更是依托，全看文档就行，里面一堆指针乱飞和神奇语义和类似Any的字符串反射都是依托</p>
<p>建议始终开文档开发</p>
<p>Open链接，AutoMigrate建表</p>
<p>增删改 Create Delete Update、Updates（Update key value, Updates map&#x2F;struct） (Save) </p>
<p>查 First Find 根据有无ID（主键）决定查全表还是查一个具体的，如果查全表传一个空对象的指针就行，First单个，Find 查切片</p>
<p>条件Where Or 填简单sql</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>Delete默认软删除（如果模型有DeleteAt字段，例如使用gorm.Modal）</p>
<p>用Unscoped().Delete()硬删除</p>
<p>结构体tag + 一对一、一对多、多对多：看文档</p>
<p>有django一脉相承的手动Preload()</p>
<p>JWT: jwt-go 文档</p>
<hr>
<h3 id="实战：jcourse-go"><a href="#实战：jcourse-go" class="headerlink" title="实战：jcourse_go"></a>实战：jcourse_go</h3><p>main.go </p>
<ul>
<li>Init() godotenv从<code>.env</code>文件之中读环境变量</li>
<li>链接Redis, DB, OpenAI api</li>
<li>registerRouter, 启动gin Engine</li>
</ul>
<p>router.go</p>
<ul>
<li><p>InitSession() 从环境变量SESSION_SECRET获取密钥后tcp链接Redis，集成进入gin (Sessions API指定存的地方 NewRedisStore 就行)</p>
</li>
<li><p>路由组：</p>
<ul>
<li>authGroup 登陆相关，不需要auth</li>
<li>needAuthGroup 其他非Admin(teacher, course, review, user) 过中间件 RequireAuth() 判断Session()里面有没有Use</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequireAuth</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		session := sessions.Default(c)</span><br><span class="line">		user := session.Get(constant.SessionUserAuthKey)</span><br><span class="line">		<span class="keyword">if</span> user == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusUnauthorized, dto.BaseResponse&#123;Message: <span class="string">&quot;未授权的请求&quot;</span>&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<ul>
<li>adminGroup 过中间件 RequireAdmin() 就是再加了一个判断User的Role</li>
</ul>
</li>
</ul>
<p>handlers(某种意义上的Controllers in java)</p>
<ul>
<li><p>auth: 很重复的东西</p>
</li>
<li><p>course: </p>
<ul>
<li>Get<ul>
<li>从设置里面拿到page 和pageSize参数构造request</li>
<li>将Query绑定到request(读取参数)</li>
<li>做一个从request的,,,的json形式转换为数组再构造filter结构</li>
<li>传给service的api</li>
<li>返回结果过DTO，Total, Data, Page, PageSize 统一BasePaginateResponse结构</li>
</ul>
</li>
<li>推荐</li>
<li>关注和取消关注</li>
</ul>
</li>
<li><p>ReviewReaction 点赞、踩</p>
</li>
<li><p>ReviewReply 回复</p>
</li>
<li><p>Review </p>
<ul>
<li>CRUD + 推荐， 同course</li>
</ul>
</li>
<li><p>Teacher</p>
</li>
<li><p>User</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>ics备考</title>
    <url>/2024/07/11/ics%E5%A4%87%E8%80%83/</url>
    <content><![CDATA[<p>ics备考</p>
<p>一道Linking,一个VM, 两个Concurrency，一个Network</p>
<ol>
<li>第七章Linking；2. 第9章VM，课程PPT补充的Replacement Policy； 3. 第11章Network，第十章中的RIO；4.  第12章Concurrency，课程PPT补充的Lock。</li>
</ol>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><span id="more"></span>
<p>1.字节序问题，网络大端序。主机使用<code>long htonl(long host)</code>(host to net long)，<code>htons</code>(… short)， <code>ntohl</code></p>
<p>2.常用api</p>
<ul>
<li><p><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 将二进制的网络地址转换为可读的字符串形式，af是<code>AF_INET</code>(ipv4), src是传入地址，dst是目标字符串，size是src大小</p>
</li>
<li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code> 监听sockfd套接字，并将client的连接信息存在addr，如果addr不是NULL，会更新addrlen大小</p>
</li>
<li><p>在监听套接字之前，需要将套接字绑定到某个端口上，书上是<code>listenfd=open_listenfd(port);</code>就行，之后accept listenfd。如果不用辅助函数需要创建套接字、为<code>sockaddr_in addr</code>设置端口、再<code>bind</code>addr和sockfd、再<code>listen(sockfd)</code>发起监听</p>
</li>
<li><p><code>dup2(int fd1, int fd2)</code>将fd1复制到fd2</p>
</li>
<li><p><code>int inet_aton(const char *cp, struct in_addr *inp);</code>将cp字符串的IP解析之后转换为网络序的整数放在inp-&gt;sin_addr里面</p>
</li>
<li><p><code>int inet_pton(int af, const char *src, void *dst)</code>字符串-&gt;二进制，存在dst(in_addr*)里面; af网络族<code>AF_INET</code>ipv4</p>
<p><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 例如inet_ntop(AF_INET, &amp;in, ip_str, sizeof(ip_str)</p>
</li>
<li><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
</li>
<li><p><code>int listen(int sockfd, int backlog);</code> backlog最大请求数</p>
</li>
</ul>
<p><strong>记得Close不用的fd!!!</strong></p>
<p>多线程记得detach <code>pthread_detach(pthread_self())</code></p>
<blockquote>
<p>Detached thread cannot be reaped or killed by other threads, resources are automatically reaped on termination</p>
</blockquote>
<p>Rio相关</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rio_t</span> rio;</span><br><span class="line">Rio_readinitb(<span class="type">rio_t</span>* prio, <span class="type">int</span> fd);</span><br><span class="line">Rio_readlineb(<span class="type">rio_t</span>* prio, <span class="type">char</span> *buf, <span class="type">int</span> maxline);</span><br><span class="line">Rio_readnb(<span class="type">rio_t</span>* prio, <span class="type">char</span> *buf, <span class="type">int</span> sz);</span><br><span class="line">Rio_writen(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> sz);</span><br><span class="line"><span class="comment">// 避免buffer不够，while每次读一个定长（判断是否结束!多读就寄）</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure></div>

<p>why rio:</p>
<ul>
<li>Rubust：错误处理，stdio的相关危险——流并不是真正意义上“双向”的，不能同时读写，如果同时定义两个流绑定到一个fd上又会有close问题</li>
<li>Buffer：比起原始的write&#x2F;read快很多，相当于做了batch——syscall的高开销</li>
</ul>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>1.信号量api</p>
<ul>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value)</code> value初始值。pshared 非0进程间共享，<code>sem_init(&amp;sem, 0, 1);</code></li>
<li><code>sem_wait</code> 书上 <code>P</code>，如果sem &gt; 0, -1，否则挂起等待sem &gt;0</li>
<li><code>sem_post</code> 书上 <code>V</code>,sem+&#x3D;1,唤醒等待进程</li>
</ul>
<p>2.pthread api</p>
<ul>
<li><p><code>pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</code> arg参数，一般整成struct， attr NULL就行</p>
</li>
<li><p><code>int pthread_join(pthread thread, void **retval);</code> retval保存返回值的指针（基本类型直接强制转换就成）</p>
</li>
<li><p><code>pthread_detach(pthread_t tid)</code></p>
</li>
</ul>
<p>例子 </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> t1,t2;</span><br><span class="line">pthread_create(&amp;t1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;t2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>栈帧是线程私有的，堆和全局变量（静态变量）是线程共享的</p>
<p>原子指令</p>
<p>TAS：TestAndSet:取旧设新的原子操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = new; <span class="comment">// store &#x27;new&#x27; into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>CAS: compare_and_swap：如果compare成立，那么写入newval</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_and_swap</span><span class="params">(<span class="type">int</span>* reg, <span class="type">int</span> oldval, <span class="type">int</span> newval)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old_reg_val = *reg;</span><br><span class="line">    <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">       *reg = newval;</span><br><span class="line">    <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>第二类读写问题（writer优先）：定义一个新信号量waiting_writers，读在有waiting_writers或者writer的时候不能进, 写在有reader或者writer的时候不能进</p>
<p>Process &#x3D; thread + code, data, and kernel context（fd, vma, brk pointer）</p>
<p>thread独有的也就一套register&amp;cc+stack(不是严格独有，由于vm是不独有, 可以通过地址摸到其他线程的变量——不安全)+tid</p>
<p>Three basic approaches for concurrent programming</p>
<ul>
<li>Processes</li>
<li>Threads</li>
<li>I&#x2F;O multiplexing</li>
</ul>
<p>其中基于线程和基于进程我们都比较熟悉了，多线程与多进程的区别在于重量级和轻量级。Linux线程比进程少复制这几个东西（和其他线程共享）：整个VM，文件相关（file structure and fd），信号处理。线程的核心就在于减少进程切换开销。</p>
<blockquote>
<p>对于LinuxThreads，它使用(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)参数来调用clone()创建”线程”，表示共享内存、共享文件系统访问计数、共享文件描述符表，以及共享信号处理方式。（其中前三个标志对应共享的数据结构分别为task_struct中的mm,fs,files）。</p>
</blockquote>
<p>CLONE_VM 代表没有独立的vma, 没有独立的pagetable和heap；CLONE_FS 代表没有独立的文件系统信息，线程的当前文件夹等是共享的；CLONE_FILES 代表没有独立的文件描述符信息，对文件的操作是共享的（这引出一个注意点就是文件在多线程的情况下，尤其是webserver一定要在某个线程显式关闭，否则有线程不结束进程就不结束，fd就不回收） CLONE_SIGHAND 代表共享一套信号系统</p>
<p>而基于IO多路复用，又叫事件驱动编程，主要是针对这几个问题：</p>
<ul>
<li>线程数有限,线程开销依然大,无法承受高并发,且大多都是IO的情况下,对于IO任务不一定需要开线程</li>
<li>IO是堵塞的,类似web server,网络波动或者代码问题就会死住,希望有非堵塞服务</li>
<li>死锁活锁问题的易产生、难debug</li>
<li>并发依赖系统调度策略，难以定制和进一步调优</li>
</ul>
<p>IO多路复用就是使用select,epoll等系统调用去监听许多文件描述符（又或者它们主动中断，例如某些异步IO）。利用底层提供的aio等非阻塞IO api,避免任何阻塞，只有一个单线程主线程处理“某个fd上IO完成”这类的事件（常见于放入某个事件队列之中）。在GUI桌面编程，webserver等场景非常常见。</p>
<p>IO多路复用的问题在于：</p>
<ul>
<li>和某些底层机制，例如page，配合不好，pagefault还是会产生堵塞，不能非堵塞</li>
<li>编程相较多线程和多进程复杂，事件驱动强制要求异步和一些数据结构的包装和相关推断</li>
<li>更难适配现代多核机器</li>
</ul>
<p>thread_local：线程独有 <strong>thread_local</strong> <strong>int</strong> <strong>i</strong>&#x3D;0; 常用于随机数，errno</p>
<p>多进程的webserver: 必须回收僵尸进程（产生原因，父进程正忙（例如休眠），没有办法回收子进程资源）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Signal(SIGCHLD, sigchld_handler);</span><br></pre></td></tr></table></figure></div>



<h5 id="锁api"><a href="#锁api" class="headerlink" title="锁api"></a>锁api</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure></div>

<p>早期锁实现：开关中断——低效，不安全，特权操作，多核不正确 现在很少用</p>
<p>软件TAS：多核不正确</p>
<p>CAS(X86) , LL&amp;SC(ARM)， FAA（fetch and add-&gt;atomic_add-&gt;ticket lock）</p>
<p>自旋锁多核可接受, 避免自旋——yield(), 少cpu好，多cpu烂 -&gt;queue, park() Unpark(tid)</p>
<p>自旋锁用循环的缺点——信号问题，可以考虑用<code>sigsuspend</code>代替实现</p>
<h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><p>cache认为大都是PIPT，少数拓展题VIPT</p>
<p>x86每个PTE 8Byte（32位地址空间）</p>
<p>目前的x86_64架构CPU都遵循AMD的Canonical Form,<strong>即只有虚拟地址的最低48位才会在地址转换时被使用, 且任何虚拟地址的48位至63位必须与47位一致, 也就是说总的虚拟地址空间为256TB。</strong></p>
<p><strong>0000000000000000 – 00007fffffffffff(128TB)为用户空间,</strong><br><strong>ffff800000000000 – ffffffffffffffff(128TB)为内核空间。</strong></p>
<p>4级页表，9位一级，512 * 8 &#x3D; 4KB  4*9+12 &#x3D; 48</p>
<p>PTE结构  VA &#x3D; VPN + VPO， PA&#x3D;PPN+PPO PPO&#x3D;VPO       VPN&#x3D;Tag + Index</p>
<p>第Index个，比较Tag决定 TLB hit &#x2F; TLB miss</p>
<p>PTE |valid bit|PPN  index是VPN，和cache不同，没有tag。注意是存VA-&gt;PA的映射，所以和PA-&gt;PA无关</p>
<p>cache：full-associate, N-way, direct associate</p>
<p>缓存区溢出攻击：利用%rbp存栈帧基址，且M[%rbp]存上一个栈帧的%rbp，M[%rbp+8]存返回值，如果覆盖M[%rbp+8]就能缓存区溢出攻击</p>
<p>共享级别：</p>
<ul>
<li>vnode table（文件系统对象表）是进程级别共享的</li>
<li>堆、fd、installed handler(代码段)、… 这些是线程级别共享的（依赖于本进程的VM）</li>
<li>寄存器、CC、栈等是不共享的</li>
</ul>
<p>共享库（Shared Libs）在vm内存模型之中是PRIVATE的</p>
<p>COW也是vma之中PRIVATE的flag</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>mmap是一个系统调用，将某个文件和内存上的一段虚拟地址对应起来。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">int</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">int</span> offset)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中，start是（建议的）内存起始段（实际的由OS决定，一般设置成-1就行），prot是权限，flags是是否shared之类，fd为某个磁盘打开的文件或-1（匿名文件）offset指定文件的起始段</p>
<p>mmap可以实现快速文件拷贝等操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * use mmap to copy file to stdout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmapcopy</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">char</span>* bufp;</span><br><span class="line">	bufp = mmap(<span class="number">0</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">	write(<span class="number">1</span>, bufp, size);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>省去了用户态的拷贝到buffer + syscall的开销</p>
<p>如果是private的mapping，是不会写回文件的(COW维护自己的副本)。而如果是shared的mapping，是会写回文件的（直接操作原始的文件，只有一个副本）。</p>
<p>通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高， read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了 <strong>两次数据拷贝</strong> ；而mmap()也是系统调用，如前所述，<strong>mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的</strong>，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 <strong>一次数据拷贝</strong> 。因此，内存映射的效率要比 read&#x2F;write效率高。</p>
<p><code>MAP_PRIVATE</code>如果是<code>MAP_SHARED</code>,就会是进程间真共享, 如果再搭配<code>MAP_ANON</code>（指定mmap的不是实际文件，只是虚拟的页，初始全0）,则能够达到进程间通信的效果，例如<code>MAP_SHARED|MAP_ANON</code>后fork子进程</p>
<h4 id="Replacement-policy"><a href="#Replacement-policy" class="headerlink" title="Replacement policy"></a>Replacement policy</h4><p>OPT, LRU, FIFO, RANDOM</p>
<p>在random负载，任何实际策略都差不多</p>
<p>在80-20冷热负载，LRU优于FIFO和RANDOM</p>
<p>但在循环负载，LRU和FIFO都非常差，所以选用何种策略depends</p>
<p>Random fares notably better</p>
<ul>
<li><p>not quite approaching optimal, but at least achieving a non-zero hit rate</p>
</li>
<li><p>not having weird corner-case behaviors</p>
</li>
<li><p><strong>used as TLB replacement policy</strong></p>
</li>
</ul>
<p>近似LRU，时钟算法</p>
<p>page out: select policy：demand paging, prefetching, clustering&amp;grouping (watermark)</p>
<p>thrash control: admission control, OOM killer</p>
<p>如何在physical page获取ref bit来执行时钟算法——reverse mapping （ref bit由硬件set，由软件clear）（dirty bit在level2（1G）3（2M）4之中有——最后一页）</p>
<p>可以evict pagetable page吗？ ——除了level1也不是不行</p>
<p>可以evict OS page吗？——一般不行，会设置不允许page out的PTE bit</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>rax: accumulator register，<strong>累加寄存器</strong>，只是通过RAX存储函数<strong>返回值</strong>属于惯例。<br>rbx: base register，<strong>基址寄存器</strong>，一般用于访问内存的基址<br>rcx: counter register，<strong>计数寄存器</strong>。一般用于循环计数。<br>rdx: 数据寄存器，能够暂存一般性数据。<br>rsi: source index，<strong>源变址寄存器</strong>，字符串运算时常应用于源指针。<br>rdi: destination index，<strong>目标变址寄存器</strong>，字符串运算时常用于目标指针。<br>rsp: Stack Pointer，<strong>栈指针寄存器</strong>。它包含了当前栈顶的内存地址。<br>rbp: Base Pointer，<strong>基址指针寄存器</strong>。它通常用于指向<strong>当前栈帧的基址</strong>，即指向当前函数的栈帧的起始位置。在函数中，局部变量和其他数据可以通过 RBP 来访问。<strong>RBP 的值在函数调用时保持不变，因此可以作为一个固定的参考点来访问栈上的数据</strong>。<br>rip: Instruction Pointer，<strong>指令指针寄存器。它包含了将要执行的下一条指令的内存地址</strong>。<br>R8-R15: 一般是可以任意使用的，不指定特定用途，支持拆分。</p>
<h4 id="ostep补充"><a href="#ostep补充" class="headerlink" title="ostep补充"></a>ostep补充</h4><h5 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h5><p>性能：如果简单的方案就能工作，就不需要精巧的设计</p>
<p>多线程测试：对于一个任务，改变线程数，测试耗时</p>
<p>理想情况：多线程在多处理上就像单线程一样快（完美拓展）</p>
<p>并发计数器：naive的想法一直加锁解锁的拓展性是差的，会带来很高的性能损失</p>
<p>可拓展计数器：sloppy counter懒惰计数</p>
<p>N个cpu，N个线程，开N个局部计数器和一个全局计数器，共N+1个锁</p>
<p>定一个阈值S，只有当局部计数器的计数&gt;S的时候，才更新全局计数器，并将局部计数器归0</p>
<p>虽然局部计数器也要开锁解锁，但是由于只有全局计数器才会真正的竞争（意味着线程的挂起和调度、恢复等耗时操作），所以当S大的时候，性能很好，但计数器的精度低；当S小时，趋于naive的计数器</p>
<p>并发链表：</p>
<ol>
<li>并发的异常控制流，像是malloc这种可能会失败，但是失败概率不高的，如果需要在里面进行锁相关的操作，容易出错；更好的方法是调整语句顺序，只在真正竞态的语句前面加锁，执行完之后解锁，而不是一进入函数就加锁</li>
<li>拓展链表：上面链表的问题，拓展性差。一种理论上的解决方法是过手锁（也叫锁耦合，每个节点都有一个锁，遍历到下一个节点的时候，抢下一个节点的，释放当前节点的）（虽然实际效果不好）</li>
</ol>
<p>对于任意的数据结构，总有一个naive的并发方法：加全局的一把大锁</p>
<p>并发队列：Michael &amp; Scott 核心思想是对于头和尾，各自维护一把锁</p>
<p>这样使得入队和出队操作被分开，可以并行执行：入队获取尾锁，出队获取头锁，如果出队完队空则释放所有锁（最开始队列不是空，而是给了一个假节点）</p>
<p>并发hash：每个节点一个锁，然后每个节点是一个并发链表</p>
<p>由于每个节点的锁是独立的，并发hash的性能很好，实现也简单，被大量使用</p>
<p>“不成熟的优化是所有坏事的根源”，先从简单方案做起并发数据结构（即加一把大锁）</p>
<p>进一步方向： 更复杂的数据结构，如并发B树；不用锁的非阻塞新方案</p>
<h5 id="VM-1"><a href="#VM-1" class="headerlink" title="VM"></a>VM</h5><ul>
<li>区分on demand paging和swap out</li>
</ul>
<p>如果PTE是全0，从来没有过-&gt;on demand paging</p>
<p>如果PTE是有地址的，只不过后面的present&#x2F;valid&#x2F;…是0-&gt;swap out</p>
<ul>
<li>区分demand paging和COW -&gt;直接看vma上的标记位就行，COW是vma的事情</li>
</ul>
<p>OS还要维护一个和物理页一一对应的数据结构(因为不可能扫描虚拟页——太多了), 来辅助swap page的算法——例如LRU,FIFO,clock（近似LRU） 很多算法都要求记录访问频率之类，那就需要在struct page之中存储所有进程的VM之中指向它的pte的list，同时记录物理页的属性（例如non-swap，像OS page和pagetable page就不应该被交换下去（这个在PTE里面也有相关bit））。这个在struct page（PM）里面存VM（pte）的操作称为reverse mapping反向映射</p>
<p>swap space:在硬盘上开辟page in &amp;&amp; page out的空间</p>
<p>正常的内存引用 <strong>VA→TLB→pagetable</strong></p>
<p>如果想要让部分的page能够在硬盘之中以支持更大的地址空间，那么我们需要在PTE里面再加一个present bit，表示页是否在内存之中</p>
<p>那OS如何知道页在硬盘上的哪里呢？位置信息写在原来的PFN等地方</p>
<p>硬盘IO，进程block(调度到其他进程)，等待IO完毕之后重试指令（根据OS设计决定更不更新TLB,如果这时候不更新，重试指令TLB miss也会更新)</p>
<p>内存满了——页交换策略</p>
<p>在这种情况可以用比如!PTE_V区分是segmentation fault,用PTE_V&amp;&amp;!PTE_P来区分是page fault</p>
<p>实际上OS并不是当内存满了才开始swap page，而是有一个High watermark（HW）和 Low watermark (LW), 当OS发现有少于LW个页可用的时候，会启动内存交换进程（swap&#x2F;page daemon）直到有HW个页可用</p>
<p>把一些工作放在后台有助于OS调度、合并操作</p>
<p>判断策略优劣：AMAT（Average Memory Access Time） 或者 和 最优替换策略（总是换出最远将来将要被换出的页）进行比较</p>
<p>简单策略：FIFO、随机、LRU（Least Recently Used）</p>
<ul>
<li>没有局部性，几种策略相差不大</li>
<li>八二分布，即80%情况访问20%热门页，LRU好</li>
<li>循环引用，LRU和FIFO差，随机好</li>
</ul>
<p>实现LRU：完美LRU非常耗费资源(需要统计频率信息），通常用近似LRU，添加一个use bit(也称ref bit),有比如<strong>时钟算法等（随机遍历，如果引用位为1，设为0；替换找到第一个为0的；引用时设为1）</strong></p>
<p>也可以考虑脏页，由于踢出干净的页是低成本的（可以不写回磁盘，拿去干别的事情，例如分配内存）</p>
<p>何时将页载入内存？页选择策略（page selection）。大多数OS按需取页（demand paging）但也有不少OS实现了prefetching,例如使用页P时，提前将P+1载入内存</p>
<p>何时将页写入磁盘？OS也可以cluster或者group一些page之后再进行写入，而不是有一个页就写一次来优化</p>
<p>如果一个进程需要的内存超过了可用的总物理内存？结果是不断交换页, 被称为抖动thrashing, 有些OS会让系统运行复杂的检测来决定不运行部分进程，另一些系统在内存不足时会唤起一个杀手进程直接选择某些内存密集型程序杀掉</p>
<p>现在很有意思的情况是，内存和硬盘访问时间相差得越来越大，所以页替换算法的重要性有所降低（因为页放到硬盘的代价昂贵），“过度分页的最佳解决方案往往很简单：购买更多的内存”</p>
<h5 id="基于事件并发"><a href="#基于事件并发" class="headerlink" title="基于事件并发"></a>基于事件并发</h5><p>GUI应用， nodejs</p>
<p>基本想法是基于事件的循环：只有一个主线程，它一直进行“接收事件——处理事件”的循环</p>
<p>如何接收事件？基于操作系统的select和poll API，定时检查网络和IO的文件描述符fd是否有值得注意的写入</p>
<p>只有一个线程的好处是避免了死锁等并发问题，问题在于如果主线程阻塞了怎么办？</p>
<p>没有办法，主线程就阻塞了，无法进行切换，所以不能让主线程阻塞。</p>
<p>但是IO、网络这些操作都是可能阻塞的，因此引入了异步IO（AIO）, 当发起可能阻塞的事件处理的时候，主线程先往下走，等待操作完成之后通过中断（Unix signal）或轮询等方法得知操作处理结果。</p>
<p>但这个操作比多线程复杂，往下走的时候需要通过某种数据结构来记录依赖于这个结果的信息（通过打开的文件描述符）然后IO完成时，通过文件描述符查找这个数据结构，再去处理这些信息</p>
<p>实际上还有很多其他复杂性……</p>
<p>写出正确的并发程序：</p>
<ol>
<li>尽可能简单，避免复杂线程交互</li>
<li>使用已经被证实的线程交互方式（比如锁，或者生产者－消费者队列）</li>
<li>只在一定要使用的时候才并发，过早优化是糟糕的</li>
<li>采取map-reduce等无锁和条件变量的简单成熟算法</li>
</ol>
<h4 id="笔记节选"><a href="#笔记节选" class="headerlink" title="笔记节选"></a>笔记节选</h4><h5 id="x86大页"><a href="#x86大页" class="headerlink" title="x86大页"></a>x86大页</h5><p>4K, 2M, 1G,后两个超级块怎么实现？</p>
<p>实际上非常简单，x86 四级页表每个512 entry,8字节一个entry, 一个页表4KB，一个页也是4KB</p>
<p>超级页只需要讲entry里面的PG位设置成1——以此来标记不需要后面几级页表了——就行，4KB * 512 &#x3D; 2MB，2MB * 512 &#x3D; 1GB。很是巧妙。</p>
<p>大页的好处：</p>
<ul>
<li>占据TLB entry数量更小</li>
<li>页表翻译速度上升</li>
</ul>
<p>坏处：空间利用率低（inner fragmentation）</p>
<p>目前的x86_64架构CPU都遵循AMD的Canonical Form,<strong>即只有虚拟地址的最低48位才会在地址转换时被使用, 且任何虚拟地址的48位至63位必须与47位一致, 也就是说总的虚拟地址空间为256TB。</strong></p>
<p>0000000000000000 – 00007fffffffffff(128TB)为用户空间,</p>
<p>ffff800000000000 – ffffffffffffffff(128TB)为内核空间。</p>
<p>4级页表，9位一级，512 * 8 &#x3D; 4KB 4*9+12 &#x3D; 48</p>
<h5 id="page-attribute"><a href="#page-attribute" class="headerlink" title="page attribute"></a>page attribute</h5><p>OS做页分配的时候，页有三种attribute uncached, unalloced, cached</p>
<p>另外两种很好理解，uncached实际上就是COW，理解这一点可以这样追溯：</p>
<p>cached的page实际上对应一段data，这一段data是运行时产生的或者ELF文件之中存储的（也就是存储在实际的磁盘上的），而内存扮演了磁盘的cache的角色。在编译时分配的时候，OS记住数据所在的VM段与磁盘位置的映射关系，设置为uncached。当触发pagefault的时候，从磁盘加载到内存，分配物理页，并更新pagetable——此时uncached变成cached</p>
<p>pagefault一般也有几种情况：</p>
<ul>
<li>Swapped in or paged in</li>
<li>Demand paging</li>
<li>Segmentation fault</li>
</ul>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>内部碎片和外部碎片：</p>
<p>内部: playload和实际消耗的差距，align padding 和 header &amp; footer</p>
<p>外部: 过于细碎导致装不下——和负载有关，难以衡量</p>
<p>三种策略：first fit, next fit, best fit</p>
<p>显式&#x2F;隐式空闲链表：hdr &amp; ftr，8 bytes alignment -&gt; {block &amp; alloc bit}，利用对齐后三位是0</p>
]]></content>
  </entry>
  <entry>
    <title>linking 复习</title>
    <url>/2024/07/11/linking-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>linking 复习</p>
<h4 id="No-linker-Problems"><a href="#No-linker-Problems" class="headerlink" title="No linker Problems"></a>No linker <strong>Problems</strong></h4><p>• efficiency: small change requires complete recompilation</p>
<p>• modularity: hard to share common functions (e.g. printf)</p>
<span id="more"></span>


<p>seperate compilation: <em>separately compiled relocatable object files</em></p>
<p>reloc object files -&gt; executable object file </p>
<h4 id="What-is-linker"><a href="#What-is-linker" class="headerlink" title="What is linker"></a>What is linker</h4><ul>
<li><p>Linking is the process of: collecting and combining various pieces of code and data into a single executable file</p>
</li>
<li><p>Executable file: Can be loaded (copied) into memory and executed</p>
</li>
</ul>
<p>Linking can be performed</p>
<ul>
<li><p>at compile time, when the source code is translated into machine code by the linker</p>
</li>
<li><p>at load time, when the program is loaded into memory and executed by the loader</p>
</li>
<li><p>at run time, by application programs</p>
</li>
</ul>
<p>编译过程：preprocessor -&gt; compiler -&gt; assembler -&gt; linker</p>
<h4 id="Static-Linking"><a href="#Static-Linking" class="headerlink" title="Static Linking"></a>Static Linking</h4><p>Input:</p>
<p>A relocatable object files and command line arguments</p>
<p>Output:</p>
<p><strong>Fully linked</strong> executable object file that can be loaded and run</p>
<h5 id="Relocatable-object-file"><a href="#Relocatable-object-file" class="headerlink" title="Relocatable object file"></a>Relocatable object file</h5><p>Contain binary code and data in a form that can be combined with other relocatable object files to create an executable file</p>
<h5 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h5><ul>
<li><p>Various code and data sections</p>
</li>
<li><p>Instructions are in one section</p>
</li>
<li><p>Initialized global variables are in one section</p>
</li>
<li><p>Uninitialized global variables are in one section</p>
</li>
</ul>
<h5 id="External-reference"><a href="#External-reference" class="headerlink" title="External reference"></a>External reference</h5><ul>
<li><p>Reference to a symbol defined in another object file</p>
</li>
<li><p>The external references are <strong>value 0</strong> in the relocatable object files in the previous example</p>
</li>
</ul>
<p>Symbol resolution: Resolves external references</p>
<p>Relocates <em>symbols</em></p>
<ul>
<li><p>from their relative locations in the .o files </p>
</li>
<li><p>to new absolute positions in the executable</p>
</li>
</ul>
<h4 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h4><ul>
<li><p>Relocatable object file</p>
</li>
<li><p>Executable object file</p>
</li>
<li><p>Shared object file(A special type of relocatable object file that <strong>can be loaded into memory and linked dynamically, at either load time or run time</strong>)</p>
</li>
</ul>
<h4 id="Executable-and-Linkable-Format-ELF"><a href="#Executable-and-Linkable-Format-ELF" class="headerlink" title="Executable and Linkable Format (ELF)"></a><strong>Executable and Linkable Format (ELF)</strong></h4><ul>
<li><p>Standard binary format for object files</p>
</li>
<li><p>Derives from AT&amp;T System V Unix</p>
</li>
<li><p>later adopted by BSD Unix variants and Linux</p>
</li>
<li><p>One unified format for relocatable object files (.o), executable object files, and shared object files (.so)</p>
</li>
<li><p>generic name: ELF binaries</p>
</li>
<li><p>Better support for shared libraries than old a.out formats.</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/mqs1U3JAKW27EFi.png"
                      alt="image-20240618152139316"
                ></p>
<h5 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h5><p>The first part is very important,used to store meta data usually</p>
<p>magic number, type (.o, exec, .so), machine, byte ordering, Beginning of the section header table (as well as the program header table), etc</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span>	Elf64_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span>	Elf64_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span>	Elf64_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>	Elf64_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span>	Elf64_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>	Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span>	Elf64_Lword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span>	Elf64_Xword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> 	e_ident[<span class="number">16</span>]; 	<span class="comment">/* ELF identification */</span>  </span><br><span class="line">	Elf64_Half 		e_type; 	<span class="comment">/* Object file type ET_REL(1)、ET_EXEC(2)、ET_DYN(3)(shared) */</span></span><br><span class="line">	Elf64_Half 		e_machine; 	<span class="comment">/* Machine type EM_386(3)、EM_IA_64(50)*/</span></span><br><span class="line">	Elf64_Word 	e_version; 	<span class="comment">/* Object file version */</span></span><br><span class="line">	Elf64_Addr 	e_entry; 	<span class="comment">/* Entry point address */</span></span><br><span class="line">	Elf64_Off 		e_phoff; 	<span class="comment">/* Program header offset */</span></span><br><span class="line">	Elf64_Off 		e_shoff; 	<span class="comment">/* Section header offset */</span></span><br><span class="line">	Elf64_Word 	e_flags; 	<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	Elf64_Half 		e_ehsize; 	<span class="comment">/* ELF header size */</span></span><br><span class="line">	Elf64_Half 		e_phentsize; 	<span class="comment">/* Size of program header entry */</span></span><br><span class="line">	Elf64_Half 		e_phnum; 	<span class="comment">/* Number of program header entries */</span></span><br><span class="line">	Elf64_Half 		e_shentsize; 	<span class="comment">/* Size of section header entry */</span></span><br><span class="line">	Elf64_Half 		e_shnum; 	<span class="comment">/* Number of section header entries */</span></span><br><span class="line">	Elf64_Half 		e_shstrndx; 	<span class="comment">/* Section name string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure></div>

<p>e_ident[0-3] ‘0x7f’ ‘E’ ‘L’ ‘F’    magic number</p>
<p>e_ident[4] 1(32-bit) &#x2F; 2(64-bit)</p>
<p>e_ident[5] 1(little) &#x2F; 2(big)</p>
<p>e_ident[15] size of e_ident[]</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elf64_Word    sh_name;	<span class="comment">/* Section name (index into the section header string table). */</span> </span><br><span class="line">	Elf64_Word    sh_type;	<span class="comment">/* Section type. SHT_PROGBITS、SHT_SYMTAB 、SHT_STRTAB、SHT_REL、SHT_NOBITS </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	Elf64_Xword  sh_flags;	<span class="comment">/* Section flags. */</span></span><br><span class="line">	Elf64_Addr	    sh_addr;	<span class="comment">/* Address in memory image.(If the section will be copied into the memory to execute, this member gives the address at which the section’s first byte should reside </span></span><br><span class="line"><span class="comment">) */</span></span><br><span class="line">	Elf64_Off	    sh_offset;	<span class="comment">/* Offset in file. (the byte offset from the beginning of the file to the first byte in the section) */</span></span><br><span class="line">	Elf64_Xword  sh_size;	<span class="comment">/* Size in bytes. */</span></span><br><span class="line">	Elf64_Word    sh_link;	<span class="comment">/* Index of a related section. */</span></span><br><span class="line">	Elf64_Word    sh_info;	<span class="comment">/* Depends on section type. */</span></span><br><span class="line">	Elf64_Xword  sh_addralign;	<span class="comment">/* Alignment in bytes. */</span></span><br><span class="line">	Elf64_Xword  sh_entsize;	  <span class="comment">/* Size of each entry in section. (Some sections hold a table of fixed-size entries, this member gives the size in bytes of each entry)*/</span> </span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></div>

<h5 id="ELF-String-Table"><a href="#ELF-String-Table" class="headerlink" title="ELF String Table"></a>ELF String Table</h5><ul>
<li><p>Hold null-terminated character sequences (strings) </p>
</li>
<li><p>The object file uses these strings to represent symbol and section names</p>
</li>
<li><p>One references a string as an index into the string table section</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/eha1s3qotpK5vXM.png"
                      alt="image-20240618153451314"
                ></p>
<h5 id="Other-Sections"><a href="#Other-Sections" class="headerlink" title="Other Sections"></a>Other Sections</h5><ul>
<li><p>debug section: debugging symbol table, local variables and typedefs, global variables, original C source file (gcc -g)</p>
</li>
<li><p>.line: Mapping between line numbers in the original C source program and machine code instructions in the .text section.</p>
</li>
</ul>
<h5 id="Sections-in-ELF-obj-file"><a href="#Sections-in-ELF-obj-file" class="headerlink" title="Sections in ELF obj file"></a>Sections in ELF obj file</h5><ul>
<li><p>.text section: code 代码</p>
</li>
<li><p>.rodata section: Read-only data</p>
</li>
<li><p>.data section: initialized global and static C variables</p>
</li>
<li><p>.bss section (“Block Started by Symbol” or “Better Save Space”)</p>
</li>
</ul>
<p>–<strong>uninitialized</strong> global and static C variables, along with any global or static variables that are <strong>initialized to zero</strong></p>
<p>–<strong>has section header but occupies no disk space</strong></p>
<p>–at run time, these variables are allocated in memory with initial value zero</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><ul>
<li><p>Defined global symbols</p>
</li>
<li><p>Referenced global symbols</p>
</li>
<li><p>Local symbols(C functions and global variables with static attribute)</p>
</li>
</ul>
<p>局部非静态变量不是symbol, 不在.symtab段占有空间</p>
<p><strong>Each relocatable object file has a symbol table in .symtab section</strong></p>
<p>Symbol Table包含了：</p>
<ol>
<li><p>the module（file） that defines the symbol </p>
</li>
<li><p>the symbol type (local,global,extern)</p>
</li>
<li><p>the section (.text,.data,.bss)</p>
</li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">int</span> 	name ;		<span class="comment">/* the name in string table&#x27;s (byte) offset */</span></span><br><span class="line">	<span class="type">char</span> 	type:<span class="number">4</span>;	<span class="comment">/* function or data (4 bits) (usually，还有一些别的)*/</span></span><br><span class="line"> 	   	binding:<span class="number">4</span> ;	<span class="comment">/* local or global  (4 bits) */</span></span><br><span class="line"> 	<span class="type">char</span> 	reserved ;	<span class="comment">/* unused */</span></span><br><span class="line"> 	<span class="type">short</span> 	section ;	<span class="comment">/* section header index */</span></span><br><span class="line">  	<span class="type">long</span> 	value ;		<span class="comment">/* section offset(for relocatable), or abs address(for executable) */</span></span><br><span class="line"> 	<span class="type">long</span>	size ;		<span class="comment">/* Object size in bytes */</span></span><br><span class="line">&#125; Elf64_Symbol ;</span><br></pre></td></tr></table></figure></div>



<p>**Each symbol is assigned to some section of the object file, denoted by the section field, which is an index into the section header table.**Symbol和某个Section绑定，具体方法是Symbol记录对应Section在Section Header Table之中的index </p>
<p>There are three special pseudosections that <strong>don’t have entries in the section header table</strong></p>
<ul>
<li><p>ABS: symbols that should not be relocated </p>
</li>
<li><p>UNDEF: symbols that are referenced in this object module but defined elsewhere</p>
</li>
<li><p>COMMON: uninitialized data objects</p>
</li>
</ul>
<p>They only exist only in relocatable object files and do not exist in executable object files</p>
<p>For COMMON symbols</p>
<ul>
<li><p>value gives the alignment requirement</p>
</li>
<li><p>size gives the minimum size</p>
</li>
</ul>
<p><strong>重要</strong>:<strong>The difference between COMMON and .bss</strong></p>
<p>COMMON：<strong>Uninitialized global</strong> variables</p>
<p>.bss：<strong>Uninitialized static</strong> variables, <strong>global or static</strong> variables that are <strong>initialized to zero</strong></p>
<h5 id="重要！！！！！"><a href="#重要！！！！！" class="headerlink" title="重要！！！！！"></a>重要！！！！！</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/AKg2mf34LIXlDr7.png"
                      alt="image-20240618160330533"
                ></p>
<h5 id="重名问题"><a href="#重名问题" class="headerlink" title="重名问题"></a>重名问题</h5><p>强符号： 初始化的全局变量，函数</p>
<p>弱符号： 未初始化的全局</p>
<p>重名：强+强，报错；强+弱，覆盖；弱+弱，任意</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><ul>
<li><p><strong>concatenate related relocatable object files into a single file with an index (called an archive， .a)</strong></p>
</li>
<li><p>enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives</p>
</li>
<li><p><strong>If an archive member file resolves reference, link into executable</strong></p>
</li>
</ul>
<p>使用静态链接：经典EUD</p>
<blockquote>
<ol>
<li><p>Scan .o files and .a files in the <strong>command line order.</strong></p>
</li>
<li><p>When scan an object file f,</p>
</li>
</ol>
<ul>
<li><p>Add f to E</p>
</li>
<li><p>Updates U, D</p>
</li>
</ul>
<ol start="3">
<li>When scan an archive file f,</li>
</ol>
<ul>
<li><p>Resolve U</p>
</li>
<li><p>If m is used to resolve symbol, m is added to E</p>
</li>
<li><p>Update U, D using m</p>
</li>
</ul>
<ol start="4">
<li>If any entries in the unresolved list at end of scan, then error</li>
</ol>
</blockquote>
<p>问题：command line order matters! </p>
<p>原则：总是把链接的库放在最后面，并且可以重复</p>
<h4 id="Relocation"><a href="#Relocation" class="headerlink" title="Relocation"></a>Relocation</h4><p>For each <strong>reference to an object with unknown location</strong></p>
<ul>
<li><p>Assembler generates a relocation entry</p>
</li>
<li><p>Relocation <strong>entries for code</strong> are placed in <strong>.rel.text</strong></p>
</li>
<li><p>Relocation <strong>entries for data</strong> are placed in <strong>.rel.data</strong></p>
</li>
</ul>
<p>例如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">09      e8 00 00 00 00	callq e&lt;main+0xe&gt; swap();</span><br><span class="line">/* There is a relocation entry in rel.text */</span><br><span class="line"></span><br><span class="line">offset   symbol	type			addend</span><br><span class="line">    0a   swap	R_X86_64_PC32   	-4  /* PC32: PC-relative */</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>.rel.text section</p>
<ul>
<li><p><strong>relocation info for .text section</strong></p>
</li>
<li><p><strong>addresses of instructions</strong> that will need to be modified in the merged executable object file</p>
</li>
</ul>
<p>.rel.data section</p>
<ul>
<li>relocation info for .data section</li>
<li>addresses of <strong>pointer data</strong> that will need to be modified in the merged executable object file</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">long</span>  offset ;</span><br><span class="line">   <span class="type">long</span>  type:<span class="number">32</span> ,</span><br><span class="line">         symbol:<span class="number">32</span> ;</span><br><span class="line">   <span class="type">long</span>  addend;</span><br><span class="line"> &#125; Elf64_Rela ;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *bufp0 = &amp;buf[<span class="number">0</span>] ;</span><br><span class="line"><span class="number">00000000</span> &lt;bufp0&gt;:</span><br><span class="line">	<span class="number">0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">/* There is a relocation entry in rel.data */</span></span><br><span class="line">offset   symbol	type			addend</span><br><span class="line">    <span class="number">0</span>	   buf	R_X86_64_64   	<span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p><code>addend</code>是重定位条目中的一个数值，它在链接时与符号的地址相加，以确定最终的内存地址。这个参数提供了一种机制，允许编译器生成更灵活和可移植的代码。</p>
<p><strong>Two steps</strong></p>
<ul>
<li><p><strong>Relocating sections and symbol definitions</strong></p>
</li>
<li><p><strong>Relocating symbol references within sections</strong></p>
</li>
</ul>
<p>reloc过程的伪代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset ; <span class="comment">/* ptr to reference to be relocated */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* relocate a PC-relative reference */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset ; <span class="comment">/* ref’s runtime address */</span></span><br><span class="line">            *refptr=(<span class="type">unsigned</span>) (ADDR(r.symbol)+r.addend–refaddr) ;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* relocate an absolute reference */</span></span><br><span class="line">         <span class="keyword">if</span> ( r.type == R_X86_64_64 || r.type == R_X86_64_32||…)</span><br><span class="line">              *refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend) ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="Executable-ELF-Object"><a href="#Executable-ELF-Object" class="headerlink" title="Executable ELF Object"></a>Executable ELF Object</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/ejWVEqtyn9YJbzi.png"
                      alt="image-20240618163520190"
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> 	e_ident[<span class="number">16</span>]; 	<span class="comment">/* ELF identification */</span></span><br><span class="line">	Elf64_Half 		e_type; 	<span class="comment">/* Object file type */</span></span><br><span class="line">	Elf64_Half 		e_machine; 	<span class="comment">/* Machine type */</span></span><br><span class="line">	Elf64_Word 	e_version; 	<span class="comment">/* Object file version */</span></span><br><span class="line">	Elf64_Addr 	e_entry; 	<span class="comment">/* Entry point address */</span></span><br><span class="line">	Elf64_Off 		e_phoff; 	<span class="comment">/* Program header offset */</span></span><br><span class="line">	Elf64_Off 		e_shoff; 	<span class="comment">/* Section header offset */</span></span><br><span class="line">	Elf64_Word 	e_flags; 	<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">	Elf64_Half 		e_ehsize; 	<span class="comment">/* ELF header size */</span></span><br><span class="line">	Elf64_Half 		e_phentsize; 	<span class="comment">/* Size of program header entry */</span></span><br><span class="line">	Elf64_Half 		e_phnum; 	<span class="comment">/* Number of program header entries */</span></span><br><span class="line">	Elf64_Half 		e_shentsize; 	<span class="comment">/* Size of section header entry */</span></span><br><span class="line">	Elf64_Half 		e_shnum; 	<span class="comment">/* Number of section header entries */</span></span><br><span class="line">	Elf64_Half 		e_shstrndx; 	<span class="comment">/* Section name string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elf64_Word    p_type;       <span class="comment">/* Entry type.(PT_LOAD (1): loadable segment) */</span></span><br><span class="line">	Elf64_Word    p_flags;      <span class="comment">/* Access permission flags. Run time permissions (rwx)*/</span></span><br><span class="line">	Elf64_Off        p_offset;    <span class="comment">/* File offset of contents. (Offset from the beginning of the file to the first byte in the segment)*/</span></span><br><span class="line">	Elf64_Addr     p_vaddr;    <span class="comment">/* Virtual address in memory image. (The virtual address of the first byte in the segment)*/</span></span><br><span class="line">	Elf64_Addr     p_paddr;    <span class="comment">/* Physical address (not used). */</span></span><br><span class="line">	Elf64_Xword  p_filesz;     <span class="comment">/* Size of contents in file.Segment size in the object file (&gt;=p_memsz)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	Elf64_Xword  p_memsz;	<span class="comment">/* Size of contents in memory. */</span></span><br><span class="line">	Elf64_Xword  p_align;	<span class="comment">/* Alignment in memory and file.Usually 4KB or 2MB*/</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/k7w5fiYPAHRjOCE.png"
                      alt="image-20240618164607421"
                ></p>
<p><strong>Difference between filesz and memsz means the uninitialized data in .bss</strong></p>
<p>.init section contains a small function _init called by program’s initialization code</p>
<blockquote>
<p>startup code</p>
<p>_start: the entry point of the program. Defined in the crt1.o, Same for all C program, Calls system startup function</p>
<p>__libc_start_main: Defined in libc.so, Initializes the execution environment, Calls the main function, Handles return value, Returns control to OS (if necessary)</p>
</blockquote>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p><strong>Memory-resident</strong> operating system code</p>
<ul>
<li><p><strong>Invoked by call the execve function</strong></p>
</li>
<li><p>Copy the code and data in the executable object file from disk into memory</p>
</li>
<li><p>Jump to the entry point</p>
</li>
<li><p>Run the program</p>
</li>
</ul>
<h4 id="Dynamic-Link-动态链接"><a href="#Dynamic-Link-动态链接" class="headerlink" title="Dynamic Link 动态链接"></a>Dynamic Link 动态链接</h4><ul>
<li><p>Dynamic Linking</p>
</li>
<li><p>Position Independent Code (PIC)</p>
</li>
<li><p>Loading and Linking Shared Libraries from applications</p>
</li>
</ul>
<p>静态链接缺点：底层库修改需要所有应用重编译，应用体积过大，冗余代码</p>
<p><strong>Shared Libraries</strong> </p>
<p>.so(shared obj) on Linux, .dll(dynamic linking lib) on Windows</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc –shared –fPIC –o libvector.so addvec.c multvec.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–shared: creating a shared object</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">–fPIC:  creating the position independent code</span></span><br></pre></td></tr></table></figure></div>

<p>Partial Linking</p>
<p>在编译时，.so文件<strong>没有将.data，.text段等copy</strong>，而只是copy了一些relocation and symbol table info</p>
<p>code and data是在memory之中<code>execve() &amp; ld-linux.so</code>链接的</p>
<blockquote>
<p>After linking, the locations of the shared libraries are fixed and do not change during the execution time</p>
<p>How to find the ld-linux.so </p>
<ul>
<li>The <strong>pathname of the ld-linux.so is contained in the .interp segment</strong> of p2</li>
</ul>
</blockquote>
<p>上面那张图，memory-mapped region for shared libs</p>
<h4 id="运行时Linking"><a href="#运行时Linking" class="headerlink" title="运行时Linking"></a>运行时Linking</h4><ul>
<li>Done explicitly by user with dlopen() in Linux</li>
</ul>
<p><code>gcc –rdynamic –O2 –o p3 dll.c -ldl</code></p>
<p>API：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br><span class="line">		<span class="comment">// returns: ptr to handle if OK, NULL on error</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span> ;</span><br><span class="line">		<span class="comment">// returns: ptr to symbol if OK, NULL on error</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span> ;</span><br><span class="line">		<span class="comment">// returns: 0 if OK, -1 on error</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span> ;</span><br><span class="line">		<span class="comment">/* returns: errormsg if previous call to</span></span><br><span class="line"><span class="comment">			dlopen, dlysym, or dlclose failed,</span></span><br><span class="line"><span class="comment">			NULL if previous call was OK */</span></span><br></pre></td></tr></table></figure></div>

<p>运行时Linking示例程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> x[<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>&#125; ;</span><br><span class="line"> <span class="type">int</span> y[<span class="number">2</span>] = &#123; <span class="number">3</span>, <span class="number">4</span>&#125; ;</span><br><span class="line"> <span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">void</span> *handle;</span><br><span class="line"> 	<span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> ) ;</span><br><span class="line"> 	<span class="type">char</span> *error;</span><br><span class="line">	<span class="comment">/*dynamically load the shared library that contains addvec() */</span></span><br><span class="line"> 	handle = dlopen(“./libvector.so”, RTLD_LAZY) ;</span><br><span class="line"> 	<span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"> 		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “%s\n”, dlerror()) ;</span><br><span class="line"> 		<span class="built_in">exit</span>(<span class="number">1</span>) ;</span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/*get a pointer to the addvec() function we just loaded */</span></span><br><span class="line"> 	addvec = dlsym(handle, “addvec”) ;</span><br><span class="line"> 	<span class="keyword">if</span> ( (error = dlerror()) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> 		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “%s\n”, error) ;</span><br><span class="line"> 		<span class="built_in">exit</span>(<span class="number">1</span>) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"><span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line"> 	addvec(x, y, z, <span class="number">2</span>)</span><br><span class="line"> 	<span class="built_in">printf</span>(“z=[%d, %d]\n”, z[<span class="number">0</span>], z[<span class="number">1</span>]) ;</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* unload the shared library */</span></span><br><span class="line"> 	<span class="keyword">if</span> (dlclose(handle) &lt;<span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “%s\n”, dlerror()) ;</span><br><span class="line"> 		<span class="built_in">exit</span>(<span class="number">1</span>) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>用处：</p>
<ul>
<li>分发系统更新，更新dll重新运行时自动加载</li>
<li>高性能web server, 对不同的库动态加载卸载，使用缓存来保证函数级别的最小内存占用，<strong>也是支持热更新的来源</strong></li>
</ul>
<h4 id="PIC：位置无关代码"><a href="#PIC：位置无关代码" class="headerlink" title="PIC：位置无关代码"></a>PIC：位置无关代码</h4><p>naive: 划分一块区域专门放</p>
<p>actual: 让代码都是PC-relative，从而可以被任意地址加载</p>
<ul>
<li>文件内部函数，变量：简单，直接变成PC-relative</li>
<li>文件外部引用，全局变量：间接跳转，以一个<strong>Private的.data段开头的GOT</strong>(全局偏移量表)作为跳板</li>
</ul>
<p>调用外部全局变量的解决方案：</p>
<ol>
<li><p>保证.data段和.text段在加载的时候不分开，一起加载</p>
</li>
<li><p>利用1，.data段和.text段现在的距离和加载到的地方没有关系了，在.data段开头的GOT里面记录各个全局的data的offset，然后在.text段记录GOT的entry_index, 访问时 .text -&gt; .data -&gt; GOT[idx] -&gt; global data</p>
</li>
</ol>
<p>GOT 012预留给dynamic linker</p>
<p>调用外部函数的解决方案：PLT（Procedure Linkage Table）</p>
<ol>
<li><p>在.text段前面加一段plt段，留下外部函数的地址的标记，对地址暂时留空</p>
</li>
<li><p>把.text段内部的代码之中所有外部函数的地址该外plt段之中标记的地址（相对地址）</p>
</li>
<li><p>当运行时.text-&gt;plt-&gt; 如果没有，再加载实际地址到标记留空的地方，之后再次访问不需要实际地址，只需要把plt当跳板就行</p>
</li>
</ol>
<p>PLT：16-byte entry array</p>
<p>PLT[0] 为dynamic linker预留</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/18/DMFEe4dyZOcGLl8.png"
                      alt="image-20240618203706209"
                ></p>
<p>第一次调用addvec</p>
<p>jmpq <code>*GOT[4]</code>发现没有，回来(*GOT[4]存0x4005c6下一条指令的relative，jmp相当于没jmp)，pushq $0x1 把addvec的entry ID作为栈上的参数给dynamic linker, 然后jmpq 到PLT[0]，PLT[0]压栈<code>*GOT[1]</code>参数后，跳转到dynamic linker，dynamic linker根据<code>*GOT[1]</code>和<code>ID</code>找到对应函数，同时更新GOT[4]，填上地址</p>
<p>后面调用addvec都是直接jmpq到<code>*GOT[4]</code>,实际上是函数调用</p>
<h4 id="库打桩"><a href="#库打桩" class="headerlink" title="库打桩"></a>库打桩</h4><p>构造“二传手”函数, 截获转发一些已经写好的库函数，例如malloc，可以用于日志，统计等等</p>
<p>编译时打桩：核心在于定义一个自己的同名函数，在自己的函数去调用库函数，例如利用宏定义malloc为mymalloc，再在mymalloc里面去调用系统的malloc</p>
<p>运行时打桩：比较复杂，不太重要</p>
<h4 id="重定向深入"><a href="#重定向深入" class="headerlink" title="重定向深入"></a>重定向深入</h4><p><a class="link"   href="https://anatasluo.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%9B%B8%E5%AF%B9%E9%87%8D%E5%AE%9A%E5%90%91.html" >深入理解相对重定向 - Anatas Luo’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>总结： 1. 流水线的设计，使得IP寄存器总是指向下一条指令，计算offset时，需要考虑当前指令的长度 <strong>2. 相对偏移如果确定（通常是static data），则以section为基址进行重定向，可以减少符号表大小， Addend &#x3D; symbol_offset - relocation_len 3. 相对偏移如果不确定，则以symbol为基址进行重定向，Addend &#x3D; - relocation_len</strong></p>
<p>需要重定向的代码在汇编上以<code>0x0(%rip)</code>给出，<code>%rip</code>是PC，<code>0x0</code>则意味着待填充</p>
]]></content>
  </entry>
  <entry>
    <title>mit 6.s081踩过的坑(持续更新中)</title>
    <url>/2024/07/11/mit-6-s081%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD-/</url>
    <content><![CDATA[<p>mit 6.s081踩过的坑</p>
<p>ubuntu 22.04 不能向后兼容 20.04， 需参考这篇知乎帖子配置环境</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/537461426" >https://zhuanlan.zhihu.com/p/537461426 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>vscode alt+shift+f format会改变几个头文件的顺序</p>
<span id="more"></span>
<p>会使得编译不通过</p>
<p>（types.h需要第一个被引入）</p>
<p>解决方法：把sort include 改成false</p>
<p><code>clang-format -style=llvm -dump-config > .clang-format</code></p>
<p>在.clang-format文件中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/24/sWU7G4ie5y2EXFt.png"
                      alt="image-20231124141342067"
                ></p>
<p>记得在setting.json之中设置clang-format为默认格式化工具</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;[cpp]&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;xaver.clang-format&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>





<p>或者也可以这样，如果希望某个代码段不要参与格式化，可使用 <code>// clang-format off</code> 和 <code>// clang-format on</code> 注释对该代码段进行限定，像下面这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    // clang-format off</span><br><span class="line">    Eigen::MatrixXd ref_mat = Eigen::MatrixXd::Zero(6, 6);</span><br><span class="line">    ref_mat &lt;&lt;</span><br><span class="line">         1,        0,        0,        0,        0,        0,</span><br><span class="line">         1,      0.5,     0.25,    0.125,   0.0625,  0.03125,</span><br><span class="line">         1,        1,        1,        1,        1,        1,</span><br><span class="line">        -1,       -0,       -0,       -0,       -0,       -0,</span><br><span class="line">        -1,     -0.5,    -0.25,   -0.125,  -0.0625, -0.03125,</span><br><span class="line">        -1,       -1,       -1,       -1,       -1,       -1;</span><br><span class="line">    // clang-format on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p>gdb指导在lec2 的 slides</p>
<p>如果出现问题多半是最开始没配好环境</p>
<p>看看riscv-gnu-toolchain装了没，光一个qemu源码不行</p>
<p>如果git clone失败(没在wsl下面配置代理)</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/153124468" >https://zhuanlan.zhihu.com/p/153124468 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#wslconfig" >https://learn.microsoft.com/en-us/windows/wsl/wsl-config#wslconfig <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>但我暂时还是不行</p>
<p><del>gan，现在ping都ping不通了</del></p>
<p>用这个似乎可以</p>
<p><a class="link"   href="https://github.com/sakai135/wsl-vpnkit" >https://github.com/sakai135/wsl-vpnkit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>启动</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl.exe <span class="literal">-d</span> wsl<span class="literal">-vpnkit</span> <span class="literal">--cd</span> /app wsl<span class="literal">-vpnkit</span></span><br></pre></td></tr></table></figure></div>

<p>之后git clone能正常下载</p>
<p>配置gdb环境</p>
<p>知乎上那个高赞我试了没用，不知道其他人可不可以，gdb-multiarch那个</p>
<p>必看：</p>
<p><a class="link"   href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html" >https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  —— （1）</p>
<p><a class="link"   href="https://stackoverflow.com/questions/10534798/debugging-user-code-on-xv6-with-gdb" >https://stackoverflow.com/questions/10534798/debugging-user-code-on-xv6-with-gdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  ——（2）</p>
<p>需要注意，如果没下过</p>
<p><a class="link"   href="https://pdos.csail.mit.edu/6.S081/2020/tools.html" >https://pdos.csail.mit.edu/6.S081/2020/tools.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 里面的</p>
<p><strong>Other Linux distributions (i.e. compiling your own toolchain)</strong></p>
<p>里面的 <strong>16G</strong> 的riscv-gnu-toolchain的话，是没有riscv64-unknown-elf-gdb的</p>
<p>我暂时不知道这样是否一定不可以正常使用gdb，我自己没有找到不下载的使用方法</p>
<p>下载了之后</p>
<p>make qemu大概率会报一个错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/QrftY3wGjKbNVE1.png"
                      alt="image-20231118201909680"
                ></p>
<p>是开了-Werror -Wall导致的</p>
<p>这里面有解决方案</p>
<p><a class="link"   href="https://github.com/mit-pdos/xv6-riscv/issues/125" >https://github.com/mit-pdos/xv6-riscv/issues/125 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<blockquote>
<p>this can be solved by adding <code>__attribute__((noreturn))</code> just above line 56 in sh.c the infinite recursion is then resolved</p>
</blockquote>
<p>跟着（1）配置，改完.gdbinit之后有可能会这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/9PdZiQ1acK25z4l.png"
                      alt="image-20231118205434105"
                ></p>
<p>简单的重启电脑即可</p>
<p>成功后如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/9ZXkWmHNMLpAuf1.png"
                      alt="image-20231118213519863"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>mit-6-s081踩过的坑-持续更新中-</title>
    <url>/2024/07/11/mit-6-s081%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>py的小小魔法(2)</title>
    <url>/2024/07/11/py%E7%9A%84%E5%B0%8F%E5%B0%8F%E9%AD%94%E6%B3%95-2-/</url>
    <content><![CDATA[<p>主要参考编程随想的博客3-5</p>
<h4 id="作为OOP的py"><a href="#作为OOP的py" class="headerlink" title="作为OOP的py"></a>作为OOP的py</h4><p>py之中”一切皆对象”，没有基本类型int, string, etc</p>
<p>对比java，实现容器类的时候，由于容器类需要Object类型，与int,float等不兼容，制作了Integer，Float等包装类</p>
<span id="more"></span>
<p>一切皆对象带来了统一的api</p>
<p>所有的py对象可以通过type()函数获取类型, 这也是python的RTTI（运行时保留类型信息）</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> XXX</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(XXX)) <span class="comment"># py支持反射，运行时了解，检查，修改结构</span></span><br><span class="line"><span class="comment"># dir()得到该module里面包含了啥</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(obj, name)  <span class="comment">#判断obj对象是否具有名为name的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(obj, name, value)  <span class="comment">#设置obj对象的名为name的属性值为value</span></span><br><span class="line"><span class="built_in">getattr</span>(obj, name)  <span class="comment">#获取obj对象的名为name的属性值</span></span><br><span class="line"><span class="built_in">delattr</span>(obj, name)  <span class="comment">#删除obj对象的名为name的属性</span></span><br></pre></td></tr></table></figure></div>



<h4 id="作为FP的py"><a href="#作为FP的py" class="headerlink" title="作为FP的py"></a>作为FP的py</h4><p>map(function, iterable)</p>
<p>filter(function, iterable)</p>
<p>闭包：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 闭包:函数和环境的集合体，捕获了函数和函数所需要的变量于内存之中</span></span><br><span class="line"><span class="comment"># 没有捕获闭包退化为匿名函数/函数指针</span></span><br><span class="line"><span class="comment"># 允许环境切换的时候依然访问原来的变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clossure_diff</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x</span>):</span><br><span class="line">        dx = <span class="number">0.00001</span></span><br><span class="line">        <span class="keyword">return</span> (f(x + dx) - f(x)) / dx</span><br><span class="line">    <span class="keyword">return</span> calc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">return</span> clossure_diff(f)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_poly</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">3</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">    <span class="comment"># print(foo(a))</span></span><br><span class="line">    <span class="comment"># print(a)</span></span><br><span class="line">    <span class="built_in">print</span>(d(test_ploy)(<span class="number">1</span>))</span><br><span class="line">    f1 = d(f)</span><br><span class="line">    f2 = d(f1)</span><br></pre></td></tr></table></figure></div>





<h4 id="作为瑞士军刀的python"><a href="#作为瑞士军刀的python" class="headerlink" title="作为瑞士军刀的python"></a>作为瑞士军刀的python</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, [e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)])))</span><br><span class="line"><span class="comment"># 打印0,1,2,3,4,5,6,7,8,9</span></span><br></pre></td></tr></table></figure></div>



<p>sh 库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pip</span> install sh</span><br></pre></td></tr></table></figure></div>

<p>不支持windows命令行（）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sh</span><br><span class="line">sh.ls(<span class="string">&quot;-l&quot;</span>)</span><br><span class="line"><span class="comment"># 或者是</span></span><br><span class="line"><span class="keyword">from</span> sh <span class="keyword">import</span> ls</span><br><span class="line">ls(<span class="string">&quot;-l&quot;</span>)</span><br></pre></td></tr></table></figure></div>





<p>keyboard 库, 支持win,mac,linux</p>
<p><a class="link"   href="https://github.com/boppreh/keyboard" >https://github.com/boppreh/keyboard <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pip</span> install keyboard</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keyboard</span>():</span><br><span class="line">    <span class="keyword">import</span> keyboard</span><br><span class="line">    keyboard.add_hotkey(<span class="string">&quot;space&quot;</span>, <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;space pressed&quot;</span>))</span><br><span class="line">    keyboard.wait()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyboard2</span>():</span><br><span class="line">    <span class="keyword">import</span> keyboard</span><br><span class="line">    keyboard.wait(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keyboard3</span>():</span><br><span class="line">    <span class="keyword">import</span> keyboard</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        event = keyboard.read_event()</span><br><span class="line">        <span class="keyword">if</span> event.event_type == keyboard.KEY_DOWN:</span><br><span class="line">            <span class="built_in">print</span>(event.name + <span class="string">&quot; press down.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> event.name == <span class="string">&quot;q&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press any key to continue.&quot;</span>)</span><br><span class="line">keyboard3()</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>py的小小魔法-2-</title>
    <url>/2024/07/11/py%E7%9A%84%E5%B0%8F%E5%B0%8F%E9%AD%94%E6%B3%95-2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>splay tree</title>
    <url>/2024/07/11/splay-tree/</url>
    <content><![CDATA[<h3 id="splay-tree"><a href="#splay-tree" class="headerlink" title="splay tree"></a>splay tree</h3><ol>
<li>Counting Binary Tree</li>
</ol>
<p>ref: <a class="link"   href="https://zhuanlan.zhihu.com/p/31526354" >卡特兰数（Catalan number）（二） - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://cs.stackexchange.com/questions/368/counting-binary-trees" >https://cs.stackexchange.com/questions/368/counting-binary-trees <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>给定节点数n，二叉树的种类数？ 卡塔兰数C(n). $C(n) &#x3D; \frac{1}{n+1} * C_{2n}^{n} $</p>
<span id="more"></span>
<p>直观理解？换个角度，自底向上</p>
<p>总共n个节点每次链接两个形成一个新节点，有多少种连法</p>
<p>等效于对序列$A_1A_2A_3A_4…A_n$加括号，有几种不同的加法</p>
<p>等效于括号问题（定义卡特兰数的原始问题）：</p>
<p>一个合法的括号序列定义（非递归）为：</p>
<ul>
<li>闭合（左括号数&#x3D;右括号数）</li>
<li>从左到右，任意时刻左括号数&gt;&#x3D;右括号数</li>
</ul>
<p>递归为：</p>
<ul>
<li>（a）是括号序列</li>
<li>A，B是括号序列，（AB）也是括号序列</li>
</ul>
<p>由非递归定义可以得到一些等价问题：</p>
<ul>
<li><p>一个n*n方格，不能过对角线，从左下出发，只能向右或者上走，终点在右上角（把n格子的n+1条线看成n元素序列的n+1个可以插入括号的点，向右走看成是左括号，向上走看成右括号）</p>
</li>
<li><p>一个二进制序列，任意时刻累计0的数目小于等于1的数目，最后0数要等于1数</p>
</li>
<li><p>一个允许{push,pop}的队列，n次操作之后队列为空</p>
</li>
</ul>
<p>设这样的数目为C(n)</p>
<p>递推式子：$$C(n) &#x3D; C(0)C(n) + C(1)C(n-1)+…+C(n)C(0)$$ （直观理解: $C(0)C(n)$是左子树0个，右子树n个，以此类推）</p>
<ol start="2">
<li>splay tree</li>
</ol>
<p>ref: <a class="link"   href="https://zhuanlan.zhihu.com/p/348797577" >深入理解伸展树(splay tree) - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>， <a class="link"   href="https://www.cs.usfca.edu/~galles/visualization/SplayTree.html" >Splay Tree Visualzation (usfca.edu) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>试图对AVL树进行优化</p>
<p>由局部性原理，想到能否将最近访问的元素（容易再次被访问）旋转到根上去方便下次访问</p>
<p>朴素想法: 一直向上，和父节点旋转！zig-zag</p>
<p>问题：如果是“一”字形，在将最底层的节点旋转到顶部的同时，路径上的节点也被旋转下来了，树的整体形态没变，最坏的时候每一次调整都是O(n)</p>
<p>伸展树改进：如果是“之”字形，和朴素想法一样；如果是“一字形”，先旋转父节点和祖先节点（如果有，没有就算了），再将查询节点向上旋转</p>
<p>可以证明这样的优化会让最坏情况的平均时间复杂度降到log(n)</p>
<p>这是自底向上的方法，要求从根开始查询时维护O(n)的查询栈，还有不直观的自顶向下方法，优化了空间效率</p>
<p>伸展树的应用：</p>
<ul>
<li>优化对AVL树的连续查询</li>
<li>区间操作：由于伸展（zig-zag等）不影响树的性质（在这里重要的是中序遍历的序列不变（要是旋转改变了二叉查找树的结构那不就寄了）），所以当我们用一棵二叉查找树代表一个comparable的元素序列时，可以利用伸展变换执行一些操作：<ul>
<li>插入区间：在第p个元素和第p+1个元素之间插入区间：将p向上伸展到根，再将p+1向上伸展到根的右子树，插入区间的根就是p+1的左子树</li>
<li>删除区间：删除[m,n]区间只需要将第m-1个元素伸展到根，再将n+1个元素伸展到根的右子树，之后删掉它的左子树就行</li>
<li>翻转区间：反转区间[m,n]内的元素，注意到逆序的递归表述： $$R(AmB) &#x3D; R(B)mR(A)$$, 操作为：1.将元素m-1伸展到根2.将元素n+1伸展到根的右子树，此时[m,n]就是它的左子树 3.维护一个reverse标记，标记为1则交换左右子树，并将该标记下放给左右子树的根，将[m,n]的根的reverse标记置1</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>一次使用python脚本跑cpp测试的犯蠢记录</title>
    <url>/2024/07/11/%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E8%B7%91cpp%E6%B5%8B%E8%AF%95%E7%9A%84%E7%8A%AF%E8%A0%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>一次使用python脚本跑cpp测试的犯蠢记录</p>
<p>这件事的起因是这样的，笔者在写一个实现mini editor的cpp lab作业。这个lab要实现一个命令行交互的Editor(类似vim)，然后会读取一行或多行输入（读取多行的情况类似vim输入<code>i</code>然后切换到input mode，以一个<code>.</code>单行作为结束input的标志）</p>
<p>鉴于TA给了一个最基础的测试用例，笔者依然延续一贯的思路使用<code>subprocess</code>库的<code>Popen</code>API，让编译好的cpp程序读取python产生的字节流作为输入，输出重定向到某个log文件之中，以此来实现自动化测试。</p>
<p>最开始的代码大概这样</p>
<span id="more"></span>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess <span class="keyword">as</span> sh</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">test_input = <span class="string">&#x27;&#x27;&#x27;a</span></span><br><span class="line"><span class="string">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">using namespace std;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#includ</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">4,5d</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">1,3c</span></span><br><span class="line"><span class="string">1,5n</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;Hello my editor&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,4l</span></span><br><span class="line"><span class="string">1,4s</span></span><br><span class="line"><span class="string">1,4t</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">write</span></span><br><span class="line"><span class="string">1,999n</span></span><br><span class="line"><span class="string">9,1n</span></span><br><span class="line"><span class="string">4,2d</span></span><br><span class="line"><span class="string">2019</span></span><br><span class="line"><span class="string">w hello.cc</span></span><br><span class="line"><span class="string">Q</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># pretask</span></span><br><span class="line">    input_file = <span class="string">&quot;./test_input.txt&quot;</span></span><br><span class="line">    result_file = <span class="string">&quot;./result.txt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;./build&quot;</span>):</span><br><span class="line">        sh.run([<span class="string">&quot;rm&quot;</span>, <span class="string">&quot;-rf&quot;</span>, <span class="string">&quot;./build&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    sh.run([<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;-B&quot;</span>, <span class="string">&quot;./build&quot;</span>, <span class="string">&quot;-G&quot;</span>, <span class="string">&quot;Unix Makefiles&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    os.chdir(<span class="string">&quot;./build&quot;</span>)</span><br><span class="line">    sh.run([<span class="string">&quot;make&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(test_input)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># begin test</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(result_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fo, <span class="built_in">open</span>(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fi:</span><br><span class="line">        p = sh.Popen([<span class="string">&quot;lab2.exe&quot;</span>], stdin=sh.PIPE, stdout=fo, shell=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">            p.stdin.write(line)</span><br><span class="line">        p.stdin.close()</span><br><span class="line">    sh.run([<span class="string">&quot;make&quot;</span>, <span class="string">&quot;clean&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    os.chdir(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></div>



<p>结果报错</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">File <span class="string">&quot;D:\Desktop\2024sp\sep\lab2\test.py&quot;</span>, line 56, <span class="keyword">in</span> main</span><br><span class="line">    p.stdin.write(line)</span><br><span class="line">TypeError: a bytes-like object is required, not <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>这是因为PIPE读取的是字节流，给<code>Popen</code>加上<code> universal_newlines=True</code>将输入视为纯文本即可</p>
<p>这个错误并不大，但致命的下一个错误：</p>
<p>我在修改程序时，不小心调整了<code>p.stdin.close</code>的位置</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(result_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fo, <span class="built_in">open</span>(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fi:</span><br><span class="line">    p = sh.Popen([<span class="string">&quot;lab2.exe&quot;</span>], stdin=sh.PIPE, stdout=fo, shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">        p.stdin.write(line)</span><br><span class="line">p.stdin.close() <span class="comment"># 不小心把这里改了！！！</span></span><br></pre></td></tr></table></figure></div>

<p>当然，理论上这会抛出一个错误而终止，但问题就在这里出现……</p>
<p><strong>现象：电脑显著变卡，尝试打开输出文件无法打开，尝试删除输出文件失败<code>rm: cannot remove &#39;build/result.txt&#39;: Device or resource busy</code>，关闭IDE之后再删除，发现输出文件已经增长到几百mb甚至一个G</strong></p>
<p>显然是发生了什么不好的无限循环一直在输出，那么这个循环是怎么产生的呢？</p>
<blockquote>
<p>当python程序结束的时候，它会尝试回收所有从python程序产生的子进程，理论上不需要关心子线程的清理问题</p>
</blockquote>
<p>但这里我们使用了<code>shell=True</code>!!</p>
<p>这个参数本身是让我们可以方便地使用外部shell执行命令，但它带来的直接问题是，执行的的命令不再是由python管理了，变成了shell自己管理</p>
<p>而此时，python退出时回收了shell，但可能内部实现是简单粗暴的发了个信号直接kill了，导致shell进程开启的子进程lab2.exe没有正常退出，还在继续执行……</p>
<p>然后</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Editor::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string cmd;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cmd&gt; &quot;</span>;</span><br><span class="line">    cout.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;Q&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">dispatchCmd</span>(cmd);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *e) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;oor) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; oor.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> range_error &amp;re) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; re.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这一段核心代码的逻辑是，一直尝试读取输入流，如果输入流是什么无法解析的东西，那就抛出错误，<strong>并且自己接住了</strong>， <strong>并且只是简单的打印，而不退出</strong></p>
<p>而更恐怖的是我们使用了管道这一个实质上的syscall……</p>
<p>所以python主进程结束了之后<strong>，<code>Popen</code>打开的管道（系统临时文件）并没有被立刻直接回收</strong>……而它也<strong>没有接收到结束信号</strong></p>
<p>于是就发生了奇妙的化学反应：</p>
<p>python -&gt; shell -&gt; lab2.exe 的前两个进程被回收了，但是管道还在，于是<code>getline</code>总是读到空行和一堆不知道什么的东西，就总是抛出错误，就总是被接住，然后打印，输出到<code>result</code>文件之中……这样就出现了系统卡顿和一个G的result文件的奇观</p>
<p>这个bug的教训是什么呢？</p>
<ul>
<li>慎用Popen和shell&#x3D;True</li>
<li>如果一定要用，包裹上try except结构,并且使用<code>terminate</code>这个API以处理清理工作</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(result_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fo, <span class="built_in">open</span>(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fi:</span><br><span class="line">    p = sh.Popen([<span class="string">&quot;lab2.exe&quot;</span>], stdin=sh.PIPE, stdout=fo, shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">            p.stdin.write(line)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        p.stdin.close()</span><br><span class="line">        fo.close()</span><br><span class="line">        p.terminate()  <span class="comment"># 这是最重要的！！！</span></span><br></pre></td></tr></table></figure></div>



<p>还有一个有意思的事情：</p>
<p>当我发现输出1G的文件根本删不掉（rm 或者 直接右键删除 都会显示这个文件正在被忙碌占用，操作失败）的时候，我关闭了vscode，发现电脑不卡了（这个文件不再增长了）</p>
<p>这是为什么呢？实际上也是操作系统的知识，vscode本身作为父进程运行了包装terminal的进程，terminal运行python，python运行lab2.exe，而python不正常退出之后，lab2.exe的被转移给了python的父进程，也就是vsc管理的进程</p>
<p>所以退出vsc的时候，vsc向所有的子进程发信号终止，这个不再受python管理的lab2.exe也就被kill了。</p>
<p>再一次体会到了这样父进程提前退出的情况下转移子进程的所有权的设计之巧妙，如果出现一个“悬垂进程”，那可真是只能重启电脑了</p>
<hr>
<p>如果说上面的问题是OS三大模块之中的虚拟化和文件系统</p>
<p>下面出现的问题就是剩下的大模块并发</p>
<p>（小小的一个脚本居然能涉及到整个OS）</p>
<p>修改后的程序还有一个问题，就是输出的程序前后顺序依然很奇怪，经常会出现一个命令的输入输出顺序颠倒或者混杂的问题</p>
<p>一想，这不是显然的并行出错嘛</p>
<p>我输出的代码大概这样</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">    fo.write(line)</span><br><span class="line">    p.stdin.write(line)</span><br><span class="line">    p.stdin.flush()  <span class="comment"># 立刻将刷新输入缓冲区</span></span><br><span class="line">    fo.flush()  <span class="comment"># 立刻将输出刷新到文件</span></span><br></pre></td></tr></table></figure></div>

<p>咋一看没问题啊？先输入（并同步将输入输入到result上以保证最后的log文件有输入信息），再输出，每一行输入都尝试刷新缓冲区以保证lab2.exe能够正常读取到输入流的结束标志（而不是全部都塞进管道一直不结束最后无法解析命令）</p>
<p>它的问题是，python脚本执行和子进程lab2.exe执行实际上是并行的，<strong>python需要等待子进程完成执行，由于在输入流里面读不到东西回到阻塞状态（这也是这个lab在状态跳转了之后还有另外的从输入流读的行为决定的，如果这个lab没有多行输入这样的命令，而每次只读一行，执行过程之中不读的话，完全可以直接写，反正执行之中也不读）</strong>。而一个很难搞的点在于，lab2.exe实质上一直在运行，只不过内部状态不断跳转，而外部的python无法知道它的内部状态<strong>，无法使用os.wait()等同步原语</strong>（因为子进程根本没有结束！）</p>
<p>那又要如何保证顺序呢？笔者最后是采取了一个最蠢的方法，<strong>直接开睡</strong>！每一次输入、开始子进程之后，python主进程都睡眠一段时间等待子进程。而在写文件的函数上采用异步的方法来提供wait</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess <span class="keyword">as</span> sh</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">test_input = <span class="string">&#x27;&#x27;&#x27;a</span></span><br><span class="line"><span class="string">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">using namespace std;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#includ</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">4,5d</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">1,3c</span></span><br><span class="line"><span class="string">1,5n</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;Hello my editor&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">1,4l</span></span><br><span class="line"><span class="string">1,4s</span></span><br><span class="line"><span class="string">1,4t</span></span><br><span class="line"><span class="string">1,$n</span></span><br><span class="line"><span class="string">write</span></span><br><span class="line"><span class="string">1,999n</span></span><br><span class="line"><span class="string">9,1n</span></span><br><span class="line"><span class="string">4,2d</span></span><br><span class="line"><span class="string">2019</span></span><br><span class="line"><span class="string">w hello.cc</span></span><br><span class="line"><span class="string">Q</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">input2file</span>():</span><br><span class="line">    input_file = <span class="string">&quot;./test_input.txt&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(test_input)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    input_file = <span class="string">&quot;./test_input.txt&quot;</span></span><br><span class="line">    result_file = <span class="string">&quot;./result.txt&quot;</span></span><br><span class="line">    sh.run([<span class="string">&quot;cmake&quot;</span>, <span class="string">&quot;-B&quot;</span>, <span class="string">&quot;./build&quot;</span>, <span class="string">&quot;-G&quot;</span>, <span class="string">&quot;Unix Makefiles&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    os.chdir(<span class="string">&quot;./build&quot;</span>)</span><br><span class="line">    sh.run([<span class="string">&quot;make&quot;</span>], shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start input2file......&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> input2file()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start testing......&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(result_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fo, <span class="built_in">open</span>(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fi:</span><br><span class="line">        p = sh.Popen([<span class="string">&quot;lab2.exe&quot;</span>], stdin=sh.PIPE, stdout=fo, shell=<span class="literal">True</span>, universal_newlines=<span class="literal">True</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 脚本休眠，等待第一个 &gt; cmd 先输出</span></span><br><span class="line">        fo.flush()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fi:</span><br><span class="line">                fo.write(line)</span><br><span class="line">                fo.flush()</span><br><span class="line">                p.stdin.write(line)</span><br><span class="line">                p.stdin.flush()  <span class="comment"># 立刻将刷新输入缓冲区</span></span><br><span class="line">                time.sleep(<span class="number">0.05</span>) <span class="comment"># 脚本休眠等待程序处理</span></span><br><span class="line">                </span><br><span class="line">                fo.flush()  <span class="comment"># 立刻将输出刷新到文件</span></span><br><span class="line">            p.stdin.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">            p.stdin.close()</span><br><span class="line">            fo.close()</span><br><span class="line">            p.terminate()   </span><br><span class="line">            <span class="comment"># print(line)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sh.run([&quot;make&quot;, &quot;clean&quot;], shell=True)</span></span><br><span class="line">    os.chdir(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></div>

<p>最后解决了这个异步问题</p>
<p>整个bug流程涉及到了好多知识，也很有意思，并且bug非常具有破坏性（指1G文件，如果运维之中有这种bug估计不当处理要服务器爆炸），所以记录了整个流程</p>
]]></content>
  </entry>
  <entry>
    <title>使用pycron库编写hexo自动部署脚本</title>
    <url>/2024/07/11/%E4%BD%BF%E7%94%A8pycron%E5%BA%93%E7%BC%96%E5%86%99hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>使用pycron库编写hexo自动部署脚本</p>
<p>开始尝试使用bash写这个自动化脚本，但是bash对字符串的处理非常的disgusting（）</p>
<span id="more"></span>
<p>hexo的几个“特性”：</p>
<ul>
<li>hexo new [filename]，filename对特殊字符的处理不佳，比如’&amp;’, ‘.’，’+’等等，会被替换成’-‘; 例如， c++example&amp;test会变成c–example-test</li>
<li>hexo new [filename]之中， filename不能带.md，否则会出现filename-md.md</li>
<li>hexo 的几个指令都不算是“原子化”的，可能是异步的，然后和前面的几个“特性”结合起来出现了极其玄幻的效果，在之前编写脚本的尝试之中，出现了调用hexo new [filename]之后使用cp自动填充内容，结果因为名字替换的特性，导致一部分的内容被写到了c++example&amp;test.md, 一部分被写到了生成出来的c–example-test-md.md，多的时候甚至能生成好几个文件，然后全部部署，成功的让整个文件夹变成shit</li>
<li>说到为什么想写自动化脚本，是因为hexo生成新文件多少有些烦了。我喜欢直接抄起typroa就写，不喜欢每次先 hexo new 一个草稿（省得随便发布），再写好title, pinned，tag等，在写<code><!-- more ---></code><del>(我甚至记不住这个折叠的语法)</del>&#x2F;。于是乎，在hexo的_post外部有许多的.md文件，但是hexo却没有提供一个批量发布的功能</li>
</ul>
<p>所以思路大概是，</p>
<ol>
<li>把文件的名字先做一个替换，先把中英文的各种特殊符号替换成<code>-</code>（结尾替换成空），去除空格，做hexo的事，避免它自作主张的给我复制一次</li>
<li>copy 原来的.md文件的内容到发布的新文件，并且加上通用的title, pinned等头部设置，再设置<code><!-- more ---></code></li>
<li>使用类似crontab的功能达成开机脚本定时执行，部署自动化，只需要拖动.md文件到目标文件夹，在某个时间它会自己部署.md文件</li>
</ol>
<p>最开始的思路是</p>
<p>bash + wsl 的从crontab 达成自动化的效果</p>
<p>后面发现bash的字符串简直是shit, 转投python</p>
<p>开始想用python 的 subprocess库，但中间有一个很蛋疼的地方是，subprocess传递参数的时候，<code>""</code>怎么也保留不下来，然后<code>()</code>等bash保留符号在文件名之中就会产生bug……. 尝试了转义字符，f string等方法均失败。还踩了subprocess里面stdout相关的坑。</p>
<p>最后的解决方法是，朴素的 <code>os.system()</code>和<code>with open() as f:</code></p>
<p>…….</p>
<p>还有一些bug, 比如</p>
<ul>
<li>我的电脑上open默认以gbk编码，需要加一个<code>encoding='utf-8'</code></li>
<li>py字符串的replace()方法并不适用于中文字符，需要使用正则库re</li>
<li>开始想将折叠符号 <code><!-- more ---></code> 放在比如第50个字处，后来发现一个问题，当它插入在markdown块中间（比如代码块），会不起作用，最后就是简单的插入在第4个空行的地方（因为我很喜欢敲空行（））</li>
<li>……</li>
</ul>
<p>然后就是自动部署的阶段</p>
<p>开始的想法是调用crontab包</p>
<p>但我只有wsl下了这个包</p>
<p>尝试在外部用wsl.exe 调用wsl, 或者在内部 用 &#x2F;mnt&#x2F;path 访问外部文件</p>
<p>为了wsl内外代码的一致性还将路径统一为比如这种代码</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">script_path = os.path.realpath(__file__) </span><br></pre></td></tr></table></figure></div>



<p>然后发现wsl虽然能读写外部的文件，但是似乎并不能做比如调用外部的 git bash这样的事情（乐）</p>
<p>难道山穷水尽了吗（）</p>
<p>不！然后我找到了crontab的替代品，一个py库 python crontab</p>
<p>于是问着codeium写了一个bat脚本，然后看<em><a class="link"   href="https://cloud.tencent.com/developer/article/1889190" >https://cloud.tencent.com/developer/article/1889190 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em> 这个博客配置了开机自启动</p>
<p>碎碎念：本来以为最多一小时写完的脚本写了这么久……不过确实学到了些经验，原谅他了</p>
<p><strong>终于，我的hexo变成没有脑子的自动的东西了，好耶！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>南大PA历险记（持续更新中）</title>
    <url>/2024/07/11/%E5%8D%97%E5%A4%A7PA%E5%8E%86%E9%99%A9%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD-/</url>
    <content><![CDATA[<p>南大PA历险记</p>
<p>PA0：</p>
<p>23.9.3</p>
<p>配置环境 之前装完Ubuntu 觉得已经好了，结果第一个poweroff命令就发现不支持，查阅了不少资料，发现都是过时的脚本（根本跑不起来），结果最后看了wsl2的官方公告上成功通过wsl2配置了systemd!</p>
<span id="more"></span>
<p>好耶！<a class="link"   href="https://devblogs.microsoft.com/commandline/systemd-support-is-now-available-in-wsl/" >https://devblogs.microsoft.com/commandline/systemd-support-is-now-available-in-wsl/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>配置环境下：</p>
<p>之前甚至没加过用户，一直root权限开在那里</p>
<p>查阅资料，root(su -)和sudo还是有区别，于是开了一个账户</p>
<p>adduser [username]</p>
<p>然后 su username切换，直接exit会退出wsl&#x2F;登不出去</p>
<p>PA配置的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install libsdl2-dev        # a library used later</span><br><span class="line">apt-get install llvm llvm-dev      # llvm project, which contains libraries used later</span><br><span class="line">apt-get install llvm-11 llvm-11-dev # only for ubuntu20.04</span><br></pre></td></tr></table></figure></div>

<p>这三行会报依赖错误</p>
<p>解决方案：用aptitude 替代apt-get，然后当全肯定bot(雾)</p>
<p>编译不出来：缺啥装啥，<del>除了一个#include “llvm&#x2F;MC&#x2F;MCAsmInfo.h”错误需要如下方法：</del></p>
<p>#include “llvm&#x2F;MC&#x2F;MCAsmInfo.h” 这玩意巨难配</p>
<p>不知道为什么我最开始llvm下不下来，后来从aptitude那里发现好像有版本冲突，于是按照它的提示降了一些软件的版本，结果还是不行。中间不知道那里下了clang，然后clang能找到llvm找不到（实际上没下下来）要麻了。cd 到 &#x2F;usr&#x2F;include里面看， 发现没有llvm这个文件夹，遂下之。发现还是不行，再看，发现原来之前的llvm13没卸载，现在的llvm下载下来，变成了两个分立的文件夹 llvm-13和llvm-14，然后里面各有一个llvm（本来应该llvm在外面，即&#x2F;usr&#x2F;include，这下找不到了）</p>
<p>于是卸了llvm13， 14重下一遍，把src&#x2F;utils&#x2F;filelist.mk改回来，终于ok!</p>
<p>PA1:</p>
<p>tmux ctrl + b + %创建横向分屏， ctrl + b + &amp;关闭该分屏幕</p>
<p>sudo apt install tree 之后 tree就可以形成文件目录啦</p>
<p><code>tree -L 2 -P &quot;*.h|*.c&quot;</code>  限制深度为2，只筛选以.h .c结尾的文件</p>
<p><code>lscpu</code>   了解cpu信息 ， make jx（x为一个数字，如 j4），开j线程make</p>
<p><code>make -nB</code> 只输出命令而不执行，反推通配符等</p>
<p>gdb 内存检查：gcc&#x2F;g++ 编译时加上选项 -fsanitize&#x3D;address -g</p>
<p>如<code>gcc -fsanitize=address -g -c main.c -o main.o</code></p>
<p>之后建议使用 <code>./a.out 2&gt;(错误流重定向) error.txt</code>再看，否则命令行窗口会看不全</p>
<p>gdb补充命令</p>
<p>list：看当前附近的代码</p>
<p>args:</p>
<ul>
<li>show args : 查看当前程序启动时的参数列表</li>
<li>set args : 设置程序启动时的参数列表，run&#x2F;r 启动后才会生效</li>
</ul>
<p>where:显示当前执行的具体函数和代码行</p>
<p>f&#x2F;frame: 切换栈帧</p>
<ul>
<li>frame&#x2F;f [number]: 切换到第 [number] 个栈帧，如果不存在，则打印当前栈帧</li>
<li>up [number]: 选择当前栈帧编号 + [number]的栈帧</li>
<li>down [number]: 选择当前栈帧编号 - [number]的栈帧</li>
<li>info frame [addr]: 描述当前选择的栈帧, [addr]可选</li>
</ul>
<p>info args 参数列表</p>
<p>info locals局部变量</p>
<p>set var [variable]&#x3D;[value]: 给变量[variable]赋值</p>
<p>寄存器：</p>
<ul>
<li>info&#x2F;i registers&#x2F;r: 查看寄存器  i r</li>
<li>info all-registers: 显示所有寄存器</li>
<li>info r [register_name]: 查看指定的寄存器<ul>
<li>e.g.  i r rdi&#x2F;rsi</li>
</ul>
</li>
</ul>
<p>当然，也可以用 p $pc, p $sp, p $rax之类直接打印寄存器</p>
<p>disassemble [function_name]: 查看函数的汇编代码<br>disassemble &#x2F;mr [function_name]: 同时比较函数源代码和汇编代码</p>
<p>GDB 中支持搜索源码，且支持正则表达式搜索<br>search [regular_expression] 或字符串</p>
<p>make menuconfig图形化页面操作</p>
<p>使用gdb调试：cd 到nemu的build文件夹之中</p>
<p>注意使用gdb需要在menuconfig之中打开enable debug的选项</p>
<p>gdb tui:</p>
<p>输入tui enable或 ctrl-X A启动, tui disable关闭</p>
<p>当出现错误时，输入control + L 刷新屏幕</p>
<p>Ctrl-X 2：切换到汇编窗格</p>
<p>tui reg all:看寄存器</p>
<p>tui模式下上下一条命令 CTRL+ p &#x2F; n</p>
<p>执行python代码：</p>
<p>第一种 source script.py 执行外部代码</p>
<p>第二种 使用内嵌python模块</p>
<p>（gdb）python</p>
<p>&gt;…(code)</p>
<p>&gt; end (结束标识符)</p>
<p>输入record启用record模式的情况下才能使用 rs</p>
<p>反向调试： reverse-step i 反向i步 （rs i）</p>
<p>概率性错误，可以设两个断点，使用command语句</p>
<p>例如 exit断点1：</p>
<p>command 1</p>
<p>record</p>
<p>c</p>
<p>main函数结尾断点2</p>
<p>command 2</p>
<p>r</p>
<p>这样可以不断重复运行，直到exit错误出现，并启用record</p>
<p>配置图形化界面：<br>一个是要照着google配置相关的设置</p>
<p>另一个配完之后记得 在cmd 里面 wsl –shutdown; wsl这样<strong>重启一次</strong>。</p>
<hr>
<p>在新电脑之后</p>
<p>一个有趣的地方，abstract-machine的配置之中 $AM_HOME 之中ics2022变成了ics2023,应该是源代码的bug,需要手动改.bashrc</p>
<hr>
<p>在tmux上启动鼠标滚轮</p>
<p>ctrl+b, :进入命令模式，输入set -g mouse on</p>
<p>自动配置鼠标滚轮</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.tmux.conf</span><br></pre></td></tr></table></figure></div>

<p>然后加上set -g mouse on</p>
<hr>
<p>nemu state( nemu&#x2F;include&#x2F;utils.h)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/ZiT32enIf59EKRy.png"
                      alt="image-20231104002218432"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/K2vkF9WuwRQiS7g.png"
                      alt="image-20231104002556122"
                ></p>
<p>至于为什么sdb_mainloop()没有显式include“utils.h”，但却可以使用nemu_state</p>
<p>可能是由于nemu&#x2F;src&#x2F;filelist.mk</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/11/18/GUuys8g6ZxiE5tB.png"
                      alt="image-20231104004214734"
                ></p>
<p>这里，DIRS + 了utils，相当于include了utils</p>
<p>至此完成了优雅的退出</p>
<hr>
<p>jyy 习题课lec4</p>
<p>xargs [command]</p>
<p>… | xargs [command]  把…的结果传递为[command]的命令行参数</p>
<p>vi $(fzf) ， 打开特定文件 $(fzf)支持搜索，滑动，类似linux文件管理器</p>
<p>vi **&#x2F;gen-expr.c</p>
<p>nemu的运行：.&#x2F;build&#x2F;isa-nemu-interpreter</p>
<p>甚至可以 echo ‘q’ | .&#x2F;build&#x2F;isa-nemu-interpreter</p>
<p>assert 防御性编程</p>
<p>测试：小测试框架</p>
<p>vscode + wsl vsc wsl插件，然后直接wsl之中输入 code .</p>
<p>clangd插件 </p>
<hr>
<p>wsl之中复制内容</p>
<p>比如想要复制make -nB 到剪切板</p>
<p>[command] | clip.exe </p>
<hr>
<p>vscode 配置</p>
<p><del>1.c_cpp_properties之中的includePath相当于-I， defines相当于-D，在 make -nB取出所有-I和-D的项放到c_cpp_properties之中？</del></p>
<p><del>grep -Eo （正则表达式） | sort  | uniq</del></p>
<p>感觉不如下一个bear，这样抓是有漏的，最后正常了不知道是这个还是下一个的贡献</p>
<p>2.使用bear（stfw）</p>
<p><code>bear -- make</code>（在wsl bash里面运行）</p>
<p>之后会发现vscode多了一个commands.json文件，再在setting.json之中加设置</p>
<p>来避免微软自带的c++和clangd的提示冲突，同时提醒clangd读取工作区的command.json</p>
<hr>
<p>pa1 基础设施</p>
<p>strtok(char* str, const char* delim)</p>
<p>delim: 分割符集字符串</p>
<p>string token，按照delim分割字符串str，返回第一个子字符串（第一次调用传入str，后续传入NULL）</p>
<p>附注：</p>
<blockquote>
<p><code>strtok</code> 函数首先将字符串分割成第一个子字符串 <code>&quot;Hello&quot;</code>，然后通过循环继续分割剩余的部分，直到返回 <code>NULL</code>。</p>
<p>需要注意的是，<code>strtok</code> 函数在每次调用时会修改传入的字符串，将分隔符替换为 <code>&#39;\0&#39;</code>（空字符）作为子字符串的结尾。因此，如果你需要保留原始字符串，可以在分割前创建一个副本进行操作。</p>
<p>此外，需要小心的是，在多线程环境中使用 <code>strtok</code> 函数是不安全的，因为它使用了静态变量来保存分割的位置。如果你需要在多线程环境中进行字符串分割，可以考虑使用线程安全的替代函数，如 <code>strtok_r</code>（GNU 扩展）或 <code>strtok_s</code>（C11 标准）。</p>
</blockquote>
<p>readline:</p>
<p><code>readline</code> 函数会在标准输入中读取用户输入的一行文本，并将其作为字符串返回</p>
<p>sscanf:</p>
<p>从字符串之中读取格式化数据</p>
<p>例子： </p>
<p>char[20] name, int age;</p>
<p>char* parse_str &#x3D; “Ayanami 18”;</p>
<p>sscanf(parse_str, “%s %d”, name, &amp;age);</p>
<p>&#x2F;&#x2F;此时name和age都被改变了</p>
<hr>
<p>单步执行：水，改一下就好了</p>
<p>打印寄存器：水</p>
<blockquote>
<p>vscode alt+shift+f自动格式化</p>
</blockquote>
<blockquote>
<p>如果希望某个代码段不要参与格式化，可使用 <code>// clang-format off</code> 和 <code>// clang-format on</code> 注释对该代码段进行限定</p>
</blockquote>
<p>扫描内存，需要extern vaddr_read函数</p>
<p>表达式求值，正则</p>
<p>p1:拆token，算术表达式</p>
<p>()+-*&#x2F;space  十进制数</p>
<p>operator: +-&#x2F;*()</p>
<p>operand: 十进制数</p>
<p>jyy这里讲得很棒，建议看讲义</p>
<p>查看文件(夹)大小</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh [path]</span><br></pre></td></tr></table></figure></div>


]]></content>
  </entry>
  <entry>
    <title>南大PA历险记-持续更新中-</title>
    <url>/2024/07/11/%E5%8D%97%E5%A4%A7PA%E5%8E%86%E9%99%A9%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构期末复习</title>
    <url>/2024/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>数据结构期末复习</p>
<p>叠甲</p>
<p>ATTENTION：</p>
<ol>
<li>为了简化代码我都没有写模板</li>
<li>有些是伪代码，看函数看明白意思就成</li>
<li>未必和书上的实现一样（大部分该过一些逻辑和函数名称）</li>
<li>尽量不写错，错了是我菜，轻喷</li>
<li>一般不引入自定义数据结构，除了LinkedList表示单链表，其他的stack,deque之类都是std::stack， std::deque</li>
</ol>
<span id="more"></span>
<hr>
<h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h5><hr>
<h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><blockquote>
<p>例题：入栈序列1，2，…, n,第二个出栈的是3，第三个可能是？</p>
<p>解析：理解“入栈序列”，意思是入栈的是这样的顺序，但中间可以有任意出栈</p>
<p>如：入1，出1，入2，入3，出3,…</p>
<p>第一种可能：第一个出栈的是1&#x2F;2，第三个可以是1，2，4~n的任何值，共 n-4+1+2 &#x3D; n-1种</p>
<p>第二种可能：第一个出栈的是4，这样连续出两个，第二个出栈的就是3，第三个可以是 2，5~n</p>
<p>综上，取并集，n-1种</p>
</blockquote>
<p>应用：解递归</p>
<p><strong>递归本质上就是栈</strong>，所以一定能把递归写成栈的形式</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(n<span class="number">-1</span>) + <span class="built_in">foo</span>(n<span class="number">-2</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> || x == <span class="number">2</span>) &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(x - <span class="number">1</span>);</span><br><span class="line">        s.<span class="built_in">push</span>(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>中缀转后缀</p>
<p>符号栈+操作数栈</p>
<p>读到优先级高（先算）的符号，继续</p>
<p>读到优先级低的符号（即前面的符号优先级更高），前面的符号出栈</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">stack&lt;string&gt; symbol;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">midfix_to_subfix</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxPriority = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxPriority_idx = <span class="number">-1</span>;</span><br><span class="line">    string output;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input.<span class="built_in">length</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isOperand</span>(s[i]))&#123;</span><br><span class="line">            output += s[i];</span><br><span class="line">            output += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        symbol.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getPrority</span>(s[i]) &lt;= maxPriority)&#123;</span><br><span class="line">            <span class="comment">// 将优先级最高的操作符输出</span></span><br><span class="line">            output += s[maxPriority_idx];</span><br><span class="line">            output += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="type">int</span> maxPriority = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> maxPriority_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getPrority</span>(s[j]) &gt; maxPriority)&#123;</span><br><span class="line">                    maxPrority = <span class="built_in">getPrority</span>(s[j]);</span><br><span class="line">                    maxPrority_idx = j; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新max</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getPrority</span>(s[i]) &gt; maxPriority)&#123;</span><br><span class="line">            maxPrority = <span class="built_in">getPrority</span>(s[i]);</span><br><span class="line">        	maxPrority_idx = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>空表front &#x3D;&#x3D; -1 &amp;&amp; rear &#x3D;&#x3D; -1</p>
<p>插入 data[++rear] &#x3D; v</p>
<p>删除 ++front</p>
<p>循环队列</p>
<p>空表 front &#x3D;&#x3D; rear</p>
<p>插入 data[rear &#x3D; (rear+1)%M] &#x3D; v</p>
<p>删除 front &#x3D; (front+1) % M</p>
<p>链表队列：额外保存尾指针</p>
<p>hint: 似乎<strong>尾指针</strong>rear一般指最后一个合法元素，指队列&#x2F;表外的null之类的是<strong>尾后指针</strong></p>
<hr>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><blockquote>
<p>树即递归    ——沃兹基硕德</p>
</blockquote>
<p>概念：</p>
<p>森林：若干棵不相交树的集合</p>
<p>根：没有直接前驱</p>
<p>叶：没有直接后驱</p>
<p><strong>内部结点：除了根和叶</strong></p>
<p>子结点：直接后继</p>
<p>父结点：直接前驱</p>
<p>祖先结点：父节点一路向上</p>
<p>子孙结点：所有子节点一路向下</p>
<p><strong>度：和图的度定义不同，结点的度 def Node’s degree &#x3D;&#x3D; number of children</strong></p>
<p><strong>树的度 def Tree’s degree &#x3D;&#x3D; max {all Node’s degree}</strong></p>
<p>高度&#x2F;深度，算上根，只有一个根节点高度1</p>
<p>表示法：孩子链（链表的数组），孩子兄弟链表，左孩子右兄弟</p>
<ul>
<li>左孩子右兄弟: 左子树是孩子结点，右子树画兄弟结点</li>
</ul>
<p>二叉树：每个非叶结点都只有两个子结点，且是<strong>有序树</strong>（即使只有一颗子树也必须区分左子树还是右子树）</p>
<p>满二叉树：每一层的结点数量都达到最大值</p>
<p>完全二叉树：满二叉树最底层从右到左删去若干个结点</p>
<p>二叉树性质：</p>
<ul>
<li><p>第i层，最多2^i-1^个结点（根节点层数1）</p>
</li>
<li><p>高度k的二叉树最多2^k^-1个结点</p>
</li>
<li><p>n结点完全二叉树高度为[log<del>2</del>n]+1</p>
</li>
<li><p><strong>非空二叉树n<del>0</del>叶结点，n<del>2</del>度为2结点，有n<del>0</del>&#x3D;n<del>2</del>+1</strong>(推导：用边数，3n<del>2</del>+2（N-n<del>2</del>-n<del>0</del>)+ n<del>0</del>&#x3D;2(N-1) +1(根) ，化简即可）</p>
</li>
</ul>
<p>二叉树实现：顺序表、链表</p>
<p>顺序实现：根节点下标1，下标k的结点左孩子2k,右孩子2k+1，父节点[k&#x2F;2]</p>
<p><strong>非完全二叉树的顺序实现：在空的地方补上虚结点，用特殊值标志</strong></p>
<p>链表实现：左子树、右子树 (可选：父结点)（有父节点是三叉链表（广义标准存储），否则二叉链表（标准存储））</p>
<p>遍历：层序遍历，前序遍历（根左右），中序遍历（左根右），后序遍历（左右根）</p>
<p><strong>唯一确定一棵二叉树：前序+中序✔，后序+中序✔，前序+后序❌（AB BA，无法确定B是左子树还是右子树）</strong></p>
<p>例题：前序 ALBECDWX 中序BLEACWXD，求树</p>
<p>解析: 前是根左右，中是左右根，先找对应</p>
<p>中序中找根A， 则左边BLE是左子树，右边CWXD是右子树</p>
<p>L是左子树根，在中序之中找L，B是L的左子树，E是L的右子树</p>
<p>CWDX回前序找，C是右子树根，那么DWX都是C右子树，D是右子树根，WX都是D左子树，W是根，X是W右子树</p>
<p>总结：两边对应，从根突破，先大后小，分块解决</p>
<p>中前后：DFS</p>
<p>层序：BFS</p>
<p>前序递归：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(binaryTree* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// dosomething(t—&gt;root);</span></span><br><span class="line">    <span class="built_in">prefix</span>(t-&gt;left);</span><br><span class="line">    <span class="built_in">prefix</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前序非递归：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(binaryTree* t)</span></span>&#123;</span><br><span class="line">    deque&lt;TreeNode*&gt; d; <span class="comment">// 实际上不需要deque，只需要支持头插和头出就行, 完全可以换成自定义链表</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(t-&gt;root);</span><br><span class="line">    <span class="keyword">if</span>(!d.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        TreeNode* t = d.<span class="built_in">front</span>();</span><br><span class="line">   		<span class="comment">// dosomething(t)</span></span><br><span class="line">        d.<span class="built_in">pop_front</span>();</span><br><span class="line">        d.<span class="built_in">push_front</span>(t-&gt;right);</span><br><span class="line">        d.<span class="built_in">push_front</span>(t-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>中序非递归：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">midOrder</span><span class="params">(binaryTree* t)</span> </span>&#123;</span><br><span class="line">    deque&lt;TreeNode*&gt; d; <span class="comment">// 实际上不需要deque，只需要支持头插和头出就行, 完全可以换成自定义链表</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(t-&gt;root);</span><br><span class="line">    <span class="comment">// 因为此时需要让root在中间访问，所以需要记录root是第一次还是第二次访问，否则就死循环了</span></span><br><span class="line">    <span class="comment">//（pop 了 root 又加入root）</span></span><br><span class="line">    <span class="keyword">if</span>(!d.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        TreeNode* t = d.<span class="built_in">front</span>();</span><br><span class="line">   		<span class="comment">// dosomething(t)</span></span><br><span class="line">        t-&gt;<span class="built_in">addCount</span>(); <span class="comment">// 增加计数</span></span><br><span class="line">        </span><br><span class="line">        d.<span class="built_in">pop_front</span>();</span><br><span class="line">        d.<span class="built_in">push_front</span>(t-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;<span class="built_in">getCount</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 已经遍历过，只不过还没访问</span></span><br><span class="line">            d.<span class="built_in">push_front</span>(t);</span><br><span class="line">            <span class="comment">// 访问了之后由于count增加，不会再次访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(t-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>层序代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(binaryTree* t)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(t-&gt;root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* x = s.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">//dosomething(x)</span></span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;left)</span><br><span class="line">        	s.<span class="built_in">push</span>(x-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;right)</span><br><span class="line">        	s.<span class="built_in">push</span>(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>其他遍历同理</p>
<p>查找：类似遍历</p>
<p>插入：类似查找</p>
<p>删除：对于二叉查找树，删非叶结点取左子树最右边的或者右子树最左边的替换</p>
<p>统计结点数量</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(binaryTree* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">count</span>(t-&gt;left) + <span class="built_in">count</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>树高度</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(binaryTree* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left), <span class="built_in">height</span>(t-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>判断T2是不是T1子树：先T1查找T2的root, 找到为t<br>法一：非递归：遍历T2 元素为ele, search(t, ele)<br>法二：递归：T1 &#x3D;&#x3D; T2  equals to T1-&gt;root &#x3D;&#x3D; T2-&gt;root &amp;&amp; T1-&gt;left &#x3D;&#x3D; T2-&gt;left &amp;&amp; T1-&gt;right &#x3D;&#x3D; t2-&gt;right， 这样递归判断t和t2是否相等即可 </p>
<p>两结点AB最近公共祖先：</p>
<p>算法1：<br>git merge就是用了这个算法（的多路版）</p>
<p>首先假设二叉树是记录了parent的，如果没有记录遍历一遍补上parent信息<br>然后从A结点开始，反向（不断往parent找）做一个BFS（广度优先遍历,在有多个parent的情况下需要, 此处退化成一直沿着唯一的parent向上即可），记录祖辈节点的离A距离dis1</p>
<p>B也做一次，得到dis2</p>
<p>然后找出 dis1和dis2均存在 &amp;&amp; dis1+dis2最小 的结点即为所求，复杂度是O(N)，N为节点数<br>（这个记录信息可以这样做，不一定要树结点有额外元素，可以新定义一个array&lt;pair&lt;TreeNode*, T infomation&gt; 然后填array ）</p>
<p>算法2：<br>另一种效率慢一点但实现简单的方法：A的祖辈成为一个栈，在栈顶元素search(B), 如果找不到，出栈一个元素，继续</p>
<p>计算表达式：</p>
<p>书上讲得乱七八糟的（暴论）：</p>
<p>表达式记作&lt;expr&gt;</p>
<blockquote>
<p>&lt;expr&gt; ::&#x3D; operand </p>
<p>​	| (&lt;expr&gt;)</p>
<p>​	| &lt;expr&gt; op &lt;expr&gt;<br>​	| …</p>
</blockquote>
<p>也就是说， 表达式 是：操作数 或 括号套着的表达式 或 两个表达式中间一个运算符<br>（当然你可以继续拓展定义以支持单目和三目运算符之类）</p>
<p>我们先把操作数和不同操作符分开，变成不同的Token<br>输入的表达式做一个处理，变成Token流（Token数组）<br>比如 （3+5）* 8<br>变成 TK_NUM (3), TK_ADD (+), TK_NUM(5), TK_MUL(*), TK_NUM(8)</p>
<p>那么计算表达式的流程是：</p>
<ol>
<li>判断两边是不是有括号，如果有，去掉</li>
<li>找出主运算符：运算优先级最低的一个（最后算的那个）</li>
<li>把主运算符左边看成一个新表达式，右边看成一个新表达式，递归计算</li>
<li>那么什么时候递归停止呢？当表达式没有运算符的时候，如果此时有超过一个运算数，就是错误；如果只有一个运算数，那么值就是这个值</li>
</ol>
<p>建立表达式树就是一样的，<br>让主运算符为根，两边的表达式作为子树递归就行</p>
<p>具体代码可以参考我的blog<br><a href="https://ayanami1314.github.io/2023/11/15/2023-11-6-11-13%E5%AD%A6%E4%B9%A0%E5%91%A8%E8%AE%B0/">https://ayanami1314.github.io/2023/11/15/2023-11-6-11-13%E5%AD%A6%E4%B9%A0%E5%91%A8%E8%AE%B0/</a><br>的part 2部分</p>
<p>哈夫曼树（最优二叉树）：</p>
<p>比较复杂，考吗？可以参考我之前的blog：<a href="https://ayanami1314.github.io/2023/10/16/%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/%E7%9A%84%E5%89%8D%E5%8D%8A%E9%83%A8%E5%88%86">https://ayanami1314.github.io/2023/10/16/%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/的前半部分</a></p>
<p>是Huffman算法（一种压缩算法）使用的数据结构</p>
<p>avl和红黑, b树的理解</p>
<p>参见我的blog: <a href="https://ayanami1314.github.io/2023/10/16/%E6%A0%91/">https://ayanami1314.github.io/2023/10/16/%E6%A0%91/</a></p>
<p>avl、红黑，b和b+树的应试：</p>
<p>平衡度：左子树高-右子树高</p>
<p>AVL（二叉平衡树）：平衡度 0 1 -1</p>
<p>四种情况：</p>
<p>LL 左子树高，插入左左： 右单旋转</p>
<p>LR 左子树高，插入左右： 左右双旋转</p>
<p>RR 右子树高，插入右右： 右左双旋转</p>
<p>RL 右子树高，插入左左： 左单旋转</p>
<p>画图！画图！画图就懂了</p>
<p>b树&#x2F;b+树：</p>
<p>看书吧，书这里讲得还蛮清楚的</p>
<hr>
<p>哈希：</p>
<p>线性探测，平方探测，再散列法（不同的哈希方法H1(x)， (H1（x）+H2(x)) % M, (H1（x）+ 2H2(x)) % M, …），开散列表（拉链法）</p>
<p>闭散列表一般迟删除（lazy delete）</p>
<p>二次探测：有助于消除初始聚集</p>
<p><del>碎碎念：我从来没用过闭散列，都是直接开散列的（</del></p>
<hr>
<p>静态查找表：</p>
<p>分块查找（索引顺序查找）：把整个有序表分成几块，块内无所谓，块间需要有序</p>
<p>静态动态区分：是否有插入删除（改变结构）</p>
<p>内部外部区分：纯内存还是有内外存交互</p>
<hr>
<p>二叉堆：</p>
<p>以小根堆为例：</p>
<p>插入：在完全二叉树的最后加入一个元素，然后向上过滤，如果比父节点小就交换</p>
<p>删除：删除根结点，将完全二叉树的最后一个元素放到堆顶处，然后向下过滤</p>
<p>构造：逐个插入O(Nlog(N)),直接构造O（N）</p>
<p>逐个插入很好理解，直接构造的想法是：</p>
<p>逐个插入每插入一次都要维护堆的有序性，这部分工作是不必要的，只需要插入N个之后有序就行了</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(<span class="type">int</span> &amp;arr, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=size/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">percolateDown</span>(i); <span class="comment">// 向下过滤</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即：堆是完全二叉树，叶子不需要排序，所以从size&#x2F;2开始</p>
<p>当下一层全部有序的时候（左子树和右子树有序），对根排序就是一次向下过滤</p>
<p>为什么这个是O(N)</p>
<p>size&#x2F;4 到 size&#x2F;2: 最坏向下一层</p>
<p>size&#x2F;8 到 size&#x2F;4: 最坏向下2层</p>
<p>……</p>
<p>总共是sum(N*i&#x2F;2^i^, 0, log<del>2</del>(N))</p>
<p>要证 sum(N*i&#x2F;2^i^, 0, log<del>2</del>(N)) &#x3D; O(N) 即 sum(N*i&#x2F;2^i^, 0, log<del>2</del>(N)) &lt; C * N</p>
<p>令N&#x3D;2^p^代入化简，得即证 sum(i&#x2F;2^i^, 0, p) &lt; C 即可</p>
<p>i&#x2F;2^i^ 由比值审敛法，容易判定收敛，故上式成立，buildHeap是O(N)的</p>
<p>可能会考两种方法（逐个和线性复杂度）的画图</p>
<hr>
<p>排序和选择：</p>
<p>快排，堆排，希尔，计数，基数，冒泡，插入，选择，归并</p>
<p>这章没啥好讲的</p>
<hr>
<p>图论算法：</p>
<p>拓扑排序topSort：</p>
<ol>
<li>计算每个结点的入度indegree，将（所有）入度为0的点入队</li>
<li>找一个入度为0的点，出队，更新其他结点的入度（每条从此节点出发，到其他结点的边减少一个入度）</li>
<li>重复2，直至队空</li>
</ol>
<p>O(V+E)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> adjListGraph&lt;V, E&gt;::<span class="built_in">topSort</span>() &#123;</span><br><span class="line">    <span class="comment">// 伪代码</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indegree;</span><br><span class="line">    <span class="comment">// 计算入度</span></span><br><span class="line">    indegree.<span class="built_in">assign</span>(numOfVex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(E&amp; edge : <span class="keyword">this</span>-&gt;Edges)&#123;</span><br><span class="line">        indegree[edge-&gt;end]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: indegree)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> nextVer = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// dosomething(nextVer);</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 更新入度</span></span><br><span class="line">        <span class="keyword">for</span>(E* p=(verList+nextVar)-&gt;<span class="built_in">getEdgeList</span>();p!=<span class="literal">nullptr</span>;p=p-&gt;next)&#123;</span><br><span class="line">            indegree[p-&gt;end]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!q.<span class="built_in">empty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<p>dfs, bfs：</p>
<p>dfs: 如果相邻的结点还有没走的，走过去，如果死路就回溯（递归）</p>
<p>bfs: 队列，不断入队相邻结点，出队当前结点</p>
<p>Euler回路（欧拉回路）：</p>
<p>def： 起点和终点是同一点，且恰经过每一条边一次</p>
<p>存在性判断： 如果每个点的度都是偶数，则存在；否则不存在</p>
<p>寻找算法思路： </p>
<p>算法1：dfs暴搜</p>
<p>当回到原点 &amp;&amp; 还有边没走过 时回溯</p>
<p>算法2（Fleury算法）：改进, 路径为ve<del>1</del>v<del>1</del>e<del>2</del>…e<del>n</del>v， 在走过e<del>1</del>v<del>1</del>e<del>2</del>…e<del>k</del>v<del>k</del>时，找下一条边e<del>k+1</del>，除非没有其他边，否则不找割边（“桥”）</p>
<p>每走过一条边之后，“删去”（可以直接删掉（最开始留下边的拷贝）或者标记已经走过）</p>
<p>怎么判断桥？边u-v割断之后，u-v不连通的就是桥</p>
<p>怎么判断u-v连通性？DFS&#x2F;BFS</p>
<p>O（（V+E）^2^）</p>
<p>算法3：书本算法</p>
<ol>
<li>无回溯dfs，随便地找到一条回路</li>
<li>遍历该回路上的每个点，如果这个点还有没被走过的边，则以该边作为起点再找一个欧拉回路</li>
<li>将新的欧拉回路拼接到原来的欧拉回路上（原：A——B——…——A， 新： A——B——C——D——B——…——A）</li>
<li>重复23</li>
</ol>
<p>代码实现又臭又长，估计不会考代码（雾）</p>
<hr>
<p>刷试卷：</p>
<p>2020-2021</p>
<p>注意点：</p>
<p>哈夫曼树的在书上的定义（<strong>左子树编码0，右子树编码1，取最小的元素放左子树，次小的放右子树</strong>）</p>
<p>哈夫曼树在内存的存储， 2*size的内存表现表，会画</p>
<p>2018-2019</p>
<p>注意点：</p>
<p>哈希的探测似乎不算第一次，只有哈希的位置已经被占据了继续往下找才叫“探测”</p>
<p>哈希取模：小于数组长度的最大素数</p>
<p>看复习资料，重点算法和注意点</p>
<ol>
<li><p>假设单链表的实现中不维护当前元素数量（即没有current_length），设计尽可能高效的算法分别获取中间元素（或中间靠左元素）、第k个元素和倒数第k个元素。使用两个指针。</p>
<p>快慢指针法：fast_ptr走2， slow_ptr走1。 快指针走到链表尾部时，慢指针走到中间元素；倒数第k的的求法是先让一个指针走k，然后一个指针走到末尾时另一个就是倒数k</p>
</li>
<li><p>逆转单链表：某道例题。不断交换相邻的两个指针p,q</p>
</li>
<li><p>一般循环链表不设置头节点，单链表默认不带尾指针，一般带头节点</p>
</li>
<li><p>全排列的非递归算法：</p>
<ul>
<li>首先，所有元素按字典升序入栈</li>
<li>然后，从右到左找到第一个升序的相邻元素对（i,i+1），即v[i] &lt; v[i+1]，这样，v[i+1]到v[length-1]是降序的</li>
<li>在i+1到length-1这个子数组中从右向左找到第一个大于v[i]的元素，记为v[j]（由于已经是降序，v[j]此时肯定是最小的），swap(v[i], v[j]) , then reverse v[j] to v[length-1] ，（因为v[j]&gt;v[i]&gt;v[j+1]&gt;… 所以换完还是逆序的，反转之后变成顺序）就得到了下一个序列</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_permutations</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    std::stack&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(nums);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; v = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : v) &#123;</span><br><span class="line">            std::cout &lt;&lt; num &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] &lt; v[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>() + i + <span class="number">1</span>, v.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v[j] &gt; v[i]) &#123;</span><br><span class="line">                        std::<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">                        s.<span class="built_in">push</span>(v);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>算法的基本思想是，一个n个元素的排列可以用123…n这样一个数来表征，<strong>而如果能找到一种方法迭代这个数的所有可能，就可以输出全排列</strong>，这里选择了最自然的增序迭代</p>
<blockquote>
<p>在i+1到length-1这个子数组中找到第一个大于v[i]的元素（由于已经是降序，v[j]此时肯定是最小的），记为v[j]，swap(v[i], v[j]) , then reverse v[j] to v[length-1] ，就得到了下一个序列</p>
</blockquote>
<p>这一段就是找比现在的数大，但又在剩下的数之间最小的下一个数，即迭代下一项。让最低的位（对应找第一个升序的相邻对）增加最小的值（对应找右向左第一个比v[i]大的交换（同时也是最小的），然后让再右边的…321这样的子序列变成最小的123…）</p>
<p>递归全排列：回溯法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            std::cout &lt;&lt; num &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[l], nums[i]);</span><br><span class="line">            <span class="built_in">permute</span>(nums, l<span class="number">+1</span>, r);</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[l], nums[i]); <span class="comment">// backtrack</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>时间复杂度O（n!)</p>
<ol start="5">
<li><p>循环队列：<strong>规定front指向的单元不能存储队列元素，只起到标志作用</strong>，表示后面一个是队头元素。即 当尚余一个空单元时，队列就算满了。 <strong>队列满的条件是：(rear + 1) % MaxSize &#x3D;&#x3D; front 队列空的条件是：front &#x3D;&#x3D; rear。</strong></p>
</li>
<li><p>n个叶子节点的完全二叉树最多有<strong>2n</strong>个节点</p>
</li>
<li><p>孩子兄弟链表示法的树求深度非递归：双栈，结点栈和深度栈</p>
<p>核心代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!nodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node *current = nodeStack.<span class="built_in">top</span>();</span><br><span class="line">    nodeStack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> currentDepth = depthStack.<span class="built_in">top</span>();</span><br><span class="line">    depthStack.<span class="built_in">pop</span>();</span><br><span class="line">    height = std::<span class="built_in">max</span>(height, currentDepth);</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right) &#123;</span><br><span class="line">        nodeStack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        depthStack.<span class="built_in">push</span>(currentDepth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left) &#123;</span><br><span class="line">        nodeStack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        depthStack.<span class="built_in">push</span>(currentDepth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


</li>
<li><p>堆找第k大元素：两种，大根堆出队k次O（n+klogn），小根堆O（nlogk）</p>
</li>
<li><p>分块查找：<strong>块之间必须有序</strong>，块外部可以无序，<strong>每块内最大（或最小）的元素构成索引块</strong></p>
</li>
<li><p>哈希探测：至少0次探测操作（没有冲突不被计算），至少做了1次比较操作（没有冲突也计算）。闭散列表是迟删除，开散列是直接删除</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/12/30/4FvrSfIWtEiKXRa.png"
                      alt="image-20231230014839352"
                ></p>
</li>
<li><p>希尔排序 &#x3D; 希尔增量序列 + 直接插入排序（），二分插入排序可以提升查找的速度，不能解决元素移动的次数。</p>
</li>
<li><p>选择、希尔排序不是稳定排序，即使固定了选择最前面的也不稳定 例： 5 5 2 -&gt; 2 5 5, 有序的是冒泡，插入，归并，桶，计数和基数（选排：找出最小的，与第一个元素交换，而不是插入）</p>
</li>
<li><p>基数排序：时间复杂度O（N*M），M为最大数的位数。按个位数倒入10个口袋，倒出来；再按10位数倒入10个口袋, ……；</p>
<p>关键字必须是整数。链表实现，数据和分配口袋都是链表。</p>
</li>
<li><p>磁带的各种操作：看起来只考概念和选择和序列生成</p>
</li>
</ol>
<p>2013-2014卷子</p>
<p>给定树的前序和中序，重建树</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootVal = preorder[preStart];</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> leftSize = index - inStart;</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>


<p><strong>核心代码</strong>：非常重要！</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">build</span>(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">build</span>(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure></div>



<p>这个同样可以拿来做题</p>
<p>做题还有一个点是，递归的过程被一个要填的空打断了。</p>
<p>这种情况需要再去看后序遍历的结果，得到leftSize和rightSize之后对后续遍历做大致划分，可以找到对应的某个子树根突破口</p>
<p>牛魔的数据结构程序阅读理解，变量怎么不知道啥意思怎么命名，必须要先了解过算法才能写得出来</p>
<p>图的强连通分量：</p>
<p>在有向图中，强连通分量（Strongly Connected Component，简称SCC）是最大的子图，使得这个子图中的任意两个顶点v和w，都存在v到w和w到v的路径。</p>
<p>什么叫<strong>“极大”子图</strong>？注意不是“最大”子图，极大的意思是不能往里面加结点而保持其强连通性</p>
<p><strong>当我们说”一个有向图里面强连通分量有几个”时，我们是在询问这个有向图可以被分解成多少个这样的强连通分量。换句话说，我们可以将这个有向图划分成多少个区域，使得每个区域内部的任意两个顶点都是强连通的</strong>，而不同区域之间的顶点则不一定强连通。</p>
<p>简单路径：除了起始点可能也是终止点之外，没有中间点被走两遍以上</p>
<p>简单回路：起始点是终点的简单路径</p>
<p>无队列拓扑排序：</p>
<p>思路：使用栈和bfs，在bfs从v回溯到u时，将结点v入栈，此时由于有u-&gt;v的边，所以出栈顺序即为拓扑排序</p>
<p>代码实现：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V;    <span class="comment">// No. of vertices</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; *adj;    <span class="comment">// Pointer to an array containing adjacency lists</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topologicalSortUtil</span><span class="params">(<span class="type">int</span> v, <span class="type">bool</span> visited[], stack&lt;<span class="type">int</span>&gt; &amp;Stack)</span></span>;  <span class="comment">// A recursive function used by topologicalSort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V);   <span class="comment">// Constructor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span></span>;   <span class="comment">// function to add an edge to graph</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">()</span></span>;    <span class="comment">// prints a Topological Sort of the complete graph</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Graph::<span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">    adj = <span class="keyword">new</span> list&lt;<span class="type">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(w); <span class="comment">// Add w to v’s list.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::topologicalSortUtil</span><span class="params">(<span class="type">int</span> v, <span class="type">bool</span> visited[], stack&lt;<span class="type">int</span>&gt; &amp;Stack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;  <span class="comment">// Mark the current node as visited.</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (!visited[*i])</span><br><span class="line">            <span class="built_in">topologicalSortUtil</span>(*i, visited, Stack);</span><br><span class="line"></span><br><span class="line">    Stack.<span class="built_in">push</span>(v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; Stack;</span><br><span class="line">    <span class="type">bool</span> *visited = <span class="keyword">new</span> <span class="type">bool</span>[V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">      <span class="keyword">if</span> (visited[i] == <span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">topologicalSortUtil</span>(i, visited, Stack);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Stack.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        cout &lt;&lt; Stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        Stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>拓扑排序判断有向无环图：找不到入度为0的点即可</p>
<p>dfs判断有向无环图：思路，存在有向无环图时，dfs会无法正常回溯</p>
<p>将结点的状态分成三种:VISITED, VISITING, UNVISITED，结点在第一次访问时变为VISITING，在回溯之后变成VISITED</p>
<p>如果回溯异常，即回溯到了VISITING的结点，对应有向无环图DAG</p>
<p>代码实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    UNVISITED,</span><br><span class="line">    VISITING,</span><br><span class="line">    VISITED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;Status&gt;&amp; status, stack&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    status[node] = VISITING;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status[neighbor] == UNVISITED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(neighbor, graph, status, result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status[neighbor] == VISITING) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status[node] = VISITED;</span><br><span class="line">    result.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDAG</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;Status&gt; <span class="title">status</span><span class="params">(n, UNVISITED)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status[i] == UNVISITED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, graph, status, result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>邻接矩阵的压缩存储：</p>
<p>无向图邻接矩阵是对称的，所以只需要保存上三角矩阵即可,主对角线是0，还可以把主对角线也省略掉</p>
<p>关键路径：源点到收点最长路径，关键活动：关键路径上的活动（边）</p>
<p>关键路径算法：</p>
<ol>
<li>拓扑排序</li>
<li>按照排序后序列的顺序遍历，用类似dijkstra的方法松弛，for edge [p,q] of vertex p : if w[p,q] + ee[p] &lt; ee[q], ee[q] &#x3D; w[p,q] + ee[p], 因为已经拓扑排序了，所以这样的松弛能够保证pq顺序。遍历完成后就得到了每个结点的最早发生时间ee[i]（从源点到该节点的最长路径）</li>
<li>求最迟发生时间，先让每个结点的最迟发生时间为汇点的最早发生时间，然后再（拓扑排序的）反向（i 从 Ver-1 到 0）遍历一次，for edge [p,q] of vertex p : if w[p,q] + le[p] &gt; le[q], le[p] &#x3D; le[q] - w[p,q]</li>
<li>再遍历一次，path &#x3D; [i for i if ee[i] &#x3D;&#x3D; le[i]]，求出关键路径</li>
</ol>
<p>B树删除和合并的左右子树取法在书上是有规定的<br>删除非根结点时，取<strong>右子树的最左结点</strong>删除<br>如果删除后不满足最低结点数据个数，先借左还是右没说，但是合并优先<strong>合并左兄弟</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数理方法课本回顾</title>
    <url>/2024/07/11/%E6%95%B0%E7%90%86%E6%96%B9%E6%B3%95%E8%AF%BE%E6%9C%AC%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="数理方法.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
  </entry>
  <entry>
    <title>杂谈——关于二游之辩</title>
    <url>/2024/07/11/%E6%9D%82%E8%B0%88-%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%B8%B8%E4%B9%8B%E8%BE%A9/</url>
    <content><![CDATA[<ol>
<li>什么是二游</li>
</ol>
<p>作为一个从来没有被正式化过的概念，“二游”究竟是什么是很依赖于玩家共识的，或许有人会觉得有二次元日式萌系画风的就算二游，但我认为这样定义的话会有很多解释不清的东西，例如《rabi-ribi》《终焉的莉莉丝》这种显然不能算二游，乃至像《超次元游戏：海王星》这种JRPG也不能算二游，而你又很难说乙游这种偏韩漫画风的不算二游，甚至这样定义农都能算二游。</p>
<p>所以我暂且给他一个狭义的，我自己认为能够有比较多的人认可的定义，二游应该具备以下几种特性：</p>
<ul>
<li>非现实性漫画性画风的</li>
<li>角色为其一个卖点的（不一定是主要卖点，例如明日方舟很难讲是卖玩法还是角色）</li>
<li>非买断制</li>
<li>多端适配，且移动端手游（即侵占碎片时间）为主要运营方向</li>
</ul>
<span id="more"></span>


<ol start="2">
<li>二游的特点</li>
</ol>
<p>相信诸位看官也能发掘，二游，<strong>其核心在于挤占移动端的空闲时间</strong>，非重度游戏玩家，才是它的目标对象和盈利根本点；又或者说，二游的设计理念就是“副游”。而这个逻辑继续向下挖，<strong>就能发现二游的本质始终是手游</strong>，非买断制造成了：</p>
<ul>
<li><p>二游必须存活</p>
</li>
<li><p>二游的存活来源于流水</p>
</li>
<li><p>二游必须有不断的内容更新以吸引新老玩家氪金</p>
</li>
<li><p>人的垃圾时间是有限的，二游的更新是频繁的，强度环境乃至玩法机制是变化极快的，<strong>一旦一个二游被挤占到了不是第一的位置，对于大部分玩家来说退坑就不远了</strong></p>
</li>
</ul>
<p>这样的逻辑链条</p>
<p>所以之前白姐姐问“二游不能是独游吗”,我的答案非常肯定，独游和我们说的这种狭义二游，整个盈利机制，和盈利机制带来的运营环境、厂商姿态都是完全不同的，例如：</p>
<p>独立游戏开发者和玩家是平等甚至高一等的关系，一方面因为买断制是一锤定音的，且生产独游的技术水平具备稀缺性，你就算今天被2077宣传诈骗坑了，大部分人对此的记忆也不会深刻波及到厂商，另一方面，独立游戏开发者与玩家交互较少，在游戏成型的后续更新后才会继续响应玩家的呼声而优化&#x2F;推出dlc，但独立游戏开发者始终具备主动权，也有着对内容表达的某种默许“独裁权”。但是二游的技术（米系除外）<strong>可替代性非常高</strong>，也由于长线运营的缘故，<strong>厂商一般是对玩家低姿态的（高姿态的参见精灵再临和少前2）</strong>，<strong>玩家对厂商是不信任、不允许独裁的</strong></p>
<p>进一步，二游的核心<strong>从来不在于玩法</strong>，只要还要想吃二游这碗饭，<strong>稳住不爆雷才是核心玩家的第一诉求</strong>。这与其他的内容创作，例如小说、漫画、或者VTB这种“不怕你幽默，就怕你没活”的逻辑截然不同。<strong>二游的内容创作</strong>，是由百度贴吧、b站、nga泥潭、各类小说网站乃至pixiv等合力完成的，而<strong>不是由厂商、或者游戏本体完成的</strong>，所以你能看到诸如碧蓝航线这种完全没有剧情、玩法也很单调的游戏坚挺了七年，而技术力和玩法复杂程度远超的崩坏三却由于运营事故天天流水跳楼，还有少前二的暴死这些在其他游戏类型上很难理解的现象。</p>
<p>那二游的核心是什么呢？<strong>情感诉求</strong>。接下来我慢慢讲。</p>
<ol start="3">
<li>论二游的核心：何为情感诉求盈利</li>
</ol>
<p>我认为，目前国内二游核心渲染的情感诉求主要有二：</p>
<ul>
<li>喜爱、受尊重、恋爱感等，即占据异性位置的：代表如碧蓝航线、偶像大师、碧蓝档案、尘白禁区</li>
<li>竞争、社交、共同语言：代表如原神、赛马娘</li>
</ul>
<p>或许有人会认为存在相当多的第三类，例如有人会认为明日方舟和少女前线的核心是塔防和战棋玩法，有人会认为崩坏三、重返未来1999的核心是剧情和故事，等等。但我是不认同的，我觉得其核心盈利逻辑还是上述两种的组合，就像说到明日方舟，多数人的第一反应是方舟的脚臭文化和血狼破军之类出圈的强度讨论，而不是诸如《孤星》《登临意》这种优质剧情或是其非常棒的音乐。本质在于，当你脱下了二游的皮，拿《孤星》和真正的文字冒险去比，拿音乐和专门的音乐企划去比，<strong>不仅是没比头的，更关键是不能吸引到付费的，这些圈层的人为这样水平、这样占比的东西付费是较少的</strong></p>
<p>二游，甚至手游受限于游戏硬件载体和所占据时间定位条件，必然不是以“深度”盈利的。</p>
<p>所以二游核心的付费逻辑是情感诉求：</p>
<ul>
<li>“原神，启动！原来你也玩原神” 是社交情感诉求</li>
<li>“我是神里绫华的狗”是爱恋情感诉求</li>
<li>赛马娘卷大赛（PVP玩法）是竞争情感诉求+变相的爱恋情感诉求（抽卡资源）</li>
<li>……</li>
</ul>
<p>所以二游的其他一切，玩法、操作、IP、人设、圈子塑造等等等，都是为了满足玩家的情感诉求，更进一步让他们为游戏付费——所构造的，就像几乎没有人会因为在空洞骑士里面战胜了一个设计非常好的boss而向制作组打钱，而像BangDream这种音乐企划，在网易云上最热的歌都是MyGo,并且有断层差距。</p>
<p>所以国内的二游困境其实是，<strong>情感联系断裂容易建立难，而越是断裂，建立越是难</strong>。一方面，游戏题材、政治审查、硬件条件、行业平均水平、乃至二游企划在现实的注资问题，都不允许策划和厂商有过多发挥空间；另一方面，玩家因为被“缅北二游”伤了太多、现实周边人的压力与不理解、大环境的下行，已经出现了难以建立情感联系，乃至于有些过分激动、PTSD的状态。<strong>玩家为二游付费，是知道自己的付出与回报不成正比的，要么是情绪之下的一掷千金（典型如抽卡上头），要么是类似“支持手办”这样的朴素情感投射</strong>（典型如“我二弟才是我大哥”）</p>
<p>基于游戏内容的付费在当下中国的二游市场是极少的，萌芽中的萌芽。</p>
<ol start="4">
<li>情感断裂的衍生物：抽象与乐子人文化、“有男不玩”与ML仙人、缅北二游</li>
</ol>
<p>什么是抽象? 或许这个词的本义就是对抽象最好的概括：对现有释义的解构与小圈子狂欢，就是要让外面的人完全看不懂，里面的人“不是哥们，这么虾头”才叫抽象。如前面所说，<strong>由于二游的内容创作核心是玩家二次创作，所以二游不存在剧情、人物等的“官方定调”</strong>。在叛逆的玩家群体和吃瓜的非玩家群体之中，<strong>经常能发生对话语权的争抢</strong>，典型的有“东海帝王唱的哈吉米是猫”（短视频对赛马娘的入侵）、“狂暴雷普狼”（碧蓝档案的砂狼白子二创覆盖原始角色形象）等。在艾尔登法环之中，你可以对月之公主菈妮发癫，其他人只会“沃日，这么虾头.jpg”而不会跳出来与你争辩是否OOC，就是因为大家在心里有官方背书已经形成上了“什么才是不OOC”的共识。但在二游，那真是“你所热爱的，便是你的生活”，大多数玩家群体认为那是什么，TA就真是什么，<strong>官方甚至会积极入场完善民间私设</strong>，当一个角色被恶意曲解的时候，很多角色厨就只有两个选择：要么一起加入这个抽象狂欢，变成乐子人；要么要退出对话语权的争夺，<strong>与角色和官方、社群的情感联系断裂，不再有付费意愿</strong>，最常见的是就此退游。</p>
<p>与之还有联系的是另一个历史证明的游戏理论：<strong>少数的深度游戏玩家才是（显式或者隐式）营收的贡献主体，而玩家数量的泡沫一戳即破</strong>——不少玩家只是什么游戏玩的人多、什么游戏出圈、什么游戏社交属性强，才会去玩什么。而当核心的内容创作者离开的时候，几乎也就是长线运营的游戏死亡的时候——这个循环甚至是雪崩式的，人越少，创作激励越少，离开的人越多。</p>
<p>这就又能解释一些现象，例如某二字游戏的策划天天暴雷，退坑的老玩家越来越多，但是还没死，甚至一时不见明显衰退之象。但人家就是有足够的游玩人数，也有虽然不算深，但在同类对比里面鹤立鸡群的内容产能，庞大的圈层使得整个内容和情感体系没有崩塌——并且米家的运营策略向来是把角色的话语权掌握在自己手里的（这也需要充足的内容产能支持）。</p>
<p>又例如某种意义上同类的少前二，都是制造“独立女性”人设、“玩家摄像头”、“角色有自己的生活”，卖百合和其他cp，暴死的却比谁都快——无它，内容产出不够，除了情感联系之外没有留下玩家的手段是尔。</p>
<p>所以市场上的二游一般有两种运营策略：</p>
<p>一是如碧蓝航线、赛马娘这种，极致强化玩家的情感联系。碧蓝航线卖爱情卖安全感，就要“你就是角色的生活，角色也是你的生活”，就要用“我同意&#x3D;我接受&#x3D;我爱你”的金伯利恒等式（nga评价为：2024年最伟大的等式（doge），重点还是和唐妞不等式的对比）<strong>来强化、巩固玩家的情感联系，进而衍生出以皮肤而不是抽卡盈利的独特二游体系</strong>（有人会觉得LOL这种也是，但是不同点在于比起全程可见的LOL英雄皮肤，碧蓝航线其实没什么时间能看到皮肤，大家的心态也更倾向于“给心爱的TA卖新衣服”）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.nga.178.com/attachments/mon_202402/04/foQ2t-dqk8K21T3cSsg-cl.jpg"
                      alt="img"
                ></p>
<p>而赛马娘走的是极致强化机制的竞争策略（很有日式的风格）：PVP玩法是日活的核心中的核心，无论是疯狂的新卡爆老卡金币，还是抽卡资源的比例限制（不少部分只能PVP获取），又或是游戏复杂充满随机数和高血压的策略选择体系，都在鼓励玩家养马内卷。</p>
<p>二是尝试跳出这个体系，借独游或是其他游戏探索不同的玩法，做更多的内容创作以降低对玩家情感付费的依赖，例如米家游戏之中，崩坏三的动作机制和3D渲染、星穹铁道的梗和文案设计、原神的开放世界工作量和技术，明日方舟做出特色的rougelike模式、对于传统塔防的探索……但就我的所见所闻而言，这些部分单独拿出算是精巧，但真要放在世界游戏之中竞争, 还是难有竞争力。只能说厂商也难以all in探索。目前的成功很大程度上依赖于国内大学之前很多人没有电脑，又或者主机文化的不流行（笑</p>
<blockquote>
<p>“游戏是一个必须要做到100分的行业”</p>
</blockquote>
<p>说回“缅北二游”，实际上就是国内新培养的一批游戏相关毕业生，觉得自己要“在游戏里面寄托高深精神追求”，但又没这个能力，俗称文青病犯了，想做“艺术类”而不是“服务类”二游，结果伤害了玩家感情，又没有对应玩法导致的一地鸡毛。</p>
<p>注意我没有说过有玩法、内容就可以肆意伤害玩家感情，这个前车之鉴太多了，各种黑深残等等，只是说当游戏有过人之处的时候，<strong>玩家会给游戏创作者一个表达的机会，而基础玩法都做不好的是没资格表达的</strong>。VTB和偶像也是这样，不火的偶像是没资格学樋口圆香的，而VTB爆雷过一次，就会对事业造成永久性创伤（例如七海nanami打拳事件），而二游的容忍度由于玩家已经是碎片时间+满心疲惫+二次元滤镜的程度，会更加低</p>
<blockquote>
<p>“游戏是一个必须要做到100分的行业”</p>
</blockquote>
<p>理解了这个之后，对于“有男不玩”这种现象，就也可以理解了，玩家不信任厂商的一碗水端平能力，拒绝让厂商有伤害自己感情的机会，本质上是一种应激自保行为。“有男不玩”的核心从不在于“有男”，而在于“不玩”——是部分玩家群体向某些视觉上的服务业、实际上的畜牧业的厂商的一种朋克式反叛，所谓“矫枉必须过正”是也。</p>
<ol start="5">
<li>玩家圈层的资源竞争与“借鸡生蛋”</li>
</ol>
<p>还有许多大佬有着这样的观点</p>
<ul>
<li>二游的资源（现有厂商的产能）是极其有限的，但是玩家的诉求是多种多样的，这是其一</li>
<li>不同的玩家都想玩到最合自己心意的二游，这是其二</li>
<li><strong>一旦一个二游被挤占到了不是第一的位置，对于大部分玩家来说退坑就不远了</strong>，因而尽管大家知道什么才能带来流水（也可能不知道），但是对核心情感&#x2F;玩法塑造不自信的情况下，厂商的第一要务不是“保住锅里的”，而是“去抢碗里的”</li>
<li>也正由于此，才会有越来越多的厂商盯上了较少被开发的女性玩家的地盘，才会有原神的黑丝小男孩、散兵路人缘极差的人设等现象</li>
<li>而这种女性玩家对原先男性玩家生态位的挤压，<strong>或者本质上是少数需求玩家对多数需求玩家的挤压，本质上是一种“借鸡生蛋”</strong>。比如，假设我是一个福瑞控，但福瑞控在玩家群体的数量不足，不足以让厂商专门出一款全是福瑞的游戏，那我就只能在其他已有游戏之中发声，利用老玩家音量小的特性——来向厂商传递错误需求，让他更多地出福瑞角色——这本质上是资源不够。在广得多得多的买断制游戏市场就少有这个现象。</li>
<li>也由于上面，你不玩某开放世界二游，你又想玩开放世界二游，那你还能玩什么呢？等两年蓝色星原吗？最后的归宿就是，要么在一个二游定居，要么最后不玩二游。</li>
</ul>
<ol start="6">
<li>其他观点</li>
</ol>
<p>还有很多观点，例如扯到性焦虑的、结合社会环境分析的，巴拉巴拉，这东西知乎b站上一堆，我就不多讲了，主要以一个<strong>游戏玩家</strong>——并非游戏制作者、UP主、或是冷眼点评的评论家的的观点，粗鄙之言，还望大家嘴下留情。</p>
]]></content>
  </entry>
  <entry>
    <title>浅入理解断点和调试器</title>
    <url>/2024/07/11/%E6%B5%85%E5%85%A5%E7%90%86%E8%A7%A3%E6%96%AD%E7%82%B9%E5%92%8C%E8%B0%83%E8%AF%95%E5%99%A8/</url>
    <content><![CDATA[<h4 id="浅入理解断点和调试器"><a href="#浅入理解断点和调试器" class="headerlink" title="浅入理解断点和调试器"></a>浅入理解断点和调试器</h4><p>主要参考</p>
<p><a class="link"   href="https://events.static.linuxfound.org/sites/events/files/slides/slides_16.pdf" >https://events.static.linuxfound.org/sites/events/files/slides/slides_16.pdf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information" >https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<span id="more"></span>
<p>在写知识之前，不如先问自己几个问题：</p>
<ul>
<li>debugger的实现原理是什么？</li>
<li>断点(breakpoint)和监视点(watchpoint)的区别？</li>
<li>断点有哪些实现方法？具体到gdb之中，它是怎么实现的？</li>
</ul>
<p><strong>debugger的最基本原理，就是这样的代码</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Expected a program name as argument\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">run_target</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">run_debugger</span>(child_pid);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>debugger作为父进程，使用fork调出了需要debug的子进程，然后通过某种方法和子进程交互（操控子进程）</p>
<p>那么就引出了这样的问题：</p>
<ol>
<li>怎么操控的（允许操控的机制）</li>
<li>操控之后的控制流</li>
<li>已经控制了，debug信息从哪来（如果不做处理，高级语言编译之后是没有原来的代码行数、变量符号等信息的）</li>
</ol>
<p>又可以进一步总结出以下几点，</p>
<p><strong>debug需要信息：</strong></p>
<ol>
<li><p>在高级代码—&gt;汇编的过程之中，我们需要代码的一一对应关系，比如第几行的高级代码对应第几行（到第几行）的汇编代码</p>
</li>
<li><p>在汇编代码—&gt;可执行文件的过程之中，我们需要将有用的信息保存在可执行文件内</p>
</li>
</ol>
<p><strong>debug需要断点：</strong></p>
<ol start="3">
<li>需要有一种方法在gdb或者在可执行文件之中达成中断</li>
<li>进一步地，需要让gdb（父进程）能够控制、监视、改变子进程（被调试的进程）</li>
</ol>
<p>解决了这几个问题，理论上就能产生debugger</p>
<p>问题1，很遗憾，由于现代编译器的优化和现代编程语言的复杂性，源程序语言和编译完成的汇编，又或者说最后执行的机器指令很难完美对应，编译器开启对应的编译指令之后也只能做到近似（**不能完全相信back trace!**）但大体上还是对的。（也可以强制让编译器不优化）</p>
<p>下图转载： <code>gdb br</code>的失败例子</p>
<p>问题2，这就是为什么需要gcc <strong>-g</strong> 的理由，<strong>也是为什么可以不止于对内存地址设断点，还能对一个函数，一行源代码设断点的原因</strong></p>
<blockquote>
<p>现代编译器在将高级代码转换为高级代码方面做得很好，其缩进和嵌套的控制结构以及任意类型的变量可以很好地转换为一大堆称为机器代码的位，其唯一目的是在目标 CPU 上尽可能快地运行。大多数 C 行被转换为多个机器代码指令。变量被推到各处 - 进入堆栈、寄存器或完全优化。<strong>结构和对象甚至不存在于生成的代码中 - 它们只是一个抽象</strong>，被转换为硬编码的偏移量到内存缓冲区中。</p>
<p>那么，当您要求调试器在某个函数的入口处中断时，调试器如何知道在哪里停止呢？当你向它询问变量的值时，它是如何找到要显示的内容的？<strong>答案是 - 调试信息</strong>。<br>**<strong>调试信息由编译器与机器代码一起生成。它是可执行程序和原始源代码之间关系的表示。这些信息被编码为预定义的格式，并与机器代码一起存储</strong>。多年来，为不同的平台和可执行文件发明了许多这样的格式。由于本文的目的不是调查这些格式的历史，而是展示它们的工作原理，因此我们必须确定一些事情。这将是 DWARF，它今天几乎无处不在地用作 Linux 和其他 Unix-y 平台上 ELF 可执行文件的调试信息格式。</p>
</blockquote>
<p>对应elf文件中的.debug_**段</p>
<p>如何进一步阅读?</p>
<p><code>objdump --dwarf=info</code></p>
<p>info可以换成别的</p>
<p>问题3、4</p>
<p>debug需要断点，需要某种可恢复的中断，怎么做？</p>
<ul>
<li>软件支持</li>
<li>硬件支持</li>
</ul>
<p>先讲硬件支持是怎么实现的。如果设备有实现硬件debug，<strong>它会在内存之中占据一段特殊的位置，使得这个硬件支持对cpu是可见的</strong></p>
<p>（cpu也实现了debug的控制寄存器和控制单元）。<strong>而gdb在debug时，会先确定本机的架构和硬件信息，之后根据硬件信息去寻找相关的debug是否有硬件支持。</strong></p>
<p>而这个硬件支持表现在能够硬件上单步执行，通过比较器设置断点，etc</p>
<blockquote>
<p>Gateway between re-purposed JTAG bit protocol and debug logic</p>
<p>Debug hardware often visible in a special memory address space</p>
<p>E.g. (gdb) stop requires writing 0x1 (Halt Request) to address 0x090 (Debugger Run Control Register) of the CPU debug unit.</p>
<ul>
<li><p>Shift 4 bits into IR</p>
</li>
<li><p>Shift 34 bits into DR</p>
</li>
<li><p>Shift 4 bits into IR</p>
</li>
<li><p>Shift 34 bits into DR</p>
</li>
<li><p>Shift 34 bits into DR</p>
</li>
</ul>
</blockquote>
<p>另一种就是软件支持，</p>
<p>首先是中断，当程序运行到断点的时候，它应该向gdb发出一个中断信号（比如SIGTRAP），之后gdb程序（父进程）接收到中断信号后，辨别出这个是断点产生的中断还是程序正常运行的中断，并加以处理</p>
<p>然后是ptrace系统调用，这个系统调用允许一个进程去得到另一个进程的控制权，包括监视、改变、发送命令等</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_target</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* programname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;target started. will run &#x27;%s&#x27;\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allow tracing of this process */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace this process&#x27;s image with the given program */</span></span><br><span class="line">    <span class="built_in">execl</span>(programname, programname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而有了中断之后，一种简单的实现方法可能是这样的：</p>
<p>在指定的地址上设一个监视点w</p>
<p>首先，每次运行一条指令之后我都切换到debugger，比对一下pc和监视地址是否相同，如果相同，那么我就停止</p>
<p>这种切换的机制来源于：</p>
<ol>
<li>wait() 不止在子进程exit时才会退出，在子进程触发中断时也会返回，并保存一些中断信息</li>
<li>ptrace调用定义了一个特殊的request PTRACE_SINGLESTEP，会告诉OS启动被监控进程，但是一条指令后停止（pc+4），并产生中断通知父进程</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_debugger</span><span class="params">(<span class="type">pid_t</span> child_pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> wait_status;</span><br><span class="line">    <span class="type">unsigned</span> icounter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;debugger started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for child to stop on its first instruction */</span></span><br><span class="line">    <span class="built_in">wait</span>(&amp;wait_status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">WIFSTOPPED</span>(wait_status)) &#123;</span><br><span class="line">        icounter++;</span><br><span class="line">        <span class="comment">/* Make the child execute another instruction */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></span><br><span class="line">        <span class="built_in">wait</span>(&amp;wait_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">procmsg</span>(<span class="string">&quot;the child executed %u instructions\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们当然可以用这种单步执行比对pc的“监视点”方法实现断点，但这个方法的问题是，每执行一条指令都要不断切换进程，效率太低了</p>
<p>jyy介绍， gdb用了一种很神奇的方法： int 3（注意这个int不是integer 的int）偷龙转凤</p>
<p>int 3 是一个单字节x86指令，作用就是简单地发出一个中断SIGTRAP</p>
<p>单字节使得它能够替换到任何一条指令的开头，并且不会覆盖两条及以上的指令</p>
<p>在设置断点的时候，<strong>gdb可以将断点处的指令保存起来，之后替换它的首个字节为int 3</strong></p>
<blockquote>
<p><strong>Instruction at the given address is read, saved and replaced with a breakpoint:</strong></p>
<p>​ <strong>- either a special instruction, &#x2F;&#x2F; SIGTRAP, int 3</strong></p>
<p>​ <strong>- or an undefined encoding. &#x2F;&#x2F; SIGILL</strong></p>
</blockquote>
<p>之后程序正常运行，执行到int 3时产生中断（SIGTRAP，int 3就是第三号TRAP，x86的调试器中断），而gdb程序作为父进程收到这个信号，达成中断（通过ptrace设置了中断的handler），之后也可以将原来的指令替换回来继续执行。</p>
<p>继续执行的细节：</p>
<p>实际上在有了ptrace的调用之后，每当被监控程序执行exec的时候，就会发出一个中断</p>
<blockquote>
<p>Indicates that this process is to be traced by its parent. Any signal (except SIGKILL) delivered to this process will cause it to stop and its parent to be notified via wait(). <strong>Also, all subsequent calls to exec() by this process will cause a SIGTRAP to be sent to it, giving the parent a chance to gain control before the new program begins execution</strong>. A process probably shouldn’t make this request if its parent isn’t expecting to trace it. (pid, addr, and data are ignored.)<br>指示此过程将由其父级跟踪。传递给此进程的任何信号（SIGKILL 除外）都会导致它停止，并通过 wait（） 通知其父级。此外，此进程对 exec（） 的所有后续调用都将导致向它发送 SIGTRAP，从而使父级有机会在新程序开始执行之前获得控制权。如果进程的父进程不希望跟踪它，则进程可能不应发出此请求。（PID、ADDR 和 DATA 将被忽略。</p>
</blockquote>
<p>小的自问自答环节：</p>
<p>Q：为什么gdb不是特权指令？它读寄存器值、内存值等是怎么实现的？</p>
<p>A：<strong>但install是特权指令（笑）</strong>，Linux之中，二进制文件是自动具备可执行的默认权限的（<strong>file mode</strong>），而不是像bash脚本那样需要sudo chmod +x 给予权限。</p>
<p>并且咨询gpt还得到一个有趣的事情：ptrace调用确实可以修改其他的进程，<strong>所以ptrace调用是需要root权限</strong>，但是，<strong>用户权限下，可以使用setuid或者setcap机制，是gdb能对特定的文件，具有特定系统调用的权限</strong></p>
<p>读寄存器值是使用了特定的中断，读内存是读的虚拟内存。</p>
]]></content>
  </entry>
  <entry>
    <title>编程随想blog笔记</title>
    <url>/2024/07/11/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3blog%E7%AC%94%E8%AE%B0%EF%BC%9A/</url>
    <content><![CDATA[<h3 id="编程随想blog笔记："><a href="#编程随想blog笔记：" class="headerlink" title="编程随想blog笔记："></a>编程随想blog笔记：</h3><blockquote>
<p><strong>如何用十年掌握编程？</strong></p>
<p>　　研究人员（Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)）得出结论：想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。<strong>关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能力限度的事情，尝试并思考你的表现，并自我矫正。周而复始。</strong></p>
</blockquote>
<hr>
<span id="more"></span>

<h4 id="python系列的魔法"><a href="#python系列的魔法" class="headerlink" title="python系列的魔法"></a>python系列的魔法</h4><p>一、何为动态语言？</p>
<p>动态语言和静态语言的区别本质并不是编译和解释的区别，而是<strong>“能否在运行时修改自身程序结构”</strong>的区别。能修改自身结构的就属于动态语言。</p>
<p>二、使用运行时修改自身的特性</p>
<p>例子：</p>
<p>python自带的exec和eval方法</p>
<p>eval: 对一个字符串表达式求值</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">op:<span class="built_in">str</span>, num1:<span class="built_in">str</span>, num2:<span class="built_in">str</span></span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">f&quot;<span class="subst">&#123;num1&#125;</span> <span class="subst">&#123;op&#125;</span> <span class="subst">&#123;num2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>(<span class="params">op:<span class="built_in">str</span>, num1:<span class="built_in">str</span>, *args:<span class="built_in">tuple</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(args) &gt; <span class="number">0</span>)</span><br><span class="line">    result = num1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">f&quot;<span class="subst">&#123;result&#125;</span> <span class="subst">&#123;op&#125;</span> <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(foo(<span class="string">&quot;+&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(foo(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(foo(<span class="string">&quot;*&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo2:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(foo2(<span class="string">&quot;+&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cal:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(cal(<span class="string">&quot;1+2*3&quot;</span>)))</span><br></pre></td></tr></table></figure></div>



<p>联合类型标注和重载</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x:<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>], y:<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other:<span class="string">&#x27;Vector&#x27;</span></span>)-&gt;<span class="string">&#x27;Vector&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other:<span class="string">&#x27;Vector&#x27;</span></span>)-&gt;<span class="string">&#x27;Vector&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x - other.x, <span class="variable language_">self</span>.y - other.y);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other:<span class="string">&#x27;Vector&#x27;</span></span>)-&gt;<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x*other.x + <span class="variable language_">self</span>.y*other.y;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    v2 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v1: &#123;&#125;, v2: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(v1, v2)) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(v1, v2, v1 + v2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; - &#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(v1, v2, v1 - v2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; * &#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(v1, v2, v1 * v2))</span><br></pre></td></tr></table></figure></div>



<p>exec的妙用——用户自配置，运行时生成函数：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mail</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Title:<span class="built_in">str</span>, Content:<span class="built_in">str</span>, From:<span class="built_in">str</span>, To:<span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.Title = Title</span><br><span class="line">        <span class="variable language_">self</span>.Content = Content</span><br><span class="line">        <span class="variable language_">self</span>.From = From</span><br><span class="line">        <span class="variable language_">self</span>.To = To</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Title: <span class="subst">&#123;self.Title&#125;</span>, Content: <span class="subst">&#123;self.Content&#125;</span>, From: <span class="subst">&#123;self.From&#125;</span>, To: <span class="subst">&#123;self.To&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RuleKey</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Title = <span class="string">&quot;Title&quot;</span></span><br><span class="line">    Content = <span class="string">&quot;Content&quot;</span></span><br><span class="line">    From = <span class="string">&quot;From&quot;</span></span><br><span class="line">    To = <span class="string">&quot;To&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rules</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rule_dict: <span class="type">Dict</span>[RuleKey, <span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.rules = rule_dict</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;rule_dict: <span class="subst">&#123;self.rules&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_config</span>(<span class="params">mail:Mail, rules: Rules</span>):</span><br><span class="line">    code = <span class="string">f&#x27;&#x27;&#x27;    </span></span><br><span class="line"><span class="string">def mail_filter(Title: str, Content: str, From: str, To:str)-&gt;bool:</span></span><br><span class="line"><span class="string">    if(Title.find(&quot;<span class="subst">&#123;rules.rules[RuleKey.Title]&#125;</span>&quot;) != -1 or Content.find(&quot;<span class="subst">&#123;rules.rules[RuleKey.Content]&#125;</span>&quot;) != -1 or From.find(&quot;<span class="subst">&#123;rules.rules[RuleKey.From]&#125;</span>&quot;) != -1 or To.find(&quot;<span class="subst">&#123;rules.rules[RuleKey.To]&#125;</span>&quot;) != -1):</span></span><br><span class="line"><span class="string">        return True</span></span><br><span class="line"><span class="string">    return False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    local_dict= &#123;&#125;</span><br><span class="line">    <span class="built_in">exec</span>(code, <span class="literal">None</span>, local_dict)</span><br><span class="line">    mail_filter = local_dict[<span class="string">&quot;mail_filter&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> mail_filter(mail.Title, mail.Content, mail.From, mail.To)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_input_handler</span>()-&gt;Rules:</span><br><span class="line">    parser = argparse.ArgumentParser(prog=<span class="string">&quot;mail filter&quot;</span>, description=<span class="string">&quot;set email filter config.&quot;</span>,</span><br><span class="line">                                     epilog=<span class="string">&quot;The test version&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--title&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;filter title: should contain this string&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--content&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;filter content: should contain this string&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--from&quot;</span>, dest=<span class="string">&quot;my_from&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;filter from: should contain this string&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-to&quot;</span>, <span class="string">&quot;--to&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;filter to: should contain this string&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;parsed args:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;title: <span class="subst">&#123;args.title&#125;</span>, content: <span class="subst">&#123;args.content&#125;</span>, from: <span class="subst">&#123;args.my_from&#125;</span>, to: <span class="subst">&#123;args.to&#125;</span>&quot;</span>)</span><br><span class="line">    r : <span class="type">Dict</span>[RuleKey, <span class="built_in">str</span>] = <span class="built_in">dict</span>()</span><br><span class="line">    r[RuleKey.Title] = args.title</span><br><span class="line">    r[RuleKey.Content] = args.content</span><br><span class="line">    r[RuleKey.From] = args.my_from</span><br><span class="line">    r[RuleKey.To] = args.to</span><br><span class="line">    <span class="keyword">return</span> Rules(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    m = Mail(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="comment"># r = Rules(&#123;RuleKey.Title: &quot;test&quot;, RuleKey.Content: &quot;test&quot;, RuleKey.From: &quot;test&quot;, RuleKey.To: &quot;test&quot;&#125;)</span></span><br><span class="line">    r = user_input_handler()</span><br><span class="line">    <span class="built_in">print</span>(filter_config(m, r))</span><br></pre></td></tr></table></figure></div>


]]></content>
  </entry>
</search>
