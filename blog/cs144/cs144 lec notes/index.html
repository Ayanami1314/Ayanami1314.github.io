<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">CS144 Lecture Notes | Ayanami&#x27;s Cave</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ayanami1314.github.io/blog/cs144/cs144 lec notes"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="CS144 Lecture Notes | Ayanami&#x27;s Cave"><meta data-rh="true" name="description" content="Unit 1: Internet and IP"><meta data-rh="true" property="og:description" content="Unit 1: Internet and IP"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-09-20T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="network,cs144"><link data-rh="true" rel="icon" href="/img/ayanami.jpg"><link data-rh="true" rel="canonical" href="https://ayanami1314.github.io/blog/cs144/cs144 lec notes"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/cs144/cs144 lec notes" hreflang="en"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/cs144/cs144 lec notes" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://ayanami1314.github.io/blog/cs144/cs144 lec notes","mainEntityOfPage":"https://ayanami1314.github.io/blog/cs144/cs144 lec notes","url":"https://ayanami1314.github.io/blog/cs144/cs144 lec notes","headline":"CS144 Lecture Notes","name":"CS144 Lecture Notes","description":"Unit 1: Internet and IP","datePublished":"2024-09-20T00:00:00.000Z","author":{"@type":"Person","name":"ayanami"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://ayanami1314.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Ayanami&#39;s Cave Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/personal-essays/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/personal-essays/atom.xml" title="Ayanami&#39;s Cave Atom Feed">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.00dd3480.css">
<script src="/assets/js/runtime~main.b29abffd.js" defer="defer"></script>
<script src="/assets/js/main.84cf7678.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Ayanami&#x27;s Cave</b></a><a class="navbar__item navbar__link" href="/docs/Chcore源码阅读/">课程笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">技术博客</a><a class="navbar__item navbar__link" href="/personal-essays">个人随笔</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs186-database-WIP">ucb cs186 课程笔记(更新中)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os-虚拟化">NJU操作系统(jyy OS)课程笔记-虚拟化部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/local-llm">来本地部署大模型!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ostep-chapter42-44">ostep阅读笔记：单机fs的崩溃一致性(chapter42-44)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/系统架构设计笔记">system-design-interview笔记</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/JUC">JUC</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs144 labs">cs144 labs(Winter 2024)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os：并发">NJU操作系统(jyy OS)课程笔记-并发部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/nginx">nginx基础</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/cs144/cs144 lec notes">CS144 Lecture Notes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/django-mosh">Django_mosh</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/splay-tree">splay tree</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/xv6book-notes">xv6book Notes(C1-4)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Go-Gin学习">Go,Gin学习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/godis源码阅读">godis源码阅读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/hibernate-jpa">hibernate&amp;jpa</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/linking-复习">linking 复习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ts基础">ts基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/实战2-mosh-gamehub">react practice:mosh gamehub</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/浅入理解断点和调试器">浅入理解断点和调试器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/黑马点评">黑马点评(速通版)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/js基础">js基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/11-14-11-26学习双周记">11-14-11-26学习双周记</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">CS144 Lecture Notes</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-09-20T00:00:00.000Z">September 20, 2024</time> · <!-- -->69 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-1-internet-and-ip">Unit 1: Internet and IP<a class="hash-link" aria-label="Direct link to Unit 1: Internet and IP" title="Direct link to Unit 1: Internet and IP" href="/blog/cs144/cs144 lec notes#unit-1-internet-and-ip">​</a></h2>
<p>网络四层模型<!-- -->:application<!-- -->, transport, network, link</p>
<p>7层OSI, 拆app,trans,link为更细的两个</p>
<p>网络的基础和底层是IP, 只有IP model是不可替代的“细腰”,上层的application、transport和下层的link都是可以替换的</p>
<p>application 应用层,smtp, ftp, http, ssh</p>
<p>transport 传输层,tcp, udp, rdp</p>
<p>link 连接层,4G, WiFi, ...</p>
<p>网络连接的几种常见例子:</p>
<p>client-server, BitTorren 一服务器多client的集群, ......</p>
<p>网络 application上 <!-- -->:read<!-- -->/write</p>
<p>传输过程 app-&gt;...-&gt;link-&gt;(link-&gt;network-&gt;link)(router) -&gt;... link-&gt;...-&gt;app</p>
<p>IP(Internet protocol) service model:</p>
<p>设计目标:简单甚至笨拙,端到端(end-to-end),意味着尽可能减少中间router的工作量,能放在end的计算机上的都放在end的计算机上。对上下做非常少的假设。</p>
<p>几个特点:</p>
<ul>
<li>Unreliable(不保证能传到) 由上层的协议,如tcp来实现重传等确保传到</li>
<li>Best effort: 尽量传到,只有在必要时才丢弃数据包(什么是必要时？例如中间路由器满了无法处理新请求)</li>
<li>Datagram:传输的每一个包(packets)都是自路由(individually routed),也就是保存了<code>Src_IP</code>和<code>Dst_IP</code>不需要依赖其他包来传输,同时传输依靠路由器一跳一跳(hop-by-hop)</li>
<li>Connectionless: 无状态,包的顺序可以被打乱,发送和接受也没有要求“建立连接”</li>
</ul>
<p>一些细节:</p>
<ul>
<li>
<p>Tries to prevent packets looping: packet内简单对跳转次数计数,达到某个值时router会丢弃</p>
</li>
<li>
<p>大数据包会拆成多个 (fragment)</p>
</li>
<li>
<p>使用IP 标头校验是否发送错误和重新组合</p>
</li>
<li>
<p>允许加入新字段</p>
</li>
</ul>
<p>IP 标头</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/05/6wuf2QUWsX5pGd7.png" alt="ipv4-datagram" class="img_ev3q"></p>
<p>大部分字段都是不言而喻的,flags和fragment offset用于拆分数据的重新组合,checksum是标头的,用于检测是否损坏,protocol ID根据ID指定协议,比如TCP, version指定IPv4, TTL用于跳转计数避免循环,type of service是一个服务器标识符,用于表达这个包的重要性</p>
<p>可以用<code>traceroute</code>查看包在路由器中的路径</p>
<p>TCP Byte Stream</p>
<p>通过<code>{IP, port}</code>来通信,中间过计算机或者router, 例如wifi第一跳是过wifi接入点路由器</p>
<p>路由器转发:转发表模式匹配(最大前缀匹配)</p>
<blockquote>
<p>如果在地址匹配过程中,不能和路由表中任何条目所匹配,packet将被丢弃。</p>
<p>【一个名为 Destination Unreachable(目标不可达)的ICMP信息将发回给源地址】</p>
</blockquote>
<p>TCP 三次握手(3-way handshake)</p>
<ul>
<li>client \-&gt; server SYN 请求</li>
<li>server \-&gt; client SYN/ACK 确认请求</li>
<li>client \-&gt; server ACK 确认请求</li>
</ul>
<p>packet switching:</p>
<p><strong>Independently</strong> for each arriving packet, pick its outgoing link. If the link is free, send it. Else <strong>hold the packet</strong> for later.</p>
<p>早期的 跳跃是这样的,每一个路由器将src_ip改成自己(这就是NAT,网络地址转换,将大量的私有IP隐藏在少量公有IP里面),然后继续往下走</p>
<blockquote>
<p>安全网关处于私有网络和公有网络的连接处。当内部PC(10.1.1.2)向外部服务器(202.1.1.2)发送一个IP包1时,IP包将通过安全网关。安全网关查看包头内容,发现该IP包是发向公有网络的,然后它将IP包1的源地址10.1.1.2换成一个可以在Internet上选路的公有地址202.1.1.1,并将该IP包发送到外部服务器,与此同时,安全网关还在网络地址转换表中记录这一映射。外部服务器给内部PC发送IP包1的应答报文2(其初始目的地址为202.1.1.1),到达安全网关后,安全网关再次查看包头内容,然后查找当前网络地址转换表的记录,用内部PC的私有地址10.1.1.2替换目的地址。这个过程中,安全网关对PC和Server来说是透明的。对外部服务器来说,它认为内部PC的地址就是202.1.1.1,并不知道10.1.1.2这个地址。因此,NAT“隐藏”了企业的私有网络。</p>
</blockquote>
<p>但安全问题比较大,路由器不希望目标知道自己的ip, 就改成全dst, 每次跳跃都将src改为下一跳的ip</p>
<p>结果</p>
<ul>
<li>简单的packet传播</li>
<li>高效的链接共享</li>
</ul>
<p>No per-flow state required:</p>
<p>两端不需要知道router的state, router不需要存储其他的state(因而不需要考虑清除错误的状态)</p>
<p>由于是以包作为最小单位,链接共享和流量分配很简单-&gt;根本不需要管谁传过来的,有包就发</p>
<p>Layering 分层:</p>
<p>seperation concerns</p>
<p>模块化,重用,明确的上下边界,关注点分离,Peer-to-peer communication</p>
<p>装包是灵活的</p>
<p>VPN example</p>
<p>从里到外HTTP data \-&gt; TCP(to web) -&gt;IP(to web) \-&gt; TLS(to VPN)-&gt;TCP(to VPN)-&gt;IP(to VPN)\-&gt; Ethernet(to next hop)</p>
<p>字节序,内存:网络字节序,大端序</p>
<p>IPv4</p>
<p>32位 a.b.c.d 192.168.0.1</p>
<p>netmask 子网掩码:<strong>apply this mask, if it matches, in te same network</strong> (if IP_A &amp; mask == IP_B &amp; mask,在一个子网里面)</p>
<p>例如 netmast 255.255.255.0 意味着前24bit match</p>
<p><strong>第一跳时,如果Src_IP 和 Dst_IP在同一子网内,不走外面路由器</strong> \-&gt; 127.0.0.1 和 127.X.X.X</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; ifconfig</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inet 127.0.0.1  netmask 255.0.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>地址结构(historical):</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/05/BQAF9LH7EI1tZo8.png" alt="image-20240905234039196" class="img_ev3q"></p>
<p>问题:不够灵活</p>
<p>目前<!-- -->:CIDR<!-- --> Classless Inter-Domain Routing</p>
<p>171.64.0.0/16  /16意味着16位子网掩码,171.64.0.0 ~ 171.64.255.255都是</p>
<p>ICANN ip地址分配</p>
<p>Longest Prefix Match(最长前缀匹配)</p>
<p>转发表实际上是 a set of CIDR entries</p>
<table><thead><tr><th>dest</th><th>link</th></tr></thead><tbody><tr><td>0.0.0.0/0 (x.x.x.x, default, 每个router都有)</td><td>1</td></tr><tr><td>171.33.0.0/16 (171.33.x.x)</td><td>5</td></tr></tbody></table>
<p>Address Resolution Protocol(ARP) 地址解析协议</p>
<p>解决问题:我有IP, 那发送到哪个硬件？(Link层,描述特定网卡,有唯一ID)</p>
<p>eg 48bit Ethernet 00:13:72:4c:d9:6a</p>
<p>例如,有一个网关gateway交换机,他有不同的接口,对应不同的ip</p>
<p>从IP_A -&gt; IP_B的内部请求,IP_A先由子网掩码把请求发到gateway接口A, gateway识别packet的dst_IP之后通过接口B发出,再由子网掩码发送到IP_B</p>
<p>ARP link 和 network层之间,缓存 ip &lt;-&gt; link 地址的mapping</p>
<p>简单的 request-reply 结构</p>
<p>要发送消息给ip X, 先查缓存, 如果没有, sent request to link layer broadcast address “谁有IP X?”</p>
<p>当IP_X接收到数据的时候给Src发“我有IP X&quot;(不走广播)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-2-transport">Unit 2: Transport<a class="hash-link" aria-label="Direct link to Unit 2: Transport" title="Direct link to Unit 2: Transport" href="/blog/cs144/cs144 lec notes#unit-2-transport">​</a></h2>
<p>The TCP Service Model</p>
<p>Reliable byte delivery service</p>
<ul>
<li>Acknowledgments indicate correct delivery</li>
<li>Checksums detect corrupted data</li>
<li>Sequance numbers detect missing data</li>
<li>Flow-control prevents overruning receiver</li>
<li>Congestion Control 拥堵控制</li>
</ul>
<p>TCP Segment Format</p>
<p>Unique TCP connection: IP DA, IP SA, Protocol ID=&quot;TCP&quot;, Source Port, Destation Port</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/06/sNe1a4CtuPxMKB2.png" alt="image-20240906195851377" class="img_ev3q"></p>
<p>通过sequence 和acknowledgment sequence可以确定前N个字 节已经正确发送,sequence是TCP Data的首个字节在TCP试图发送的字节流中位置</p>
<p>FIN flag 标志关闭,关闭TCP连接的过程就是一方A先发FIN, 关闭A-\&gt;B的管道, 之后B确定发送完数据后发送FIN到A, 关闭B到A管道。 PSH指示立刻发送新数据而不是等待更多老数据</p>
<p>window-based flow control</p>
<p>retransmission and timeouts</p>
<p>UDP Service Model</p>
<p>UDP 标头只有四个段:</p>
<p>Source Port, Destination Port, Checksum, Length</p>
<p>No connection established</p>
<p><strong>Packets may show up in any order!!!</strong></p>
<p>没有确认,没有检测丢包和乱序的机制,没有流量控制</p>
<p>ICMP Internet Control Message Protocal</p>
<p>Communicates network layer info between end hosts and routers</p>
<p>Reports error conditions</p>
<ul>
<li>Reporting Message</li>
<li>Unreliable - no retries</li>
</ul>
<p>典型的ICMP IP header | ICMP header | ICMP data</p>
<p>ICMP header里面主要就是 type 和 code, 两者合起来描述了一个message(通过对照表, 例如 )</p>
<table><thead><tr><th>0-Echo响应</th><th>0</th><th>Echo响应报文</th></tr></thead><tbody><tr><td>3-目的不可达</td><td>0</td><td>目标网络不可达报文</td></tr></tbody></table>
<p>用于 ping, traceroute等</p>
<p>traceroute怎么实现？很精巧的设计</p>
<p>clientA-\&gt;B A发送一个TTL为1的UDP message,然后第一个router接受,TTL为0, 决定丢弃并回传一个ICMP消息</p>
<table><thead><tr><th>11-ICMP超时</th><th>0</th><th>TTL超时报文</th></tr></thead></table>
<p>clientA拿到这个报文就得到了第一个router节点的信息,之后就可以发送一个TTL=2的...以此类推</p>
<p>End-To-End Principle</p>
<p>Error Detection</p>
<ul>
<li>Checksum:简单将data 加和,弱但快</li>
<li>CRC校验:计算多项式余数 强一些,慢一些,纠错一位,查错2位</li>
<li>消息验证码MAC -&gt; TLS, 需要密钥 剩下的一点问题在与一个k位的码如果发生单位翻转,有2^-k的可能检测不出来,从这  个角度上可能不如CRC</li>
</ul>
<p>IP/UDP/TCP Checksum: 报头中所有其他16位字的反码和的16位反码</p>
<p>检验,整个IP标头的求和结果应该为0(修改标头比如TTL时需要重新计算)</p>
<p>快,但只保证查1位错</p>
<p>Link Layer广泛使用CRC</p>
<p>MAC</p>
<p>有限状态机 FSM</p>
<p><img decoding="async" loading="lazy" src="https://code.wandoer.com/wp-content/uploads/2019/03/tcpfsm.jpg" alt="FSM" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://upload.wikimedia.org/wikipedia/en/5/57/Tcp_state_diagram.png" alt="img" class="img_ev3q"></p>
<p>Flow Control</p>
<p>sender可以send 500000个packet/s</p>
<p>receiver 只能receive 200000个</p>
<p>原则是sender减少发送的包数量,receiver give feedback</p>
<ul>
<li>stop &amp; wait sender发一个就等一个ACK, 除非超时没有接受ACK重发,receiver接一个回一个ACK</li>
</ul>
<p>有一个问题是ACK Delay</p>
<p>如果sender发了一个包A0,但ACK在timeout了,尝试重发A1后才收到,于是sender继续发下一个包B0,sender如何区分此时接受到的ACK是A1的ACK还是B0的ACK?</p>
<p>一种部分的解决方法是加入一些标志位来标识是这个packet是复制还是原始数据,但还是有一些问题,例如这样假设了网络传输的数据不是复制的,还有无法解决长延迟的问题(假设有k个标志位,最多记录第2^k^次重发,如果有超过2^k^次timeout的延迟,就还是会出现无法区分重发和新包的问题)</p>
<p>当然通过动态调节timeout和把ACK做成一个够长的标志(比如下面的序列号)是可以做的,比如下文的滑动窗口就是stop &amp; wait的泛化,</p>
<blockquote>
<p>linux 下这个timeout被动态地(通过测量发出到ACK的时间采样等方法)调节为略大于传输时间,为了处理网络的波动性,如果发现一个包重传之后还是丢,就把timeout设置为原来的2倍</p>
</blockquote>
<p>对于重复的更优处理还会有SACK字段(选择性确认),receiver回传数据表明哪里是复制了,sender知道之后就继续发送了</p>
<p>更大的问题在于速度,假设两地有50ms延迟,来回100ms, 一个包比如1.5KB, 这样的网络最大只能有15KB的速率！</p>
<ul>
<li>sliding window</li>
</ul>
<p>允许多个未确认的片段 (multiple un-acked segments)</p>
<p>将一些绑起来的片段叫做window,始终保持管道速率拉满</p>
<p>什么意思？原先只能有1个包在路上,现在可以有n个</p>
<p>Sender</p>
<p>每个片段都有一个序列号(SeqNo)</p>
<p>维护三个变量<!-- -->:Send<!-- --> window size(SWS),Last ack received(LAR), Last seg sent(LSS)</p>
<p>维持的要求<!-- -->:LSS-LAR<!-- --> &lt;= SWS, 保证中间飞的包 &lt;= SWS 个 (一个SWS大小的buffer</p>
<p>Receiver</p>
<p>还是维护三个变量<!-- -->:RWS<!-- -->, last acceptable seg(LAS), last seg received (LSR)</p>
<p>要求 LAS - LSR &lt;= RWS, 也就是说如果窗口是5, 上一个接受的是3, 不会接受9以后的SeqNo的包,并且 LAS &lt;= LSE + RWS都接受,也就是说9之前的都是可以的,比如2,会接受并回一个ACK = 下一个字节</p>
<p>也就是说 第一个包假如是 0-999字节 ACK 就是1000</p>
<p>下文中 ack 忽略掉这个值区别 包1,ACK1只表示逻辑上的第一个包和第一个ACK</p>
<p>(逻辑上下一个包,例如发送1,2丢,345,回的ACK是1 222)</p>
<p>如何知道包丢了</p>
<p>目前的方法就是等超时,例如2丢了一直等ACK 3,到timeout了重发2</p>
<p>有没有更好的方法呢？比如我在发12345,2丢了,回ACK1 222, 连续3个2表明确实是2丢了,那就可以不用等超时立刻触发重传(TCP快速重传)</p>
<p>那如果ACK丢了呢？</p>
<p>如果是前面的ACK丢了无所谓,最后一个ACK就表明这个之前的所有都已经接受,不然就重发呗</p>
<p>重传多少？</p>
<ul>
<li>Go-back-N 一个包loss,整个window重传 对网络情况悲观</li>
<li>Selective repeat 只发loss的 对网络情况乐观</li>
</ul>
<p>看实际情况,不一定哪个快,这是一个trade-off</p>
<p>RWS &lt;= SWS</p>
<p>所以这里面的</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/06/sNe1a4CtuPxMKB2.png" alt="image-20240906195851377" class="img_ev3q"></p>
<p>window size就是滑动窗口的大小,Seq 和 ACK Seq就是上文所述的序列号</p>
<p>一个发送第4000-4999字节的包,seqNo会是4000, Ack会是4999+1=5000=下一个包应该的seqNo</p>
<p>RSVD: reserved</p>
<p>Hlen,也叫offset,表明data段从哪里开始</p>
<p>Flags<!-- -->:ACK<!-- -->表示ACK 是否有效(第一个发出包的ack就无意义,其他都有意义), SYN/FIN 位掌管TCP连接(第一个包, ack not set,syn set)</p>
<p>所以后面传回的就是syn/ack ,从第二个包开始就结束了syn且有合法ack,就是ack</p>
<p>RST: reset the connection</p>
<p>TCP Setup/Teardown</p>
<p>Setup</p>
<p>需要注意的是,seqNo通常不从0开始(安全原因),所以第一次握手</p>
<p>active 带上 {SYN, S<del>A</del>} (A means active) 我的序列开始是S<del>a</del></p>
<p>passive 回复{SYN, S<del>P</del>, ACK, S<del>a+1</del>} (P means passive) 表明我的序列开始是S<del>p</del></p>
<p>active 回复 {S<del>a+1</del>, ACK, S<del>P+1</del>}</p>
<p>以上为 0字节 data</p>
<p>Teardown</p>
<p>使用FIN bit</p>
<p>A-&gt;B FIN,seq S<del>a</del>, ack S<del>b</del></p>
<p>B-&gt;A ack S<del>a+1</del></p>
<p>B-&gt;A FIN, seq S<del>b</del>, ack S<del>a+1</del></p>
<p>A-&gt;B ack S<del>b+1</del></p>
<p>cleaning up safely</p>
<p>如果teardown的部分(final ack)丢包怎么办？-&gt; 不管丢不丢,在发出FIN之后,active 都会到TIME_WAIT状态,大约会keep socket twice the maxium segment lifetime,之后关掉并重置</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-3-packet-switching">Unit 3: Packet Switching<a class="hash-link" aria-label="Direct link to Unit 3: Packet Switching" title="Direct link to Unit 3: Packet Switching" href="/blog/cs144/cs144 lec notes#unit-3-packet-switching">​</a></h2>
<p>Circuit Switching 电话</p>
<p>Problems</p>
<ul>
<li>Inefficient (for brusty req)</li>
<li>Diverse Rates</li>
<li>State Management</li>
</ul>
<p>Packet Switching</p>
<ul>
<li>
<p>通过路由表独立路由</p>
</li>
<li>
<p>所有的包共享相同的最大连接速率(router需要大buffer来收包)</p>
</li>
<li>
<p>router无连接状态</p>
</li>
</ul>
<p>好处:</p>
<ol>
<li>efficient use of expensive links 共享速率使router不闲置</li>
<li>resilience to failure of links &amp; routers, no state -&gt; 轻松切换线路</li>
</ol>
<p>Delays</p>
<p>Propagation Delay <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>l</mi></msub><mo>=</mo><mfrac><mi>l</mi><mi>c</mi></mfrac></mrow><annotation encoding="application/x-tex">t_l=\frac{l}{c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 距离 l / 光速c</p>
<p>Packetization Delay <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>p</mi></msub><mo>=</mo><mfrac><mi>p</mi><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">t_p=\frac{p}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0925em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.4461em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 包长度p / 每秒能放到连接上的bit数r</p>
<p>Queueing Delay 在路由器的buffer queue之中排队等待发射时间</p>
<p>End-to-end delay 对所有经过的router r<del>i</del>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo stretchy="false">(</mo><mfrac><mi>p</mi><msub><mi>r</mi><mi>i</mi></msub></mfrac><mo>+</mo><mfrac><msub><mi>l</mi><mi>i</mi></msub><mi>c</mi></mfrac><mo>+</mo><msub><mi>Q</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=\sum_i (\frac{p}{r_i}+\frac{l_i}{c} + Q_i(t))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.1951em;vertical-align:-0.4451em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.4461em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.2412em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.4101em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">))</span></span></span></span></p>
<p>前两个是固定的,queueing delay是随机的,导致了端到端时间具有一定的波动性</p>
<p>Real-Time Apps 为了避免queueing delay带来的体验下降,会引入</p>
<p>Playback buffers 视频缓冲区</p>
<p>playback buffer -&gt; video decoder -&gt; screen</p>
<p>也不是固定值,会增大buffer来尽量不要停</p>
<p>queue model: FIFO</p>
<p>需要注意的是字节数随时间的变化是分段的(包一个个来),近似可以认为每一段是直线</p>
<p><strong>Small packet help reduce end-to-end delay</strong></p>
<p>小包的情况下 各个中间router的Queue delay + Packetization delay可以并行,如图,类似cpu流水线, 关键是一个包是最小传输单位</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/07/WqRdP1ebG42tUzB.png" alt="image-20240907163508951" class="img_ev3q"></p>
<p>Statistical Multiplexing Gain</p>
<p>由于从一个link输入的packet的速率A具有波动性和随机性,设要使他不丢包需要R的输出速率</p>
<p>假设有另一个link 输入B, 也需要R,同时接受AB的路由器需要的输出速率R&#x27; &lt; 2R, 因为AB的最大值时间点大概率不重叠</p>
<p>让我们在处理多路流量的时候反而更高效</p>
<p>Queues With Random Arrival Processes</p>
<ul>
<li>
<p>Burstiness increase delay -&gt; 包不重叠,平均delay低</p>
</li>
<li>
<p>Determinism minimizes delay -&gt; 如果queue为空,就无法利用输出,不确定的到来时间加剧拥挤</p>
</li>
<li>
<p>Little&#x27;s Result 平均到达率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span></span></span></span> 平均排队者数量L,平均排队延迟d, L = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∗</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">\lambda * d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span></p>
</li>
<li>
<p>M/M/1 queue</p>
</li>
</ul>
<p>将收包事件近似为泊松过程,相互独立且t时间内到达的包数n, E(n)=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal">t</span></span></span></span></p>
<p>(注意网络<strong>包</strong>实际很突发,不是泊松过程,但这个model work for new <strong>flows</strong>, 新连接是近似泊松的)</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/07/M4icDXqmZLtk7uG.png" alt="image-20240907171142326" class="img_ev3q"></p>
<p>当入包速率接近出包速率时,等待时间会大幅度上涨</p>
<p>平均排队者数量就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∗</mo><mi>d</mi><mo>=</mo><mfrac><mi>λ</mi><mrow><mi>μ</mi><mo>−</mo><mi>λ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda * d = \frac{\lambda}{\mu - \lambda}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.3612em;vertical-align:-0.4811em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">λ</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">λ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>packet switch 交换机</p>
<p>一个包来之后 -&gt; 查地址 -&gt; 更新header -&gt; 进入排队 -&gt; 发送</p>
<p>Internet router</p>
<p>1, 如果DA 不等于自己,丢</p>
<p>2, 检查ip version和datagram长度</p>
<p>3, 减少TTL, 更新校验和</p>
<p>4, TTL == 0?</p>
<p>5, 查路由表, IP DA决定下一跳, 找到对应的Ethernet DA, 发送到电线</p>
<p>IP match -&gt; binary TRIE 或者 三进制可寻址内存-&gt; 01X暴力并行比较,很快</p>
<p>Ethernet match -&gt; hash</p>
<p>Input Queued Packet Switch</p>
<p>一个有 N 个输入口的交换机,每发送一个packet耗时R,最坏情况下的输出delay是(N+1) * R (假设输出速率足够大)</p>
<p>如果把排队放在输入,最坏情况下delay,理想状态下可以降低到2R</p>
<p>但问题是,如果马上要输出的几个包是同一个输出口,一个输出口同时只能输出一个,就和原来的没有区别了</p>
<p>一种解决方法是Virtual Output Queues,在每个输入口都做M个队列,M是输出口的数量,每次输出都从M个不同的输出口取</p>
<p>举了一个有趣的例子是红绿灯车道,车在进入路口前(“输入口”)分好队列,同时输出的就可以增加,排队时间就可以减少,但要求的道路宽度变多</p>
<p>FIFO的问题和其他选项</p>
<p>经典排队问题,如果有一个大包堵着,所有包的排队时间都会增加</p>
<p>strict priority</p>
<p>很符合直觉,同一个输入口再来几个队列,并分好优先级,同一个端口接受多个队列输入的时候总是优先取高优先级的包</p>
<p>也是经典问题:饿死,但问题不像sys那样严重,饿死就饿死了(),广泛应用</p>
<p>或者weight priority,解决饿死问题</p>
<p>取每个队列的概率 p =  w<del>i</del> / sum(w<del>i</del>) (用Round方法)</p>
<p>考虑到每个包的大小不一样,理论上概率应该应用到字节上而不是包上,但又不能拆开包发送,怎么做呢？</p>
<p>WFQ, 利用我们在知道包大小这个事实</p>
<p>在每个队列计数(virtual_time),权重为w的队列在发送一个size大小的包后,self.vt += size / w, 之后把self.vt push进最小堆</p>
<p>调度下一个包时从最小堆里pop()就行</p>
<p>rate guarantees (Guaranteed Delay)</p>
<p>RSVP  RFC2205</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/07/eOjCAPm8Wfdv6Lz.png" alt="image-20240907230305637" class="img_ev3q"></p>
<p>给出连接总耗时10ms上界, 传输时间 路程/c = 5ms, 打包时间=每个包的字节数/数据线最大速度 = 0.48ms</p>
<p>剩下最多4.52ms的排队延迟, 分在3个router, 要保证不丢包, 就需要至少 15 Mb * 4.52 / 3ms = 24000bit = 3KB的 buffer</p>
<p>buffer的设计在 “给定一定最大延迟的情况下,不允许丢包”</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-4-congestion-control">Unit 4: Congestion Control<a class="hash-link" aria-label="Direct link to Unit 4: Congestion Control" title="Direct link to Unit 4: Congestion Control" href="/blog/cs144/cs144 lec notes#unit-4-congestion-control">​</a></h2>
<p>堵塞控制</p>
<p>tcp堵塞控制</p>
<p>堵塞是不可避免的</p>
<p>堵塞带来丢包,由于重传等,会带来更多的数据流量,进一步加深堵塞</p>
<p>max-min fair: 不能通过减少另一个流的速率的方法增加其中一个流的速率时</p>
<p>先前的想法</p>
<ul>
<li>简单的在各个可能的router上平均分配流量 问题在于没有任何反馈机制</li>
<li>network-based 显式反馈ECN,当router堵塞发生的时候,给数据源发送包指示拥堵</li>
<li>end-host-based 通过在发送端观察网络的行为(发送的请求是否超时？是否丢包？)调整发送速度</li>
</ul>
<p>实际的TCP采用end-host based</p>
<blockquote>
<p>TCP varies the number of oudstanding packets in the network bt varying window size:</p>
</blockquote>
<blockquote>
<p>Window size = min{Advertised Window(given by receiver), Congestion Window}</p>
</blockquote>
<p>AIMD(Additive Increase Multiplicative Decrease)</p>
<p>If a packet receive OK : W &lt;- W + 1/W</p>
<p>If a packet is dropped(at Window size W): W &lt;- W/2</p>
<p>称为tcp锯齿或者AIMD锯齿</p>
<p>需要注意的是,实际上在加的中间过程中,网络速率就已经拉满了,后面再加实际上是在嗅探router的缓冲区大小</p>
<p>single flow AIMD</p>
<p>前期 router buffer空</p>
<p>RTT = constant</p>
<p>吞吐量T=W=dN/dt</p>
<p>dW/dN = 1/W , dW/dt = T/W = const</p>
<p>W,T 正比于t</p>
<p>当W大于输出速率R(常数), router buffer开始积累</p>
<p>dW / dt = R/W ⇒ W = sqrt (Rt+C)</p>
<p>此时吞吐量为R,RTT=k* buffersize+D</p>
<p>趋势上和W相同(但不完全一样,因为T输入=R+buffersize变化率=W/RTT),可以得到buffer size 随时间变化</p>
<p>multi flows AIMD</p>
<p>在多道数据流的情况下,之前的AIMD不是很适用</p>
<p>问题在于减少的时机不是所有流同步的,部分流减少后buffer又不满,其他流就不减少,总体发生丢包的时间就很分散随机,导致宏观上router的buffer一直趋于满的</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-32da757defb74ac35a9754fe4a50b5e5.png" width="1516" height="842" class="img_ev3q"></p>
<p>多流时 吞吐量T也不再等于(忽略常数)窗口大小W(多个流的平均)</p>
<p>(buffer始终趋于满的)</p>
<p>总吞吐量近似恒等于R</p>
<p>RTT也近似为常数</p>
<p>那么对于每一个流,都是W/2 → W → W/2的流程</p>
<p>又由于buffer是满的,RTT恒定,dW/dt = T/W = 1/ RTT = const ,直线</p>
<p>平均吞吐 T‘ = 3/4 Wmax/RTT</p>
<p>一次丢包前发送的包数A = 3/8 Wmax^2 ,则丢包率p=1/A</p>
<p>则T’ =  sqrt(3/2) * 1/RTT*sqrt(p)</p>
<p>考虑到每个包  字节数不同,再乘一个平均字节数MSS</p>
<p>T’ = sqrt(3/2) * MSS/RTT*sqrt(p)</p>
<p>也就是说,AIMD对两个量敏感: RTT(服务器有多远,router 排队时间多大)和 丢包率p</p>
<p>TCP堵塞控制</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-2-d7eb290cae52e8854c2f85d75d5cb1fe.png" width="1116" height="588" class="img_ev3q"></p>
<p>早期TCP(没有堵塞控制)的问题在于,端的速率超过router的速率太多,receiver返回的windows size实际上远远超过了网络实际能容纳的大小,不断丢包重传</p>
<p>TCP Tahoe: 加上congestion window, timeout estimation和self-clocking</p>
<p>congestion window中的二阶段congestion control</p>
<ul>
<li>Slow start:在连接建立或者发生丢包时,AIMD前面线性增加疑似有点太慢了,加速一下</li>
<li>Congestion avoidance: AIMD</li>
</ul>
<p>Slow Start</p>
<p>Window starts at Maximum Segment Size MSS</p>
<p>Increase window by MSS for each ACK packet</p>
<p>dW/dt = dN/dt  = W ⇒ W = exp(t)</p>
<p>指数增加试探吞吐上限</p>
<p>Congestion avoidance</p>
<ul>
<li>Increase by MSS^2/congestion window for each ACK</li>
<li>Behavior: increase by MSS each RTT</li>
<li>Linear increase</li>
</ul>
<p>在两种状态间切换使用3个信号作为信息:</p>
<ul>
<li>Inc ACK: 传输良好</li>
<li>Dup ACK: 发生丢包/延迟</li>
<li>Timeout: 网络崩溃</li>
</ul>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-1-69740e62c650931acd4f6ff27629b3ef.png" width="1267" height="664" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-3-7feabdfe1045c56bbd9f88e2df886fd1.png" width="1220" height="763" class="img_ev3q"></p>
<p>Timeout Estimation</p>
<p>太小,会频繁超时,回到slow start,影响速度</p>
<p>太长,会频繁重发,影响速度</p>
<p>挑战在于RTT是高度动态且负载相关的</p>
<p>早期的算法</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-4-49c05d0fb333ed25b8817262cbb3a8d9.png" width="1002" height="639" class="img_ev3q"></p>
<p>问题在于假设了RTT的方差不是很大,但这是不对的</p>
<p>大方差下的RTT会频繁带来过小或者过大的问题</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-5-2b31e0ccaf62ab7dd7c40e809e70347a.png" width="1257" height="694" class="img_ev3q"></p>
<p>将方差纳入考虑,实验效果好</p>
<p>self-clocking</p>
<p>应该叫一个原则/实现方式,体现为TCP的堵塞窗口不由外部时钟决定,而是根据收到的ACK频率自动改变发送速率(即前面的slow start和AIMD)</p>
<p>TCP Reno</p>
<ul>
<li>3-Dup ACK不再返回到1,返回1/2 * Wmax (fast recovery)</li>
<li>当3-Dup的时候立刻重传</li>
</ul>
<p>(不等待重传计时器超时, 并且立刻增大堵塞窗口1/2 * ssthreld + 3,也就是把这个Dup的包立刻加到这一次重传之中,混入正常的发送流,不等待几次RTT扩大window size)
<img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-6-ada3c5a068a59d00e6ac13dff9294a81.png" width="1483" height="801" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-5-nat-application">Unit 5: NAT Application<a class="hash-link" aria-label="Direct link to Unit 5: NAT Application" title="Direct link to Unit 5: NAT Application" href="/blog/cs144/cs144 lec notes#unit-5-nat-application">​</a></h2>
<p>DNS, HTTP, BitTorrent</p>
<p>NAT 当内部接口收包时,改写源地址为NAT的外部接口地址</p>
<p>例如家庭wifi 多设备连接实际上共享相同的IP</p>
<p>NAT 原则上是一个map</p>
<p>看看自己的public IP <a href="https://whatismyipaddress.com/" target="_blank" rel="noopener noreferrer">https://whatismyipaddress.com/</a></p>
<p>还有个内网IP的常识</p>
<blockquote>
<p>私有IP地址是在互联网上不被路由的IP地址,专为内部网络使用。私有IP地址范围包括以下几个段:</p>
<ol>
<li><strong>10.0.0.0 - 10.255.255.255</strong>:这个范围内的IP地址被划分为一个单独的A类网络,通常用于大型企业或组织的内部网络。</li>
<li><strong>172.16.0.0 - 172.31.255.255</strong>:这个范围内的IP地址是14个连续的B类网络,常用于中等规模的组织。</li>
<li><strong>192.168.0.0 - 192.168.255.255</strong>:这个范围内的IP地址是256个连续的C类网络,通常用于家庭或小型企业网络。</li>
</ol>
</blockquote>
<p>NAT 分类</p>
<ul>
<li>Full Cone NAT</li>
<li>Restricted Cone NAT</li>
<li>Port Restricted Cone NAT</li>
<li>Symmetric NAT</li>
</ul>
<p>区别在于Full Cone NAT只是一个map,不做安全检查</p>
<p>允许不是Dst IP的主机通过NAT的外部接口给内部接口发包,允许外部主动连接内部</p>
<p>Restricted Cone只允许Dst IP的主机发包,同时必须内部先连接外部</p>
<p>Port 就是不仅要求IP相同,还要求端口号也相同</p>
<p>Symmetric 的不同点在内部,在Port的基础上,如果内部一个{IP,port}尝试连接两个不同的外部{IP,port}, NAT会给这个内部的分配两个不同的{IP, port},然后和外部一对一链接</p>
<p>如果不符合要求,有的不翻译,有的会返回一个ICMP错误</p>
<p>Symmetric有一些问题</p>
<p>例如有游戏的多人在线服务器把不同的游戏内地图服务放在不同的端口/IP上来分流,当同时需要两种服务的时候,建立了两个连接,server没有办法知道这两个连接都是同一个东西发出来的(端口不一样)</p>
<p>static mapping</p>
<p>NAT hairmapping NAT回流</p>
<p>例如,在内网中有一台服务器S,其通过NAT暴露给外面的DNS,内网有一个客户端C想要访问S,如果使用DNS的话,得到的是S暴露给外面的NAT IP。这个时候,走外面还是走里面？</p>
<p>NAT hairmapping有多种可能的配置,一种让内部访问走外部,牺牲性能换取对内安全性,一种是主动识别内部到外部的请求,并把它放在内部解决不走NAT</p>
<p>这个例子里面更严重的问题在于如果想要走里面,B向外部IP发送包,却 从内部IP接受包,IP不同根本不会接受</p>
<p>NAT带来的问题</p>
<p>例如B想要与NAT后面的A通信,但mapping里面没有,不能主动连,也不会用A的NAT加B的mapping</p>
<p>Connection Reversal, <img decoding="async" loading="lazy" src="https://www.researchgate.net/profile/Bryan-Ford/publication/1959162/figure/fig3/AS:669491117711375@1536630529609/NAT-Traversal-by-Connection-Reversal.png" alt="NAT Traversal by Connection Reversal" class="img_ev3q"></p>
<p>公网B-&gt;中转R-&gt;请求内网A,A-&gt;B连接,因为这个请求是反向的(B想要连A,但实际上变成A连B),所以叫Connection Reversal</p>
<p>Relay 中继,A、B都在内网,通过中继R做转发</p>
<p>要求加密(除非信任R),且消耗服务器性能</p>
<p><img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img6.png" alt="" class="img_ev3q"></p>
<p>NAT Hole-Punching NAT打洞(一般用于UDP)</p>
<p>两个Client都在NAT后面,参考这篇文章<a href="https://mthli.xyz/p2p-hole-punching/" target="_blank" rel="noopener noreferrer">https://mthli.xyz/p2p-hole-punching/</a></p>
<p>主要步骤<!-- -->:ClientA<!-- -->,B给中间公网服务器S注册自己的内网地址,并通过获取对方的公网IP、内网IP, 之后A向着B发请求打通A的NAT(加上B的公网IP的mapping),B向A发请求打通B的NAT(加上A的NAT的公网IP的mapping),之后AB就可以正常通话了(隧道打通)</p>
<p><img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img8.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img9.png" alt="" class="img_ev3q"></p>
<p>如果NAT不一样深,有多层深呢？</p>
<p>AB在发送自己信息,得到对方信息的时候需要把一路上每一级NAT的公网IP带出,而在打洞的时候需要从外到内一级级打(由于缺乏拓扑信息,往往不是最优,也可能会超时)</p>
<p>注意</p>
<blockquote>
<p>Since <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img3.png" alt="A" class="img_ev3q"> and <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img4.png" alt="B" class="img_ev3q"> are on different private networks and their respective private IP addresses are not globally routable, the messages sent to these endpoints will reach either the wrong host or no host at all. <strong>Because many NATs also act as DHCP servers, handing out IP addresses in a fairly deterministic way from a private address pool usually determined by the NAT vendor by default, it is quite likely in practice that <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img3.png" alt="A" class="img_ev3q">&#x27;s messages directed at <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img4.png" alt="B" class="img_ev3q">&#x27;s private endpoint will reach <em>some</em> (incorrect) host on <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img3.png" alt="A" class="img_ev3q">&#x27;s private network that happens to have the same private IP address as <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img4.png" alt="B" class="img_ev3q"> does.</strong> <strong>Applications must therefore authenticate all messages in some way to filter out such stray traffic robustly. The messages might include application-specific names or cryptographic tokens, for example, or at least a random nonce pre-arranged through <img decoding="async" loading="lazy" src="https://bford.info/pub/net/p2pnat/img5.png" alt="S" class="img_ev3q">.</strong></p>
</blockquote>
<blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-hole-punching-tcp打孔">TCP Hole Punching TCP打孔<a class="hash-link" aria-label="Direct link to TCP Hole Punching TCP打孔" title="Direct link to TCP Hole Punching TCP打孔" href="/blog/cs144/cs144 lec notes#tcp-hole-punching-tcp打孔">​</a></h4>
<p>Establishing peer-to-peer TCP connections between hosts behind NATs is slightly more complex than for UDP, but TCP hole punching is remarkably similar at the protocol level. Since it is not as well-understood, it is currently supported by fewer existing NATs. When the NATs involved <em>do</em> support it, however, TCP hole punching is just as fast and reliable as UDP hole punching. Peer-to-peer TCP communication across well-behaved NATs may in fact be <em>more</em> robust than UDP communication, because unlike UDP, the TCP protocol&#x27;s state machine gives NATs on the path a standard way to determine the precise lifetime of a particular TCP session.
在 NAT 后面的主机之间建立点对点 TCP 连接比 UDP 稍微复杂一些,但 TCP 打洞在协议级别非常相似。由于它还没有被很好地理解,目前支持它的现有 NAT 较少。然而,当涉及的 NAT<em>支持</em>时,TCP 打洞与 UDP 打洞一样快速且可靠。事实上,跨行为良好的 NAT 的点对点 TCP 通信可能比 UDP 通信<em>更</em>稳健,因为与 UDP 不同,TCP 协议的状态机为路径上的 NAT 提供了一种标准方法来确定特定 TCP 会话的精确生命周期。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sockets-and-tcp-port-reuse-套接字和-tcp-端口重用">Sockets and TCP Port Reuse 套接字和 TCP 端口重用<a class="hash-link" aria-label="Direct link to Sockets and TCP Port Reuse 套接字和 TCP 端口重用" title="Direct link to Sockets and TCP Port Reuse 套接字和 TCP 端口重用" href="/blog/cs144/cs144 lec notes#sockets-and-tcp-port-reuse-套接字和-tcp-端口重用">​</a></h4>
<p>The main practical challenge to applications wishing to implement TCP hole punching is not a protocol issue but an application programming interface (API) issue. Because the standard Berkeley sockets API was designed around the client/server paradigm, the API allows a TCP stream socket to be used to initiate an outgoing connection via <code>connect()</code>, or to listen for incoming connections via <code>listen()</code> and <code>accept()</code>, <em>but not both</em>. Further, TCP sockets usually have a one-to-one correspondence to TCP port numbers on the local host: after the application binds one socket to a particular local TCP port, attempts to bind a second socket to the same TCP port fail.
对于希望实现 TCP 打洞的应用程序来说,主要的实际挑战不是协议问题,而是应用程序编程接口 (API) 问题。由于标准 Berkeley 套接字 API 是围绕客户端/服务器范例设计的,因此该 API 允许使用 TCP 流套接字通过以下方式发起传出连接: <code>connect()</code> ,或者通过以下方式侦听传入连接 <code>listen()</code> 和 <code>accept()</code> ,<em>但不能两者兼而有之</em>。此外,TCP 套接字通常与本地主机上的 TCP 端口号一一对应:应用程序将一个套接字绑定到特定本地 TCP 端口后,尝试将第二个套接字绑定到同一 TCP 端口会失败。</p>
<p>For TCP hole punching to work, however, we need to use a single local TCP port to listen for incoming TCP connections and to initiate multiple outgoing TCP connections concurrently. Fortunately, all major operating systems support a special TCP socket option, commonly named <code>SO_REUSEADDR</code>, which allows the application to bind multiple sockets to the same local endpoint as long as this option is set on all of the sockets involved. BSD systems have introduced a <code>SO_REUSEPORT</code> option that controls port reuse separately from address reuse; on such systems <em>both</em> of these options must be set.
然而,为了让 TCP 打洞发挥作用,我们需要使用单个本地 TCP 端口来侦听传入 TCP 连接并同时启动多个传出 TCP 连接。幸运的是,所有主要操作系统都支持特殊的 TCP 套接字选项,通常称为<code>SO_REUSEADDR</code> ,只要在所有涉及的套接字上设置此选项,它就允许应用程序将多个套接字绑定到同一本地端点。 BSD系统引入了<code>SO_REUSEPORT</code>选项,可以与地址重用分开控制端口重用；在此类系统上,必须设置这<em>两个</em>选项。</p>
</blockquote>
<p>更多细节可以看 <a href="https://bford.info/pub/net/p2pnat/" target="_blank" rel="noopener noreferrer">https://bford.info/pub/net/p2pnat/</a></p>
<p>由于S和A是两个外部节点,所以S试探出的ip, port要能用,还要求B的NAT不是symmetric的,A也一样</p>
<p>教授还提出了个很幽默的问题是</p>
<p>要求NAT支持打洞(甚至其他那些高级措施)是违背p2p的,需要NAT的支持,NAT原则上不会为不流行的新协议提供打洞支持(需要NAT起码知道哪里是IP,哪里是port,etc),而在现在广泛使用NAT的情况下,不支持穿过NAT的协议难以流行起来,死循环了</p>
<p>NAT Debate:</p>
<p>Pros:安全性,地址重用</p>
<p>Cons:不是p2p依赖大规模的硬件支持,统一规范的困难,添加新行为的困难,应用程序编写增加的困难</p>
<p>NAT Operations</p>
<p>RFC 4787 UDP</p>
<ul>
<li>A NAT MUST have an &quot;Endpoint-Independent Mapping&quot; behavior(mapping和外部端口无关,禁止symmetric NAT)</li>
<li>......</li>
</ul>
<p>RFC 5382 TCP</p>
<ul>
<li>一样,禁止symmetric NAT</li>
<li>必须允许同时的开启TCP连接(A打洞连接B的public IP,SYN;然后B连接A的public IP,SYN。此时需要能连接,打洞完成,NAT必须允许且正确处理A SYN, B SYN这种TCP State)(NAT不限制任何遍历TCP状态图的连接实现方式)</li>
<li>收到没有map的TCP SYN时必须至少保留6s才可以发送ICMP响应 (如果一个在范围外的打洞用TCP SYN传入,然后给他拒了,自己这边尝试打对面的时候可能会因为对面TCP连接关闭删了这个mapping打洞失败)</li>
<li>......</li>
</ul>
<p>HTTP:</p>
<p>REQ/RES API</p>
<p>text protocal, document-centric</p>
<p>HTTP Req Format:</p>
<hr>
<p>method | URL | version</p>
<p>header field name | value</p>
<p>...</p>
<p>header field name | value</p>
<p>blank line</p>
<p>body</p>
<hr>
<p>HTTP/1.0</p>
<ul>
<li>Open connection</li>
<li>Issue GET</li>
<li>Server closes connection after response</li>
</ul>
<p>HTTP/1.0 Speed</p>
<p>Latency 50ms</p>
<p>Req size:1 seg, Res 2 seg</p>
<p>Seg packetization delay: 10ms, full duplex(全双工,收发互不影响)</p>
<p>Maximum open connections: 2</p>
<p>window足够大</p>
<p>Case 1: Single Page</p>
<p>SYN: 50 + SYN/ACK 50 + ACK/req 60 + res/70 = 230ms</p>
<p>Case 2: page loads 2 images</p>
<p>step1(page): Setup 100ms, req/res 130ms</p>
<p>step2(images): Setup 100ms,produce 2 response, 100 + 60 + 2*20+50 = 250ms</p>
<p>总共250 + 100 + 130 = 480ms</p>
<p>TCP连接占了很大的开销,HTTP无状态影响TCP服用</p>
<p>HTTP/1.1 Keep-Alive</p>
<p>1.0 的问题</p>
<ul>
<li>多连接每次都要Setup太慢了</li>
<li>很多的传输大小都很小,TCP 的window size难以变大(Slow Start &amp; AIMD)</li>
</ul>
<p>HTTP/1.1</p>
<ul>
<li>
<p>Added Connection header for req</p>
<ul>
<li>keep-alive: 告诉server不要关闭这个connection</li>
<li>close: 告诉server关闭</li>
<li>Server can always ignore</li>
</ul>
</li>
<li>
<p>Added Connection header for res</p>
<ul>
<li>keep-alive: 告诉client不会关闭这个connection</li>
<li>close: 告诉client会关闭</li>
</ul>
</li>
<li>
<p>Added Keep-Alive header for res</p>
<ul>
<li>告诉client connection可能被维持打开多久</li>
</ul>
</li>
</ul>
<p>SPDY</p>
<ul>
<li>req pipelining</li>
<li>remove redundant headers</li>
<li>Becoming basis of HTTP/2.0</li>
</ul>
<p>BitTorrent</p>
<p>他讲的太快了</p>
<p>bt种子原理还可以参考</p>
<p><a href="https://jaminzhang.github.io/p2p/BitTorrent-Principle-Introduction/" target="_blank" rel="noopener noreferrer">https://jaminzhang.github.io/p2p/BitTorrent-Principle-Introduction/</a></p>
<p><a href="https://www.cnblogs.com/HMingR/p/13703917.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/HMingR/p/13703917.html</a></p>
<p><a href="https://www.zhihu.com/question/49829233/answer/160765176" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/49829233/answer/160765176</a></p>
<p><a href="https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)</a></p>
<p>DNS</p>
<p>原理细节(层次系统)直接看b站或者小林就行,没什么新东西</p>
<p>设计时 DNS应该是</p>
<ul>
<li>读远远多于写</li>
<li>弱一致性要求</li>
<li>可较长期缓存</li>
<li>单点故障不影响整个系统工作</li>
</ul>
<p>分布式,多DNS server -&gt; 强大的DDoS抗性</p>
<p>DNS cache poisoning 篡改DNS resolver里面的cache指向恶意网站</p>
<p>DNS info -&gt; Resource Records (RR)</p>
<p>name [TTL] [class] [type] rdata</p>
<ul>
<li>name: domain name</li>
<li>TTL: time to live (in seconds)</li>
<li>class: for extensibility, usually IN 1(Internet)</li>
<li>type: type, two critical: A(Ipv4 address) and (NS name server)</li>
<li>rdata: data depends on type</li>
</ul>
<p>DNS Message</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/13/1zgXxURw2JEaHhO.png" alt="image-20240913220108331" class="img_ev3q"></p>
<p>dns name compression</p>
<p>整个DNS包 &lt; 512字节</p>
<p>Other Kinds of Records</p>
<p>CNAME: to create an alias DNS name</p>
<p>SOA: start of authority</p>
<p>TXT: some text(for extension)</p>
<p>PTR: map address to name</p>
<p>AAAA: Ipv6</p>
<p>DHCP</p>
<p>与IP通信至少需要:</p>
<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>网关 Gateway router, 传出去的第一跳</li>
<li>[optional] DNS</li>
</ul>
<p>问题:从一个新电脑,如何得到这些值？</p>
<p>曾经:手工配置</p>
<p>现在<!-- -->:DHCP<!-- -->协议,Dynamic Host Configuration Protocal</p>
<p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP.html" target="_blank" rel="noopener noreferrer">https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP.html</a></p>
<p>常见的DHCP服务器:路由器/光猫</p>
<p>课程讲得远不如动画清楚</p>
<p><a href="https://www.bilibili.com/video/BV1Gd4y1n7Xz/?share_source=copy_web&amp;vd_source=60f8c73d5ef551168e0bbb088ac46073" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Gd4y1n7Xz/?share_source=copy_web&amp;vd_source=60f8c73d5ef551168e0bbb088ac46073</a></p>
<p>虚拟机的网络模式:</p>
<ul>
<li>
<p>网络地址转换NAT, 理解为为每一个虚拟机虚拟了一个DHCP服务器作为一个<strong>只出不进</strong>的NAT,给虚拟机分配了虚拟设备MAC, 虚拟机内连接外部ok(宿主机会作为NAT进行转发), host连接虚拟机不行(NAT外公网连内网), 虚拟机之间不能互连(有自己独立的DHCP)(不考虑端口转发等)</p>
</li>
<li>
<p>NAT网络,在虚拟机前加一台虚拟交换机,交换机连接宿主机,DHCP地址、网关地址不再一样,这样虚拟机可以连接虚拟机,其他同上</p>
</li>
<li>
<p>桥接(网卡),把虚拟机放在宿主机的局域网里面,也作为一个“独立设备”去连接宿主机器连接的DHCP server,消耗宿主所在局域网的IP地址,此时全部可以连</p>
</li>
<li>
<p>内部网络:可以互相ping, 不能ping宿主和外部网络,一个隔离的内部网络</p>
</li>
<li>
<p>Host-only(仅主机):虚拟机和宿主构成的内部网络,虚拟机不能连外部互联网和被连,比如docker采用host-only多</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-6-routing">Unit 6: Routing<a class="hash-link" aria-label="Direct link to Unit 6: Routing" title="Direct link to Unit 6: Routing" href="/blog/cs144/cs144 lec notes#unit-6-routing">​</a></h2>
<p>Approaches</p>
<ul>
<li>Flooding 在每个节点广播,效率低,但能保证可达性,仅在对网络拓扑一无所知时考虑</li>
<li>Source routing 另一个极端,端点完全知道内部的拓扑,进而直接指定一条路</li>
<li>Forwarding table 核心在于如何填充这些转发表</li>
<li>Spanning tree 一种填充转发表的方法,可以是距离的最小生成树,跳数的最小生成树,延迟的最小生成树......</li>
</ul>
<p>实际上采用的路由算法也称路由协议</p>
<p>Metrics</p>
<p>Shortest path spanning trees</p>
<p>Other types of routing</p>
<ul>
<li>Multipath 最小生成树的问题在于有些节点的的度会很高,吞吐压力很大,将不同的包分配到不同路径上均匀负载</li>
<li>Multicast 多个目标优化的情况,例如,广播,想要以尽可能少的传输代价发送到大量主机</li>
</ul>
<p>Bellman-Ford 算法</p>
<p>这里他用的“到X的最小生成树”实际上是X的单源最短路径树</p>
<p>分布式Bellman-Ford</p>
<ol>
<li>初始所有点到源的距离设为无穷,记为距离向量C=(C1,C2,...)</li>
<li>每过T时间,将C发送到所有邻边</li>
<li>如果发现发送过来的Ci比自己的Ci小,更新自己的Ci</li>
<li>重复23</li>
</ol>
<p>运行时间:最长无循环路径</p>
<p>收敛性:一定收敛</p>
<p>当连接的cost改变/连接挂了<!-- -->:Bad<!-- --> news travel slowly(Count to Infinity Problem)</p>
<p>R1-&gt;R2-&gt;R3-&gt;R4的图,R3-&gt;R4断了,R3会把R3-R4更新为R2-R3 + R2-R4的值而不是无穷！</p>
<p>这样Ri-&gt;R4的值都是慢慢增加,<strong>对切断完全不敏感</strong></p>
<p>解决方法有很多:</p>
<ul>
<li>设置“无穷”为一个小的值,迭代到超过它就是无穷,停止,认为截断</li>
<li>split horizon: R2从R3处得到最小的cost, 不反向传回R3(或传回无穷)</li>
<li>......</li>
</ul>
<p>split horizon不一定总是有效的,比较容易构造例子</p>
<p>Bellman Ford 算法和split horizon等机制构成了第一代路由协议(Routing Infomation Protocol, RIP)</p>
<p>优点是路由器的计算量很小</p>
<p>Dijkstra算法 大家都很熟了</p>
<p>注意一下Dijkstra在cost改变或者link出错的时候需要对所有节点重新计算单源最短路径</p>
<p>计算量大,但错误立即传播</p>
<p>OSPF(Open Shortest Path First)协议的基础</p>
<p>Hierarchy and Autonomous Systems(AS)</p>
<p>前面把互联网看成路由器的集合,对也不对</p>
<p>核心问题是规模太大了,导致交换和同步开销太大,即使按照O(E)也不现实, 实际上是多个小集合连接起来</p>
<p>每一个小集合称为一个AS,AS内部自己决定路由协议,通过一个或者多个出口和外部连接</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/15/KEXth5DIPTyBqfG.png" alt="image-20240915210137838" class="img_ev3q"></p>
<p>在AS之间,必须使用BGP-4(Border Gateway Protocol, rfc 1771)</p>
<p>AS的粒度大概在大学校,大企业这样</p>
<p>找找交大的AS</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">❯ traceroute electsys.sjtu.edu.cn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">traceroute to electsys.sjtu.edu.cn (202.120.35.189), 30 hops max, 60 byte packets</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1  * * *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  * * 10.3.2.217 (10.3.2.217)  4.413 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  10.32.31.246 (10.32.31.246)  4.915 ms  4.895 ms  4.874 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  10.32.73.226 (10.32.73.226)  4.305 ms  4.732 ms  4.090 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  202.120.35.189 (202.120.35.189)  4.033 ms  4.014 ms  3.995 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">❯ whois 202.120.35.189                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">% [whois.apnic.net]                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">% Whois data copyright terms    http://www.apnic.net/db/dbcopyright.h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tml                                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">% Information related to &#x27;202.112.0.0 - 202.121.255.255&#x27;             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">% Abuse contact for &#x27;202.112.0.0 - 202.121.255.255&#x27; is &#x27;abuse@cernet.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">edu.cn&#x27;                                                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inetnum:        202.112.0.0 - 202.121.255.255                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">netname:        CERNET-CN                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">descr:          China Education and Research Network                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">descr:          China Education and Research Network Center          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">descr:          Tsinghua University                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">descr:          Beijing, 100084                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">country:        CN                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">admin-c:        CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tech-c:         CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abuse-c:        AC1685-AP                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">status:         ALLOCATED PORTABLE                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        origin AS4538                                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-by:         APNIC-HM                                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-lower:      MAINT-CERNET-AP                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-routes:     MAINT-CERNET-AP                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-irt:        IRT-CERNET-AP                                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">last-modified:  2020-09-03T09:16:29Z                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">source:         APNIC                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">irt:            IRT-CERNET-AP                                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Network Research Center,                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Main Bldg, Tsinghua Univ                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Beijing 100084, China                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">phone:          +86-10-62784301                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fax-no:         +86-10-62785933                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e-mail:         abuse@cernet.edu.cn                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abuse-mailbox:  abuse@cernet.edu.cn                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">admin-c:        CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tech-c:         CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">auth:           # Filtered                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        timezone GMT+8                                       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        http://www.ccert.edu.cn                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        abuse@cernet.edu.cn was validated on 2024-07-04      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-by:         MAINT-CERNET-AP                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">last-modified:  2024-07-04T04:10:10Z                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">source:         APNIC                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">role:           ABUSE CERNETAP                                       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Network Research Center,                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Main Bldg, Tsinghua Univ                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Beijing 100084, China                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">country:        ZZ                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">phone:          +86-10-62784301                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e-mail:         abuse@cernet.edu.cn                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">admin-c:        CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tech-c:         CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nic-hdl:        AC1685-AP                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        Generated from irt object IRT-CERNET-AP              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        abuse@cernet.edu.cn was validated on 2024-07-04      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abuse-mailbox:  abuse@cernet.edu.cn                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-by:         APNIC-ABUSE                                          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">last-modified:  2024-07-04T04:10:19Z                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">source:         APNIC                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">role:           CERNET Helpdesk                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        CERNET Center                                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address:        Beijing 100084, China                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">country:        CN                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">phone:          +86-10-6278-4049                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fax-no:         +86-10-6278-5933                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e-mail:         helpdesk@cernet.edu.cn                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remarks:        abuse@cernet.edu.cn                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">admin-c:        XL1-CN                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tech-c:         SZ2-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nic-hdl:        CER-AP                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mnt-by:         MAINT-CERNET-AP                                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">last-modified:  2020-09-03T09:14:12Z                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">source:         APNIC                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">% This query was served by the APNIC Whois Service version 1.88.25 (W</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HOIS-AU1)                                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>是中国教育和科研计算机网络()</p>
<p>mac上支持<code>traceroute -a</code>但是ubuntu好像不支持</p>
<p>Interior Routing Protocols</p>
<p>RIP:</p>
<ul>
<li>使用分布式Bellman-Ford</li>
<li>每30s更新一次</li>
<li>没有身份验证</li>
<li>曾经广泛使用,现在多被OSPF和ISIS取代</li>
</ul>
<p>OSPF:</p>
<ul>
<li>连接信息直接暴力flooding</li>
<li>每一个路由器都跑Dijkstra</li>
<li>身份验证</li>
<li>很多复杂的细节(doge)</li>
</ul>
<p>单个出口的AS非常简单</p>
<ul>
<li>
<p>每一个路由器的default routing(路由表第一项)都是出口</p>
</li>
<li>
<p>路由表通常很小</p>
</li>
</ul>
<p>多出口:</p>
<p>必须指定每一个router的出口和对应前缀</p>
<p>Approach 1: hot-patato routing, 分配离路由器最近的出口</p>
<p>Approach 2: 分配离目标最近的出口</p>
<p>BGP-4 尝试解决的问题:</p>
<ul>
<li>网络拓扑复杂</li>
<li>AS 的 COST 五花八门,所以不可能找最短路径,找到一组路径就行</li>
<li>有些AS不信任其他的一些AS,隐私保护</li>
<li>不同AS的策略和目标不同</li>
</ul>
<p>the structure of Internet</p>
<p>从 Global ISP 到 Regional ISP 到 access ISP</p>
<p>BGP4</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/15/4bVGglyHLmp5sYk.png" alt="image-20240915215047521" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/15/8Tax3UIWlM6gXKV.png" alt="image-20240915215218659" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/15/erTnhlEjHGFxADw.png" alt="image-20240915215328459" class="img_ev3q"></p>
<p>例如商业上的local pref可能是</p>
<p>customer &gt; peer &gt; provider</p>
<p>Multicast</p>
<p>Reverse Path Broadcast(RPB)</p>
<p>aka Reverse Path Forwarding(RPF)</p>
<p>重用已有的最短路径树,Flooding但是只在最短路径树上Flooding</p>
<p>进一步可以给最短路径树加上剪枝</p>
<p>如果说对每个节点都维护一个最短路径树开销太大,也可以比如所有节点都采用中间的某个节点的最短路径树</p>
<p>多播常常不知道也难以知道接受者,这时候需要接受者主动表示接受数据包的意愿</p>
<p>IGMP host和直连router的协议,host要求router接受某些多播组的数据;router轮询host是否还想要</p>
<p>一些协议 DVMRP, PIM</p>
<p>multicast使用的比想象的少, 并且早期效率确实不高,并且安全、控制之类的问题也很多</p>
<p>Spanning Tree Protocol</p>
<p>Ethernet是如何避免循环的？(没有TTL字段的情况下)——构建生成树</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/15/cgl25yRxMDVLwp7.png" alt="image-20240915221756676" class="img_ev3q"></p>
<p>现在的算法又有很多变化和改 进</p>
<p>IPv6 128位地址 16 * 8 8个 4个16进制 字母块</p>
<p><code>https://[2001:470:806d:1::9]:80</code></p>
<p>大地址空间简化配置和IP分配问题</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-7-physical-and-link">Unit 7: Physical and Link<a class="hash-link" aria-label="Direct link to Unit 7: Physical and Link" title="Direct link to Unit 7: Physical and Link" href="/blog/cs144/cs144 lec notes#unit-7-physical-and-link">​</a></h2>
<p>Link</p>
<p>连接层</p>
<p>Channel capacity = B log<del>2</del>(1+S/N)</p>
<ul>
<li>B 带宽,S 信号强度,N噪声</li>
</ul>
<p>电磁波-&gt;信号:</p>
<ul>
<li>Amplitude Shift Keying ASK振幅调制</li>
<li>Freq Shift Keying FSK频率调制</li>
<li>Phase Shift Keying PSK相位调制</li>
</ul>
<p>有线网络一般ASK 慢的PAM-5,快的PAM-16</p>
<p>振幅调制需要环境干扰小且稳定</p>
<p>类似无线网络,环境干扰大,就常用PSK</p>
<p>BPSK two phases (0, pi)</p>
<p>QPSK (0, 90, 180, 270)</p>
<p>相位的优点有一个是可以很轻松地得到任意相位的波</p>
<p>I/Q Moudulation 一个0,一个180,线性叠加</p>
<p>QAM 同时使用ASK和PSK来得到物理层上表示更多信息的符号</p>
<p>eg. 16-QAM for 3G</p>
<p>Bit Error and Coding</p>
<p>Bit Error 噪声必定带来错误的symbol</p>
<p>Coding 通过在物理层加入冗余的bit来检错纠错</p>
<p>m/n code: m位bit转化为n位物理层bit 1/2 3/4</p>
<p>物理和链路原理</p>
<p>如何在没有全局时钟的情况下从电磁波得到symbol(接受者不知道发送者的时钟)</p>
<p>异步通信:</p>
<p>收到Start的下降沿之后开始按照自己的时钟周期接受</p>
<p>适用于 数据量小(积累偏移少,无需同步)的情况</p>
<p>例如红外遥控器</p>
<p>同步通信:</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/sowvx1uN8WatKA6.png" alt="image-20240914003537280" class="img_ev3q"></p>
<p>从时钟恢复单元通过过滤等手段从发送信号中得到原始时钟</p>
<p>以原始时钟  速率压入FIFO, 另一端以接收端的时钟弹出FIFO</p>
<p>如果不发送原始时钟信号,要完成clock recovery需要原始data有上升/下降沿</p>
<p>如何处理全0/全1？</p>
<p>Manchester Coding:</p>
<blockquote>
<p>在曼彻斯特编码中,每一位的中间有一跳变,位中间的跳变既作<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7/0?fromModule=lemma_inlink" target="_blank" rel="noopener noreferrer">时钟信号</a>,又作数据信号。</p>
<p>曼彻斯特编码有两种相反的约定。</p>
<p>其中的第一种约定由1949年由GE托马斯(GE Thomas)首次出版,随后有众多作家使用,例如,安迪·塔南鲍姆(Andy Tanenbaum)。 [3]它指定对于0位,信号电平将为低高电平(假设对数据进行幅度物理编码)-在位周期的前半段为低电平,在后半段为高电平。对于1位,信号电平将为高-低。</p>
<p>第二种约定也被众多作者使用(例如William Stallings) [4],IEEE 802.4(令牌总线)和IEEE 802.3(以太网)标准的低速版本所遵循。它指出逻辑0由高-低信号序列表示,逻辑1由低-高信号序列表示。</p>
</blockquote>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/xWHkfsrdiq6C9QV.png" alt="image-20240914004311151" class="img_ev3q"></p>
<p>问题:中间那个跳变为什么无影响？</p>
<p>答:对面也需要有大概频率,过一个过滤器(找频率的主成分),时钟能差两倍还是太离谱了</p>
<p>Pros:</p>
<ul>
<li>保证一个bit一次转换</li>
<li>保证了 d.c balance (相等的high/low, 有效电压稳定)</li>
</ul>
<p>Cons: 曼彻斯特编码的问题是最坏需要两倍的带宽</p>
<p>4b5b encoding</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/dCSU6vbEDLWKqtP.png" alt="image-20240914005027325" class="img_ev3q"></p>
<p>Coding</p>
<p>物理性错误的概率低但不是没有</p>
<p>加冗余<!-- -->:forward<!-- --> coding</p>
<p>Reed Solomon 编码(CD, DVD, RAID6, ...)</p>
<ul>
<li>从data中取k 块</li>
<li>让这k块作为一个k-1的多项式f的系数</li>
<li>用f计算n个不同点(n&gt;=k)</li>
<li>把这n个点作为k块的附加也发送</li>
<li>n个中任意k个可以恢复原始多项式</li>
</ul>
<p>最多校正 (n-k)/2个error,可以查所有错</p>
<p>可以通过interleaving来提升纠错能力,避免burst errors</p>
<p>The Link Layer</p>
<p>Ethernet上通过介质(空气,总线等)连接的多台主机的发信协议？</p>
<ul>
<li>
<p>Aloha 非常简单,有话就直接对介质说,冲突(自己说完听,如果不一样就冲突了)就稍后重发</p>
</li>
<li>
<p>CSMA/CD(实际使用的) 比较Aloha,加了1.说前先听有没有在说(CS) 2.(CD)如果冲突立刻停止,冲突后根据当前负载随机决定重发时间(0, 2^n^)512 bit times</p>
</li>
<li>
<p>更复杂的token ring之类用的不是很多,容错性也不是很好</p>
</li>
</ul>
<p>CSMA/CD 有最小包大小要求</p>
<p>如果距离最远两个点距离L, 传输速率c, 每个包至少要有2L/c这么长,否则collision信号传输到一个已经发完包的节点是令人疑惑的</p>
<p>Ethenet</p>
<p>更快的Ethenet 由于 2L/c 的限制,数据包大小不变,L只能缩小</p>
<p>早期:使用Hub 集线器</p>
<p>后来Ethenet越来越快,冲突增加,L减少,需要进行更多分区,不再能一个Hub全管,同时芯片技术升级,成本降低,就从粗放管理产生了交换机</p>
<p>并且交换机的线还可以做成全双工,进一步减少冲突</p>
<p>Hubs to Switches</p>
<blockquote>
<p>对于集线器而言,信号将沿其端口进行传输,并广播到其他端口,正因如此容易产生广播风暴,当网络规模较大时其性能会受到影响。而交换机只有发出请求的端口和目的端口之间才会相互响应,并不会影响到其他端口,因此交换机能够在一定程度上有效抑制广播风暴的产生。</p>
<p>此外,集线器的所有端口都是共享一条带宽,在同一时刻只能有两个端口进行数据传输,其他端口都处于等待状态。而交换机 的每个端口都有一条独立的带宽,当各个端口进行工作时,每个端口之间互不受影响。而且交换机会保留与之连接的所有设备的MAC地址,可查询到数据转发到了哪个端口上。也就是说交换机确切地知道将数据发送到了哪个端口,能有效节省网络响应时间。但集线器却没法区分将数据转发到了哪个端口。</p>
</blockquote>
<table><thead><tr><th>区别</th><th>集线器</th><th>交换机</th><th>路由器</th></tr></thead><tbody><tr><td>工作层次</td><td>物理层</td><td>数据链路层</td><td>网络层</td></tr><tr><td>作用</td><td>信号放大和传输作用,可将计算机网络连接在一起。</td><td>将一个网络端口分成多个网络端口,用于连接更多的设备；同时可管理端口和配置VLAN安全管理。</td><td>连接不同的网络,以及选择信息传输的线路。</td></tr><tr><td>数据传输形式</td><td>电信号</td><td>帧和包</td><td>包</td></tr><tr><td>端口</td><td>4/12端口</td><td>多端口,通常在4~48端口数之间</td><td>2/4/5/8端口</td></tr><tr><td>传输方式</td><td>泛洪、单播、多播或广播</td><td>先广播在单播或多播</td><td>先广播在单播和多播(取决于需求)</td></tr><tr><td>设备类型</td><td>非智能设备</td><td>智能设备</td><td>智能设备</td></tr><tr><td>应用</td><td>局域网</td><td>局域网</td><td>局域网/城域网/广域网</td></tr><tr><td>传输模式</td><td>半双工</td><td>半双工/全双工</td><td>全双工</td></tr><tr><td>速率</td><td>10Mbps</td><td>10/100Mbps, 1Gbps</td><td>1<del>100Mbps(无线) 100</del>1000Mbps(有线)</td></tr><tr><td>用于数据传输的地址类型</td><td>MAC地址</td><td>MAC地址</td><td>IP地址</td></tr></tbody></table>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/QfjLvwRaoA21Kn8.png" alt="image-20240914014627891" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/Y6vkIzncm3XWigO.png" alt="image-20240914014742672" class="img_ev3q"></p>
<p>Wireless Networking</p>
<p>Radiates over space -&gt; 最坏r^2^的信号衰减</p>
<p>Uncontrolled medium -&gt; 易受影响,随时变化</p>
<p>can reflect</p>
<p>wifi 具有高丢包率,且波动巨大-&gt;必须考虑tcp等重传机制</p>
<p>CSMA/CD对wifi不适用:核心在于碰撞检查,在无线情况下,自己监听到的情况和实际接受者处的情况区别较大(比如衰减太多以至于听不到)</p>
<p>问题有:</p>
<ul>
<li>如何区分是碰撞还是信号衰减太多没收到</li>
<li>Exposed terminal, B-&gt;A, C-&gt;D, 圆形区域以为信道碰撞,实际没有碰撞可以使用</li>
<li>Hidden terminal, 例如A-B-C,中间有山, A感知不到C, C感知不到A,无法碰撞检测</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://img2018.cnblogs.com/blog/1958143/202003/1958143-20200311121104859-1365284745.png" alt="1583899442855" class="img_ev3q"></p>
<p>CSMA/CA (collision avoidance)</p>
<p>把碰撞检测改成碰撞检查,尝试发送包的时候先给目标发送一个确认,当目标返回确认时才发包,否则等待并重试,如果等待太久丢弃这个包</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/xvTGNABhWOosK27.png" alt="image-20240914185814619" class="img_ev3q"></p>
<p>参考 <a href="https://www.cnblogs.com/cpaulyz/p/12461500.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/cpaulyz/p/12461500.html</a></p>
<p>CSMA/CA尝试降低碰撞的概率,但没有解决上面Exposed terminal等问题</p>
<p>在CSMA/CA上的补充<!-- -->:RTS<!-- -->/CTS</p>
<p>简要流程</p>
<blockquote>
<p>在送真的封包之前,先廣播一個 request to send 封包。這個封包不只有目的地會收到,發送者傳輸範圍內的其他裝置也會收到。而目的地如果順利收到這個 RTS 的封包,則必須廣播一個 clear to send (CTS) 封包,代表已經準備好接收封包。</p>
<p>並且規定:聽到 CTS 廣播的那些節點,也就是上圖中的紅色節點,在一段足夠向 𝐶 傳輸完訊息的時間內,都不能向 𝐶 傳輸訊息</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/IEEE_802.11_RTS/CTS" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/IEEE_802.11_RTS/CTS</a></p>
<p>这个讲得很好 <a href="https://hackmd.io/@0xff07/SJO5VTpmY" target="_blank" rel="noopener noreferrer">https://hackmd.io/@0xff07/SJO5VTpmY</a></p>
<p>解决了Hidden terminal, 对另外两个效果不是很好</p>
<p><strong>但是实际的WIFI系统不怎么用,开销问题</strong></p>
<p>传输速率越高,实际数据需要的时间越少,在传数据前进行RTS/CTS沟通的开销就越大,11Mbps的时候已经占了25%的开销</p>
<p>802.11 Format</p>
<p><img decoding="async" loading="lazy" src="https://s2.loli.net/2024/09/14/b2Pfe4ZFJndMxcS.png" alt="image-20240914193159633" class="img_ev3q"></p>
<p>duration可以用来提供CTS对其他节点需要等多久的通知</p>
<p>wifi为了向前兼容性</p>
<p>前面的控制头是以最低速率1mbps 发送的,后面的data段才可以加速</p>
<p>这也是为什么速率上不去(2020的144说最大600mbps左右(for 802.11.n 2008))和RTS/CTS实际上开销很大的原因</p>
<p>Fragementation:</p>
<p>不同的Link层对包的大小最大限制是不同的</p>
<p>一个大的数据传输时会被分成许多小包,而在传输过程中如果分成的小包还是超过了这一段的传输限制,就会继续拆分,但直到dst之前都不会被重新组装。</p>
<p>过多的小包带来了速度和容易丢失(一旦有一个IP包拆出来的几个小包丢失就需要重发整个IP包)等问题,所有要避免</p>
<p>一个技术手段是使用IP的DF(don&#x27;t fragment)bit,指定之后如果发现还需要进一步分片,就丢弃并返回一个ICMP error</p>
<p>分片细节参考</p>
<p><a href="https://packetpushers.net/blog/ip-fragmentation-in-detail/" target="_blank" rel="noopener noreferrer">https://packetpushers.net/blog/ip-fragmentation-in-detail/</a></p>
<p>现在的分段问题少了很多,一个是基本使用Ethernet 1500MTU, 二个是会提前使用ICMP检测路径上最短的MTU(maximium transmition unit),控制包小于MTU来避免分块,不过对于UDP,参见上面的blog,还是有不少问题</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="unit-8-security">Unit 8: Security<a class="hash-link" aria-label="Direct link to Unit 8: Security" title="Direct link to Unit 8: Security" href="/blog/cs144/cs144 lec notes#unit-8-security">​</a></h2>
<ol>
<li>Secrecy</li>
<li>Integrity</li>
<li>Authentication</li>
<li>Uninterrupted communication</li>
</ol>
<p>这个章节建议看看他的动画demo听故事(bushi)</p>
<p>Layer2 ATTACK(Link)</p>
<p>MAC Overflow attack: 交换机从包的src,dst中学习路径,如果表里面没有就全端口广播,为了让攻击者看到交换信息,攻击者产生大量{src,dst}包用于LRU驱逐交换机原有的路径表,使得其他人发包产生广播</p>
<p>DHCP ATTACK 建立恶意DHCP server, 并先于好的server发出响应</p>
<p>同理的ARP ATTCAK</p>
<p>TCP Hijacking(TCP劫持)ARP ATTACK的基础上,作为TCP连接的转发中间人窃听信息</p>
<p>Layer3 ATTACK(IP)</p>
<p>ICMP ATTACK 在路由不到的时候会返回一个ICMP error,攻击者通过恶意路由器充当中间人/重定向到恶意地址</p>
<p>BGP hijacking 非常严重,几乎无法防备。从运营商层面进行攻击,提供错误的路由“路标” <a href="https://www.cloudflare.com/zh-cn/learning/security/glossary/bgp-hijacking/" target="_blank" rel="noopener noreferrer">https://www.cloudflare.com/zh-cn/learning/security/glossary/bgp-hijacking/</a></p>
<p>More Specific Prefix</p>
<p>DDos 大规模变化肉鸡向server发送消耗资源无意义请求,例如flood ping,占用大量网络带宽至服务不可用</p>
<p>更精妙的是可以有其他服务器充当放大跳板,有些请求的响应会比请求大几倍,向某个跳板服务器发送目标为攻击服务器的请求,跳板服务器的响应洪流就可以比原始攻击流放大几倍,也 更不好追踪</p>
<p>还有SYN Attack 多台攻击机器向服务器发起tcp请求,又不建立链接,让被攻击服务器自己超时才释放,消耗系统资源。类似还有发送部分IP链接碎片的IP Fragment flooding</p>
<p>还有UDP echo攻击,SSL攻击......</p>
<p>解决方法:加密 &amp;&amp; 可拓展(高可用)系统 &amp;&amp; 信任链 &amp;&amp; ......</p>
<p>后面的密码学感觉没有什么特别研究的必要,都是数学细节,非对称加密、证书、TLS之类看看科普也行,写过web多少知道些。知道咋回事,拿来用就行。用课程的一句话:</p>
<blockquote>
<p>It&#x27;s easy to make a mistabke. Use existing, open source implementions. Be careful and follow best practices.</p>
</blockquote></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/network">network</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/cs-144">cs144</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/nginx"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">nginx基础</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/django-mosh"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Django_mosh</div></a></nav><div>Loading Comments...</div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-1-internet-and-ip">Unit 1: Internet and IP</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-2-transport">Unit 2: Transport</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-3-packet-switching">Unit 3: Packet Switching</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-4-congestion-control">Unit 4: Congestion Control</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-5-nat-application">Unit 5: NAT Application</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#tcp-hole-punching-tcp打孔">TCP Hole Punching TCP打孔</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#sockets-and-tcp-port-reuse-套接字和-tcp-端口重用">Sockets and TCP Port Reuse 套接字和 TCP 端口重用</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-6-routing">Unit 6: Routing</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-7-physical-and-link">Unit 7: Physical and Link</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/cs144/cs144 lec notes#unit-8-security">Unit 8: Security</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">notes</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/RL">课程笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/personal-essays">Personal Essays</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Ayanami, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>