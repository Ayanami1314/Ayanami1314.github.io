<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">4 posts tagged with &quot;mllm&quot; | Ayanami&#x27;s Cave</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ayanami1314.github.io/blog/tags/mllm"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="4 posts tagged with &quot;mllm&quot; | Ayanami&#x27;s Cave"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/ayanami.jpg"><link data-rh="true" rel="canonical" href="https://ayanami1314.github.io/blog/tags/mllm"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/tags/mllm" hreflang="en"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/tags/mllm" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Ayanami&#39;s Cave Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/personal-essays/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/personal-essays/atom.xml" title="Ayanami&#39;s Cave Atom Feed">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.00dd3480.css">
<script src="/assets/js/runtime~main.aa217668.js" defer="defer"></script>
<script src="/assets/js/main.0da58ad9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Ayanami&#x27;s Cave</b></a><a class="navbar__item navbar__link" href="/docs/Chcore源码阅读">课程笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">技术博客</a><a class="navbar__item navbar__link" href="/personal-essays">个人随笔</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/llm for code paper notes">paper-reading, code&amp;rl方向</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/speculative-decode-overview">投机解码简述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Paper reading Context Pruning and beyond hard pruning">Paper reading - Context Pruning and beyond hard pruning</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/结构化输出">结构化输出与AI工具与Agent</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/context-engineering">context-engineering</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/从微 调reranker到搜推">从微调reranker到搜推工程实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/llm-tech-report">部分llm技术报告的阅读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Ask in Any Modality A Comprehensive Survey on Multimodal Retrieval-Augmented Generation">Paper reading-Ask in Any Modality A Comprehensive Survey on Multimodal Retrieval-Augmented Generation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/精读 AAAI 2025 Fit and Prune Fast and Training-free Visual Token Pruning for Multi-modal Large Language Models">Paper reading - Fit and Prune Fast and Training-free Visual Token Pruning for Multi-modal Large Language Models</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/精读：Eagle Exploring The Design Space for Multi- modal LLMs with Mixture of Encoders">Paper reading-Eagle Exploring The Design Space for Multi- modal LLMs with Mixture of Encoders</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/RAG的一些思考和细节">RAG的一些思考与细节</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/精读  Interleaved Scene Graph for Interleaved Text-and-Image Generation Assessment">Paper reading - Interleaved Scene Graph for Interleaved Text-and-Image Generation Assessment</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ColBERT">ColBERT-后期交互方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/05/26/技术博客阅读">美团技术博客阅读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Milvus">稀疏神经嵌入</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/RocketMQ">RocketMQ学习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/AI limu">李沐dl笔记</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs186-database-WIP">ucb cs186 课程笔记(更新中)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os-虚拟化">NJU操作系统(jyy OS)课程笔记-虚拟化部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/local-llm">来本地部署大模型!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ostep-chapter42-44">ostep阅读笔记：单机fs的崩溃一致性(chapter42-44)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/系统架构设计笔记">system-design-interview笔记</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/JUC">JUC</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs144 labs">cs144 labs(Winter 2024)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os：并发">NJU操作系统(jyy OS)课程笔记-并发部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/nginx">nginx基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs144/cs144 lec notes">CS144 Lecture Notes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/django-mosh">Django_mosh</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/splay-tree">splay tree</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/xv6book-notes">xv6book Notes(C1-4)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Go-Gin学习">Go,Gin学习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/godis源码阅读">godis源码阅读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/hibernate-jpa">hibernate&amp;jpa</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/linking-复习">linking 复习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ts基础">ts基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/实战2-mosh-gamehub">react practice:mosh gamehub</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/浅入理解断点和调试器">浅入理解断点和调试器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/黑马点评">黑马点评(速通版)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/js基础">js基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/11-14-11-26学习双周记">11-14-11-26学习双周记</a></li></ul></nav></aside><main class="col col--7"><header class="margin-bottom--xl"><h1>4 posts tagged with &quot;mllm&quot;</h1><a href="/blog/tags">View All Tags</a></header><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/Ask in Any Modality A Comprehensive Survey on Multimodal Retrieval-Augmented Generation">Paper reading-Ask in Any Modality A Comprehensive Survey on Multimodal Retrieval-Augmented Generation</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-06-02T00:00:00.000Z">June 2, 2025</time> · <!-- -->16 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div class="markdown"><p>RAG 抽象来说就是，<code>embed - opitional[rerank] - generate</code>管道</p>
<p>有许多的增强方案，例如 Plan X RAG（将问题分解为子问题的DAG，然后设计一些critic LLM判断流的状态正常与否，一个执行LLM按照拓扑序执行DAG），Agentic RAG,  feedback-driven iterative refinement</p>
<p>局限是：传统RAG主要针对文本，多模态集成还是挑战</p>
<p>流程概述如下图</p>
<hr>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2502.08826v2/extracted/6211743/MM-RAG-500.png" alt="Refer to caption" class="img_ev3q"></p>
<hr>
<h1>Multimodel RAG</h1>
<p>LLM拓展为MLLM带来了多模态RAG的挑战</p>
<ul>
<li><strong>检索哪些模态</strong></li>
<li><strong>数据类型的有效融合</strong></li>
<li><strong>跨模态相关性</strong></li>
</ul>
<p><strong>特定模态的编码器将不同的模态映射到共享语义空间，实现跨模态对齐</strong></p>
<hr>
<h1>现有数据集和基准</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据集">数据集<a class="hash-link" aria-label="Direct link to 数据集" title="Direct link to 数据集" href="/blog/tags/mllm#数据集">​</a></h2>
<ul>
<li>
<p>图文任务（字幕、检索）：MS-COCO, Flickr30K, LAION-400M</p>
</li>
<li>
<p>利用外部知识的视觉问答: OK-VQA</p>
</li>
<li>
<p>多模态推理：MultimodalQA</p>
</li>
<li>
<p>视频文本任务：ActivityNet，YouCook2</p>
</li>
<li>
<p>医学：MIMIC-CXR</p>
</li>
</ul>
<p>许多数据集都是单模态的，随后与其他模态的互补数据集集成。</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="benchmark">Benchmark<a class="hash-link" aria-label="Direct link to Benchmark" title="Direct link to Benchmark" href="/blog/tags/mllm#benchmark">​</a></h2>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mn>2</mn></msup><mtext>⁢</mtext><mi>R</mi><mtext>⁢</mtext><mi>A</mi><mtext>⁢</mtext><mi>G</mi></mrow><annotation encoding="application/x-tex">M^2⁢R⁢A⁢G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">⁢</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord">⁢</span><span class="mord mathnormal">A</span><span class="mord">⁢</span><span class="mord mathnormal">G</span></span></span></span>:
我们执行以下步骤来处理图像，以确保它们具有高质量并且与用户查询相关：
（1）<strong>缓存和转换</strong>：使用 URL 下载所有图像，并将其转换为广泛接受的格式，例如 JPG、PNG、GIF 或 WEBP。无法成功下载或转换的图像将被丢弃；
（2）<strong>过滤</strong>：小于某个阈值或与查询文本的基于 CLIP 相似度得分较低的图像将被删除。此类图像通常包含非代表性的视觉内容，例如图标、横幅等。
（3）<strong>重复数据删除</strong>：使用 PHash Zauner 算法删除重复或高度相似的图像。</p>
<p>指标设计：<strong>主要靠prompt gpt-4o做评估</strong></p>
<ul>
<li>文本模态指标：流畅性，相关性，忠实度，上下文准确率</li>
<li>多模态指标：图像连贯性（图像和周围文本逻辑的连贯性，图像有用性， 图像引用（验证图像和文本引用的适当性），图像召回率（高度相关图像的召回比例）</li>
<li>取所有指标的平均值用于计算总分</li>
</ul>
<hr>
<h1>两种联合建模策略</h1>
<ul>
<li>single-stage：直接生成多模态输出</li>
<li>multi-stage: <strong>文本生成 - 图像插入 - 文本重润色</strong> 三个阶段</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2411.16365v3/x1.png" alt="" class="img_ev3q"></p>
<hr>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2411.16365v3/x2.png" alt="Refer to caption" class="img_ev3q"></p>
<hr>
<h1>视觉为中心的评估</h1>
<p>MRAG-Bench, VQAv2, VisDoMBench, Dyn-VQA, ScienceQA</p>
<p><img decoding="async" loading="lazy" src="https://mragbench.github.io/static/images/teaser.png" alt="img" class="img_ev3q"></p>
<hr>
<h1>知识密集型评估</h1>
<p>TriviaQA, RAG Check, Natural Questions</p>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250528162131659" src="/assets/images/image-20250528162131659-62018707c1a0f00cfba6a516a14268bc.png" width="1590" height="831" class="img_ev3q"></p>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250528162212109" src="/assets/images/image-20250528162212109-27a90337735939c22a158260b068557b.png" width="1639" height="793" class="img_ev3q"></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="创新和方法">创新和方法<a class="hash-link" aria-label="Direct link to 创新和方法" title="Direct link to 创新和方法" href="/blog/tags/mllm#创新和方法">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="检索策略">检索策略<a class="hash-link" aria-label="Direct link to 检索策略" title="Direct link to 检索策略" href="/blog/tags/mllm#检索策略">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="高效和精度">高效和精度<a class="hash-link" aria-label="Direct link to 高效和精度" title="Direct link to 高效和精度" href="/blog/tags/mllm#高效和精度">​</a></h4>
<p>现代MRAG<strong>将不同输入模态编码到统一的embedding空间实现直接跨模态检索</strong></p>
<p>方法上，主要为Maximum inner product search (<strong>MIPS</strong>) 变体：近似MIPS，分布式MIPS，KNN变体，近似KNN，ScaNN</p>
<ul>
<li>ScaNN主要结合了一些数学方法 和 量化方法构建了足够快的向量检索索引，这类方法都是用于海量数据的（如1M）</li>
<li>专注于CPU，例如做了很多量化优化让它能尽量利用现代CPU的simd指令 <a href="https://zilliz.com/blog/faiss-vs-scann-choosing-the-right-tool-for-vector-search" target="_blank" rel="noopener noreferrer">https://zilliz.com/blog/faiss-vs-scann-choosing-the-right-tool-for-vector-search</a></li>
</ul>
<hr>
<p>创新主要在效率提升和精度降低：</p>
<ul>
<li>混合搜索</li>
<li>自适应量化</li>
<li>learned index: 神经网络驱动的索引建立，主要是数据库那边的工作</li>
</ul>
<hr>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="以模态为中心的检索">以模态为中心的检索<a class="hash-link" aria-label="Direct link to 以模态为中心的检索" title="Direct link to 以模态为中心的检索" href="/blog/tags/mllm#以模态为中心的检索">​</a></h4>
<p>文本中心</p>
<ul>
<li>BM25</li>
<li>bge-m3</li>
<li>ColBERT</li>
<li>RAFT(混合干扰和ground truth文档微调模型增强抗干扰能力)</li>
<li>...</li>
</ul>
<hr>
<p>视觉中心</p>
<ul>
<li>直接用图像表示进行知识提取</li>
<li>基于参考图像的检索，如EchoSight和ImgRet<!-- -->
<ul>
<li>EchoSight 引入了多模态重排</li>
<li><img decoding="async" loading="lazy" src="https://go2heart.github.io/echosight/static/images/teaser.png" alt="Teaser" class="img_ev3q"></li>
</ul>
</li>
</ul>
<hr>
<p>具体来说，对于一个图文问题query, 先用image视觉相似度找到对应的wiki条目，再将wiki的section与图+文的完整query（经过Q-Former之后）进行文本rerank，最后综合视觉分数和文本rerank分数，选取topk后输入LLM。<strong>专注于问题和知识库都是图+文的情况</strong>，也只是finding, 感觉确实创新度不够
<img decoding="async" loading="lazy" src="https://go2heart.github.io/echosight/static/images/overall.png" alt="Overall Structure h:500" class="img_ev3q"></p>
<hr>
<ul>
<li>组合多张图像特征形成综合查询表示</li>
<li>图文映射：Pic2word 如下图，将视觉映射到文本描述</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjkH5SDYcnCCNSbv4tyJ7lEaZp4W0SsMVP2rBTx8-AnXGM2eYaY04UX9sczYL07-z9TPvcbKP5wF6huVyWe6SOQqqz_iE9Ove-RupgS0e50E5StD1A_yKF2KQtrVgy01J6WaLUZ4rYatFQqgBEnoltPBRXAqTgcGmuD8hVJ3BBkEi55ASVhMy35-_j1yCjs/s16000/image3.png" alt="img" class="img_ev3q"></p>
<hr>
<p>视频中心</p>
<ul>
<li>iRAG，增量检索</li>
<li>MV-Adapter</li>
<li>Video RAG</li>
<li>RTime: 时间因果关系</li>
<li>OmAgent：分治处理复杂视频理解</li>
<li>DRVideo：基于文档检索处理长视频理解</li>
<li>...</li>
</ul>
<hr>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="文档检索和布局理解">文档检索和布局理解<a class="hash-link" aria-label="Direct link to 文档检索和布局理解" title="Direct link to 文档检索和布局理解" href="/blog/tags/mllm#文档检索和布局理解">​</a></h4>
<p>ColPali， ColQwen2: 端到端文档图像检索，动态分辨率处理，整体多页推理，绕过OCR技术，1.9k star</p>
<p>它的想法是这样的</p>
<ul>
<li><strong>OCR的多个组件和分块带来误差传播</strong>，且预处理流程耗时也长，能不能直接端到端一次使用文档截图解决</li>
<li>但是如果将整页的文档编码成一个向量，肯定精度不够</li>
<li>多向量方案最经典的ColBERT, 并且在这样一个视觉的情况下，<strong>视觉patch做多向量比文本token还合理</strong></li>
</ul>
<hr>
<ul>
<li>贡献<!-- -->
<ul>
<li>benchmark ViDoRe</li>
<li>将ColBERT和视觉语言模型结合，利用多向量不仅启发了<strong>文搜文，文搜图，还启发了“给一个文档，查找相似的文档”这样的任务</strong></li>
<li>提供了一个良好的视觉文本融合的范式（例如，解决了CLIP这样的模型缺乏文本细粒度的问题），允许最先进的VLM如Qwen-VL-2B，以相同的训练策略微调后作为嵌入器，+5.3 nDCG@5</li>
</ul>
</li>
</ul>
<hr>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2407.01449v6/extracted/6240861/images/final_architecture.png" alt="Refer to caption" class="img_ev3q"></p>
<hr>
<p><strong>可不可以将这个范式沿用到引用溯源？</strong></p>
<p>已经有一些了，ColPali自己就做了每个词条最显著的图像块</p>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2407.01449v6/extracted/6240861/images/similarity_map_energy.png" alt="Refer to caption h:500" class="img_ev3q"></p>
<p>一些布局理解的新框架：ViTLP, DocLLM, CREAM, mPLUG-DocOwl</p>
<hr>
<blockquote>
<p><em>To our knowledge, no benchmark evaluates document retrieval systems in practical settings; in an end-to-end manner, across several document types and topics, and by evaluating the use of both textual and visual document features.</em></p>
</blockquote>
<blockquote>
<p><a href="https://huggingface.co/blog/fsommers/document-similarity-colpali" target="_blank" rel="noopener noreferrer">https://huggingface.co/blog/fsommers/document-similarity-colpali</a>
基于 OCR 的文本提取，以及随后的布局和边界框分析，仍然是重要文档 AI 模型（例如 LayoutLM）的核心。例如， <a href="https://huggingface.co/microsoft/layoutlmv3-base" target="_blank" rel="noopener noreferrer">LayoutLMv3</a> 对文档文本进行编码，包括文本标记序列的顺序、标记或线段的 OCR 边界框坐标以及文档本身。这在关键的文档 AI 任务中取得了最佳成果，但前提是第一步——OCR 文本提取——能够顺利完成。</p>
<p><strong>但通常情况并非如此。</strong></p>
<p>根据我最近的经验，<strong>OCR 瓶颈导致现实世界生产文档档案中的命名实体识别 (NER) 任务的性能下降近 50%。</strong></p>
</blockquote>
<hr>
<p><img decoding="async" loading="lazy" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/paligemma/paligemma_arch.png" alt="Architecture h:600" class="img_ev3q"></p>
<hr>
<p>为下游任务提供了一系列微调版本</p>
<ul>
<li>Image Caption 加字幕</li>
<li>VQA</li>
<li>Detection (Detect [entity])</li>
<li>图像实体分割</li>
<li>文档理解</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="重排序和选择">重排序和选择<a class="hash-link" aria-label="Direct link to 重排序和选择" title="Direct link to 重排序和选择" href="/blog/tags/mllm#重排序和选择">​</a></h3>
<p>多用多步骤检索，整合监督和非监督策略</p>
<ul>
<li>probabilistic control keywords to improve credibility<!-- -->
<ul>
<li>对示例的关键信息进行关键词提取，为关键词赋予概率权重，使用概率进行控制信号，<strong>让模型倾向于选择高概率关键词的示例</strong></li>
</ul>
</li>
<li>RULE 利用<strong>统计方法</strong>(Bonferroni校正)校准相关上下文<!-- -->
<ul>
<li>利用统计方法，将“5%概率<strong>存在</strong>错误上下文”这样的朴素要求通过统计运算转换成单个上下文相关度的硬阈值</li>
</ul>
</li>
<li>视频检索中<strong>基于聚类的关键帧选择</strong>来提高多样性</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="相关性评估">相关性评估<a class="hash-link" aria-label="Direct link to 相关性评估" title="Direct link to 相关性评估" href="/blog/tags/mllm#相关性评估">​</a></h3>
<ul>
<li><strong>SSIM (Structural Similarity Index Measure)</strong>
最早用于图像领域，衡量两幅图像间的结构、亮度、对比度相似度。现在常用于多模态信息检索，例如图片和文本联合时的相似性计算。<!-- -->
<ul>
<li>比起传统的均方差等简单像素差，更符合人类对视觉感知的一致性判断，综合考虑亮度对比度等</li>
</ul>
</li>
<li><strong>NCC (Normalized Cross-Correlation)</strong>
标准化互相关，常见于信号处理，也可以衡量不同模态数据间的相关强度。<!-- -->
<ul>
<li>衡量两个向量或数组的<strong>线性相关性</strong></li>
</ul>
</li>
<li><strong>BERTScore</strong>
利用BERT这样的深度语义模型计算文本间的语义相似度，比传统关键词对齐更关注上下文语义一致性</li>
<li>分层后处理：重排、相似度筛选、上下文窗口、合并、...</li>
</ul>
<hr>
<ul>
<li>
<p><strong>LDRE</strong></p>
<p>结合多种特征（如caption描述、上下文语义、实体识别等），通过权重自适应集成，提高不同表示方式下的检索相关性适应能力</p>
</li>
<li>
<p>BM25等传统排名的集成</p>
</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="过滤机制">过滤机制<a class="hash-link" aria-label="Direct link to 过滤机制" title="Direct link to 过滤机制" href="/blog/tags/mllm#过滤机制">​</a></h3>
<ul>
<li>
<p>硬负样本挖掘：比起文本的硬负样本挖掘需要多处理跨模态的问题，如不同模态的bias等</p>
<ul>
<li>GME</li>
<li>MM Embed</li>
</ul>
</li>
<li>
<p>共识过滤、多向量过滤</p>
<ul>
<li>MuRAR</li>
<li>ColPali</li>
</ul>
</li>
<li>
<p>动态模态过滤</p>
<ul>
<li>训练retriever判断哪部分是噪声</li>
<li>RAFT, Img2Loc, MAIN-RAG</li>
</ul>
</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="融合机制">融合机制<a class="hash-link" aria-label="Direct link to 融合机制" title="Direct link to 融合机制" href="/blog/tags/mllm#融合机制">​</a></h3>
<p>分数融合和对齐</p>
<ul>
<li>
<p>训练交叉编码器将多模态转换为文本格式</p>
</li>
<li>
<p>引入交错文本对，合并垂直多张few shot images（?）</p>
</li>
<li>
<p>CLIP分数融合，BLIP特征融合，嵌入到相同的空间</p>
</li>
<li>
<p>VISA 使用文档截图嵌入(DSE)模型，对齐文本查询和视觉文档表示</p>
</li>
<li>
<p>MA-LMM视频文本嵌入</p>
</li>
<li>
<p>LLM-RA 将文本和视觉嵌入连接成联合查询</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<p>注意力机制：</p>
<p>注意力方法动态加权跨模态交互，支持特定任务推理</p>
<p>EMERGE, MORE, Alzheimer RAG,RAMM,RAGTrans, MV-Adapter, M2-RAAP</p>
<hr>
<p>统一的框架和预测</p>
<p>M3DocRAG : 多页文档展平为单个嵌入张量</p>
<p>PDF-MVQA 融合了基于感兴趣区域 (RoI) 和基于块 (CLIP) 的视觉语言模型</p>
<p>DQU-CIR 图像转换为复杂查询的文本标题以及将文本叠加到图像上来统一原始数据，然后通过 MLP 学习的权重融合嵌入</p>
<p>SAM-RAG生成图像的标题来对齐图像-文本模态</p>
<p>UFineBench 利用共享粒度解码器进行超精细文本人物检索</p>
<p>Dense2Sparse 投影，将来自 BLIP/ALBEF Li 等人 ( <a href="https://arxiv.org/html/2502.08826v2#bib.bib111" target="_blank" rel="noopener noreferrer">2022a</a> ) 等模型的密集嵌入转换为稀疏词汇向量，使用层归一化和概率扩展控制来优化存储和可解释性</p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="增强技术">增强技术<a class="hash-link" aria-label="Direct link to 增强技术" title="Direct link to 增强技术" href="/blog/tags/mllm#增强技术">​</a></h3>
<p>Context Enrichment</p>
<p>查询 重构为结构化检索请求， Video-RAG,EMERGE 整合实体关系和语义描述</p>
<p>Img2Loc 提示中包含数据库中最相似的和最不相似的点来让模型排除预测中不可信的位置</p>
<p>虽然说只是prompt工作，但想法似乎挺有趣，只是这样的作法能否比简单的几层MLP强呢？</p>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2403.19584v1/extracted/2403.19584v1/figure3.jpg" alt="Refer to caption h:400" class="img_ev3q"></p>
<hr>
<p>动态检索</p>
<ul>
<li>
<p>SKURG 查询复杂度决定跳数</p>
</li>
<li>
<p>MR2AG 动态评估和过滤</p>
</li>
<li>
<p>OmniSearch 分解问题</p>
</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="生成技术">生成技术<a class="hash-link" aria-label="Direct link to 生成技术" title="Direct link to 生成技术" href="/blog/tags/mllm#生成技术">​</a></h3>
<ul>
<li>
<p>In context learning</p>
<ul>
<li>
<p>记忆数据 RAG-Driver（可解释的自动驾驶）</p>
<ul>
<li><strong>检索引擎</strong>
接收到当前驾驶场景（如视频帧和对应的车辆控制信号）后，先在专家示范的记忆库中检索出与当前最相似的历史驾驶样本。</li>
<li><strong>多模态大语言模型处理</strong>
将检索到的样本与当前场景一同输入多模态大语言模型（MLLM），利用指令微调（Instruction Tuning），实现三项任务：<!-- -->
<ul>
<li><strong>动作解释</strong>（Driving Action Explanation）：输出当前行为的自然语言解释；</li>
<li><strong>行为理由</strong>（Action Justification）：对决策作出合理性说明；</li>
<li><strong>控制信号预测</strong>（Control Signal Prediction）：给出下一个动作的具体数值（如速度和转角）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><img decoding="async" loading="lazy" src="https://yuanjianhao508.github.io/RAG-Driver/static/images/RAGDriver_main.png" alt="MY ALT TEXT h:600" class="img_ev3q"></p>
<hr>
<ul>
<li>
<p>融合上下文Fusion-in-Context Learning (没太看懂RAVEN这篇论文和融合上下文这一个比较早期的encoder-decoder模型的机制有什么关系)</p>
</li>
<li>
<p>Reasoning</p>
<ul>
<li>CoT RAGAR RAG链和RAG树，迭代方式优化事实核查</li>
<li>VisDoM CoT和证据整理</li>
<li>SAM-RAG 推理链和多阶段验证</li>
</ul>
</li>
</ul>
<p>指令调优：如mR2AG 用 mR2AG-IT的数据调优MLLM</p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="来源归属">来源归属<a class="hash-link" aria-label="Direct link to 来源归属" title="Direct link to 来源归属" href="/blog/tags/mllm#来源归属">​</a></h3>
<p>VISA 视觉来源归属</p>
<ul>
<li>看了看他的论文，VLM<strong>直接输出</strong>边界框(也就是，输入为文档图片，输出为答案 + Box)的，再<strong>LoRA微调</strong>......</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20250528205321419 h:400" src="/assets/images/image-20250528205321419-2f1eec60f2c657b45d90932b2e0c898a.png" width="956" height="538" class="img_ev3q"></p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对齐">对齐<a class="hash-link" aria-label="Direct link to 对齐" title="Direct link to 对齐" href="/blog/tags/mllm#对齐">​</a></h3>
<p>主要是对比学习：文档/图片/字幕...</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="噪声管理">噪声管理<a class="hash-link" aria-label="Direct link to 噪声管理" title="Direct link to 噪声管理" href="/blog/tags/mllm#噪声管理">​</a></h3>
<p>RagVL 噪声注入训练，数据级别加负样本，token级别加Gauss噪声</p>
<p>RA-CM3  随机删除查询token做query dropout</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="mrag解决的任务">MRAG解决的任务<a class="hash-link" aria-label="Direct link to MRAG解决的任务" title="Direct link to MRAG解决的任务" href="/blog/tags/mllm#mrag解决的任务">​</a></h2>
<ul>
<li>图像字幕</li>
<li>QA</li>
<li>事实验证</li>
<li>视觉叙事连贯性</li>
<li>图文检索</li>
<li>.....</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="未来方向">未来方向<a class="hash-link" aria-label="Direct link to 未来方向" title="Direct link to 未来方向" href="/blog/tags/mllm#未来方向">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="泛化">泛化<a class="hash-link" aria-label="Direct link to 泛化" title="Direct link to 泛化" href="/blog/tags/mllm#泛化">​</a></h3>
<ul>
<li>
<p>领域自适应</p>
</li>
<li>
<p>模态偏差，过度依赖文本</p>
</li>
<li>
<p>可解释性</p>
</li>
<li>
<p>引用来源归属，在视觉/语音等模块更严重，难以识别出对应的小区域</p>
</li>
<li>
<p>多模态的对抗性扰动，误导性信息</p>
</li>
</ul>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="推理">推理<a class="hash-link" aria-label="Direct link to 推理" title="Direct link to 推理" href="/blog/tags/mllm#推理">​</a></h3>
<p>多模态融入KG</p>
<p>如何进行实体感知检索</p>
<p>位置敏感性</p>
<p>冗余检索</p>
<p>具身智能</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="长上下文效率可拓展">长上下文，效率，可拓展<a class="hash-link" aria-label="Direct link to 长上下文，效率，可拓展" title="Direct link to 长上下文，效率，可拓展" href="/blog/tags/mllm#长上下文效率可拓展">​</a></h3>
<ul>
<li>带图像的多页文档</li>
<li>视频这种超长上下文</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mllm">mllm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ai">ai</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/llm">llm</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/精读 AAAI 2025 Fit and Prune Fast and Training-free Visual Token Pruning for Multi-modal Large Language Models">Paper reading - Fit and Prune Fast and Training-free Visual Token Pruning for Multi-modal Large Language Models</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-06-02T00:00:00.000Z">June 2, 2025</time> · <!-- -->10 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div class="markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="任务">任务<a class="hash-link" aria-label="Direct link to 任务" title="Direct link to 任务" href="/blog/tags/mllm#任务">​</a></h2>
<p>当前MLLM依赖于<strong>大量的视觉token</strong>做出高精度的视觉推理，例如LLaVa使用576 image patches as visual tokens，这相较于纯文本带来了<strong>6.2</strong>倍的计算时长开销。此外，一些其他工作正在使用提高图像分辨率的方法来缓解MLLM的视觉缺陷，但<strong>进一步加剧了计算量</strong>。</p>
<p>作者想要得到一种方法来在MLLM的<strong>图像token输入</strong>中，进行压缩，从而进行<strong>推理时的加速</strong>，且不能太影响下游任务精度。</p>
<p>同时，作者认为先前的方法依赖于大量的实验来确定超参数，他提出的方法需要具有一定的<strong>泛化能力</strong>，并且<strong>超参数确认简单</strong> <code>can be obtained in about 5 minutes for all VL tasks</code></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="motivation">motivation<a class="hash-link" aria-label="Direct link to motivation" title="Direct link to motivation" href="/blog/tags/mllm#motivation">​</a></h2>
<ol>
<li>大规模视觉token在MLLM中的存在明显的冗余，MLLMs 的多头注意力机制是单向的，而非真正“全局”的。简而言之，MLLMs 仅将信息从前一个标记传递到后一个标记，其视觉标记通常置于文本问题之前。在这种情况下，它们主要作用是为文本标记提供视觉语义，但实际上其中大部分并未被激活。</li>
</ol>
<p><img decoding="async" loading="lazy" src="https://pic4.zhimg.com/v2-8df5d0c2852ba56e89010c2fe91b9bb9_1440w.jpg" alt="img" class="img_ev3q"></p>
<hr>
<p>如图，大部分蓝色部分（不相关语义）实际上几乎不参加推理，图像到文本注意力非常集中。</p>
<p><img decoding="async" loading="lazy" alt="image-20250527131819120" src="/assets/images/image-20250527131819120-c14d369820575726608d4915d598be9a.png" width="813" height="618" class="img_ev3q"></p>
<hr>
<ol start="2">
<li>作者将确定压缩比例这一超参数的问题转换成一个统计问题。将压缩问题转换为这样的问题：<strong>给定一个采样样本集合</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span>, 再给定一个计算开销<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span> ，设压缩策略为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>， 目标是找到<strong>一个压缩比够大</strong>（满足计算开销到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>以下）的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>，<strong>使得在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span>上整体的注意力分布变化最小</strong></li>
</ol>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="方法">方法<a class="hash-link" aria-label="Direct link to 方法" title="Direct link to 方法" href="/blog/tags/mllm#方法">​</a></h2>
<p><strong>作者只对多头注意力层进行修剪</strong></p>
<p><img decoding="async" loading="lazy" alt="image-20250527155650905" src="/assets/images/image-20250527155650905-1e815d1abeb04e6857086fe406cca405.png" width="1609" height="741" class="img_ev3q"></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="得到修剪策略">得到修剪策略<a class="hash-link" aria-label="Direct link to 得到修剪策略" title="Direct link to 得到修剪策略" href="/blog/tags/mllm#得到修剪策略">​</a></h2>
<p>对于采样样本集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span>, 计算每一层的视觉token自注意力和视觉-文本交叉注意力。假设视觉token数N，文本token数M，第i层的第j个视觉token的平均注意力为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mrow><mi>s</mi><mo separator="true">,</mo><mi>c</mi></mrow><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msubsup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msubsup><mi>A</mi><mrow><mi>m</mi><mo separator="true">,</mo><mi>j</mi></mrow><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">a_{s,c}^{i,j}=\sum_{m=1}^{N}A_{m,j}^{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078em;vertical-align:-0.3831em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8247em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">c</span></span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.376em;vertical-align:-0.3948em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8247em"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em"><span></span></span></span></span></span></span></span></span></span>, s和c分别代表自注意和交叉注意，A代表是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span>上取的平均</p>
<p>移除策略P可以建模成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msubsup><mi>t</mi><mn>1</mn><mo>∗</mo></msubsup><mo separator="true">,</mo><msubsup><mi>t</mi><mn>2</mn><mo>∗</mo></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>t</mi><mi>k</mi><mo>∗</mo></msubsup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_1^*, t_2^*,...t_k^*]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0331em;vertical-align:-0.2831em"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> (假设模型有k层)</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>t</mi><mi>i</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">t_i^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.2587em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em"><span></span></span></span></span></span></span></span></span></span>表示在<strong>第i层新移除的token数量</strong>，注意前面层移除的token也不会传递给后面层，也就是说移除的总数是单调增的</p>
<p>采用一个注意力相差阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>和计算开销<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>两者一起控制裁剪，具体来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>是提前给定的，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>是二分查找计算出来的值</p>
<hr>
<p><img decoding="async" loading="lazy" alt="height:600 width:500" src="/assets/images/image-20250527153710785-90079defd43229432666e6978e287317.png" width="746" height="932" class="img_ev3q"></p>
<hr>
<p>用通俗的话翻译就是:</p>
<ol>
<li>将注意力分布的差别简化为平均每个token的自注意力/交叉注意力<strong>之和</strong>的差别，即是否删除某个token，注意力和的<strong>相对变化</strong>需要小于阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span></li>
<li>由于只计算和，所以可以对自注意力、交叉注意力两个集合分别按照大小排序 —— 注意力分布变化最小的保证转化为，总是优先考虑删除注意力最小的token</li>
<li>给定一个阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>, 对于每一层遍历，对于自注意力、交叉注意力分别不断尝试删除token，直到注意力变化达到阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>, 而这一层最后的策略P，即token删除数量为自注意力删除集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>和交叉注意力集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>的<strong>交集的大小</strong></li>
<li>现在有了一个删除策略<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>, 计算它是否满足计算开销约束（文中并没有具体说是怎么计算的，应该是根据模型的删除后token和参数量估算FLOPS，或者是某种直接测量计算量的工具，用的显卡是单张A100）</li>
</ol>
<hr>
<ol start="5">
<li>
<p>如果满足，说明删除策略<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>是可行的，但说不定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>太大删除太多了，需要调  小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>；如果不满足，说明删除策略<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>不可行，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>太小了，需要调大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>。因此，二分查找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>直到找到一个满足计算开销约束的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>，且这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>的左右区间长度小于阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">ϵ</span></span></span></span>(后文实验是0.01)，则这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>对应的删除策略<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>就是最终的删除策略。</p>
</li>
<li>
<p>最后效果是在满足计算开销约束<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span></span></span></span>的情况下，尽可能保留更多的视觉token</p>
</li>
</ol>
<hr>
<p>关于这样的算法最后带来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>−</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\delta - \alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.03785em">δ</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>关系，作者附了这么一个曲线</p>
<p><img decoding="async" loading="lazy" alt="image-20250527162141135" src="/assets/images/image-20250527162141135-8bdddf8722d17a88c421e695dc843834.png" width="534" height="458" class="img_ev3q"></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="根据策略在推理时  修剪">根据策略在推理时修剪<a class="hash-link" aria-label="Direct link to 根据策略在推理时修剪" title="Direct link to 根据策略在推理时修剪" href="/blog/tags/mllm#根据策略在推理时修剪">​</a></h2>
<p>在实际推理时，作者将得到的删除策略<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>应用到模型中。具体来说，对于每一层的视觉token，按照<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span>中给定的删除数量进行修剪。</p>
<p>具体删除哪些token呢？作者的方法是，</p>
<p>对于第i层</p>
<p>计算第i层<strong>剩余</strong>视觉token j的自注意力和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">a_s^{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0717em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8247em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span></span></span></span>和交叉注意力和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">a_c^{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0717em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8247em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span></span></span></span>，然后将这两个和的<strong>乘积</strong>作为用于排序的参考，排序之后<strong>去除</strong>最小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span>个token（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span>是删除数量）</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="实验结果">实验结果<a class="hash-link" aria-label="Direct link to 实验结果" title="Direct link to 实验结果" href="/blog/tags/mllm#实验结果">​</a></h2>
<p>作者使用 LLaVA-655k 数据集（Liu et al. 2023b）中的 655 个样本（0.1%）来生成剪枝策略</p>
<p>在LLaVA, LLaVA-HR,LLaVA-NEXT三个具有不同大小的视觉token（7B模型，576，1024，2880 tokens）的模型上进行测试，十余个下游任务数据集上进行测试</p>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250527160437182" src="/assets/images/image-20250527160437182-35bb2b550fd308086647c96c255c4f7b.png" width="1789" height="979" class="img_ev3q"></p>
<hr>
<p>可以看到，剪枝之后，在保持准确率几乎不下降的情况下， 能够带来计算量的大幅下降</p>
<p>作者还做了其他几组实验</p>
<ol>
<li>
<p><strong>视觉冗余在不同层级的变化</strong></p>
<p>采用在不同层级上，随  机删除裁剪视觉Token的方法。作者发现，深层次token的冗余度更高，裁剪深层次token几乎不影响准确度，可视化图也表明深层次的注意力几乎集中在最关键的元素中。但具体到每一层的最佳剪枝比例，层间也有比较大的不同</p>
</li>
</ol>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250527161223832" src="/assets/images/image-20250527161223832-a7dedefa5a7d792b5b4df9d98c4c3abb.png" width="916" height="409" class="img_ev3q"></p>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250527161358014" src="/assets/images/image-20250527161358014-df758aa4a01ac89ba28d6406b516bf03.png" width="689" height="509" class="img_ev3q"></p>
<hr>
<ol start="2">
<li>
<p><strong>与baseline的对比</strong></p>
<p>对比了FastV和ToMe两种裁剪方法，表明了自身的SOTA性质。同时指出，在裁剪程度低的时候大家都差不多，裁剪程度高的时候才显露方法的性能差距</p>
<p><img decoding="async" loading="lazy" alt="image-20250527161538762" src="/assets/images/image-20250527161538762-cf4680fadb2324a68d23a06ed98d886e.png" width="1783" height="806" class="img_ev3q"></p>
</li>
</ol>
<hr>
<ol start="3">
<li>
<p><strong>样本数量的消融实验</strong></p>
<p>作者将&quot;LLaVA-655k 数据集（Liu et al. 2023b）中的 655 个样本（0.1%）来生成剪枝策略&quot; 换成1%的数据，发现性能相当。<strong>作者进一步推测MLLM层间信息交换的模式可能更多地依赖于模型本身的特性</strong>，而在不同的输入样本上有较高的泛化性，FitPrune 方法可以有效地捕捉这种模式。同时下面的表还表明，这个方法有着很强的少样本泛化性，确实是模型的特性而不是样本数据集的特性，在仅有10个样本的时候也能得到非常优秀的策略</p>
</li>
</ol>
<p><img decoding="async" loading="lazy" alt="image-20250527162201012" src="/assets/images/image-20250527162201012-c5d2cddb5c89b8435daf12cf36c90db6.png" width="632" height="316" class="img_ev3q"></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="结论">结论<a class="hash-link" aria-label="Direct link to 结论" title="Direct link to 结论" href="/blog/tags/mllm#结论">​</a></h2>
<p>作者介绍了一种FitPrune的无训练方法，用于对 MLLMs 进行视觉标记剪枝。通过将标记剪枝问题表述为一个统计问题，FitPrune 旨在最小化注意力分布的偏差，从而实现冗余视觉token的高效剪枝，进而提高计算效率。FitPrune 能够基于少量数据生成最优的剪枝策略，避免了昂贵的手动试验。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mllm">mllm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ai">ai</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/llm">llm</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/精读：Eagle Exploring The Design Space for Multi- modal LLMs with Mixture of Encoders">Paper reading-Eagle Exploring The Design Space for Multi- modal LLMs with Mixture of Encoders</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-06-02T00:00:00.000Z">June 2, 2025</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div class="markdown"><p>nvidia的论文, 主要还是实践训练MLLM上的一堆经验</p>
<hr>
<h1>任务</h1>
<p>探究通过使用<strong>不同的视觉编码器和分辨率</strong>来提高MLLM系统性能的不同设计带来的效果</p>
<hr>
<h1>motivation</h1>
<ol>
<li>解读<strong>高分辨率的精细视觉信息</strong>是MLLM重要的课题，常用的CLIP-ViT 预训练时候的分辨率只有如224*224或者336*336，<strong>对OCR等细粒度信息不够好</strong></li>
<li>近期研究发现<code>enhanced visual perception</code>显著减少幻觉和提高性能，许多近期MLLM用了混合视觉编码器<!-- -->
<ul>
<li>有扩大视觉编码器的预训练量和参数的</li>
<li>有将高分辨率编码器和CLIP融合的</li>
<li>也有更复杂的融合和路由，根据任务选用不同编码器，&quot;视觉MoE&quot;的</li>
</ul>
</li>
<li>但缺乏对此类方法设计的通用考量, 以及综合性的大benchmark</li>
</ol>
<hr>
<h1>方法</h1>
<ol>
<li>对<strong>不同的视觉编码器</strong>进行<strong>基准测试</strong>，寻找更<strong>高分辨率自适应</strong>的方案</li>
<li>对<strong>不同的视觉编码器混合策略</strong>做同类比较(论文将近期的混合策略归为了CC,SA,LH等几类)</li>
<li>寻找多个视觉编码器的<strong>最优组合</strong></li>
<li>改进<strong>pre-alignment</strong>和数据混合</li>
</ol>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="增加输入分辨率的做法">增加输入分辨率的做法<a class="hash-link" aria-label="Direct link to 增加输入分辨率的做法" title="Direct link to 增加输入分辨率的做法" href="/blog/tags/mllm#增加输入分辨率的做法">​</a></h2>
<ul>
<li>Tiling 将输入分割为子图，CLIP-ViT单独编码</li>
<li>直接放大输入分辨率，并对位置编码进行进行插值</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="eagle做的实验">Eagle做的实验：<a class="hash-link" aria-label="Direct link to Eagle做的实验：" title="Direct link to Eagle做的实验：" href="/blog/tags/mllm#eagle做的实验">​</a></h2>
<p>预训练，LLaVA-1.5 + CLIP 基础模型，和LLaVA相同的 595k 图文对，<strong>冻结整个模型，只训练projection layer</strong></p>
<p>SFT： 1809k 多模态对话数据</p>
<p>评估：11个任务，包含VQA任务， OCR/文档/图表理解，视觉中心任务，基于知识的任务</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="结果---strong-clip">结果 - Strong CLIP<a class="hash-link" aria-label="Direct link to 结果 - Strong CLIP" title="Direct link to 结果 - Strong CLIP" href="/blog/tags/mllm#结果---strong-clip">​</a></h2>
<ol>
<li>
<p><strong>如果插值，需要unfrozen视觉编码器，否则损害性能</strong>。这个结论和以前实验不同。</p>
</li>
<li>
<p>输入分辨率和预训练分辨率差越大，插值越掉点</p>
</li>
<li>
<p>672分辨率下，插值和子图方法性能差不多，但是考虑效率的话还是插值更好</p>
</li>
<li>
<p>进行分辨率adaption，300M的CLIP-ViT性能接近6B的InternVL</p>
</li>
</ol>
<p><strong>按照下表，nvidia着重提了448*448+解锁视觉编码器的方案，300M就达到非常接近SOTA的性能了。</strong></p>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250601233933871" src="/assets/images/image-20250601233933871-a091334ceb9515da01d836fd92b8ea12.png" width="1166" height="592" class="img_ev3q"></p>
<hr>
<h1>Vision Encoder</h1>
<p>选取了以下的encoder</p>
<ul>
<li>
<p>视觉语言对比学习的视觉Encoder，比如CLIP的ViT和OpenCLIP的ConxNeXt；</p>
</li>
<li>
<p>以目标检测为中心的任务预训练的视觉Encoder，EVA-02</p>
</li>
<li>
<p>OCR上训练的Pix2Struct</p>
</li>
<li>
<p>分割上预训练的SAM</p>
</li>
<li>
<p>自监督训练的DINO-V2</p>
</li>
</ul>
<p>对不同预训练的视觉encoder输出的特征图进行resize和插值，使得视觉token数量相同.</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="结果">结果：<a class="hash-link" aria-label="Direct link to 结果：" title="Direct link to 结果：" href="/blog/tags/mllm#结果">​</a></h2>
<p><img decoding="async" loading="lazy" alt="image-20250601234936395" src="/assets/images/image-20250601234936395-09f01aa111506ba3b9c5c12a40b0d2e0.png" width="1136" height="643" class="img_ev3q"></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="分析">分析：<a class="hash-link" aria-label="Direct link to 分析：" title="Direct link to 分析：" href="/blog/tags/mllm#分析">​</a></h2>
<ul>
<li>在freeze的情况下他们通常能<strong>在和自己预训练任务相近的MLLM benchmark上实现最佳性能</strong>。例如来自CLIP的ConvNeXt进行了图文对齐，因此在TextVQA、SQA任务上时所有编码器里表现的最好的。而Text Recognition任务上训练所得的Pix2Struct视觉编码器，在OCR任务上是表现的最好的。</li>
<li>当跟随CLIP-ViT高分辨率拓展策略，<strong>unfreeze视觉编码器时，基本都能有性能提升</strong>，也有反超对应domain上训练的视觉编码器的可能性，例如CLIP-ConvNeXt微调后在OCR上性能超过了Pix2Struct。</li>
</ul>
<hr>
<h1>融合策略：</h1>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2408.15998v2/x2.png" alt="Refer to caption" class="img_ev3q"></p>
<hr>
<ul>
<li>序列维度拼接：SA sequence append</li>
<li>通道维度拼接：CC concat channel</li>
<li>LLAVA-HR式：LH 将高分辨率特征使用adapter注入低分辨率特征中，维持序列长度、通道维度不变</li>
<li>Mini-Gemini式：MG 将高分辨率特征使用local windows cross attention注入到低分辨率的queries中。</li>
<li>Deformable Attention式：DA 将MG的local windows变成了Deformable Attention</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="结果-1">结果：<a class="hash-link" aria-label="Direct link to 结果：" title="Direct link to 结果：" href="/blog/tags/mllm#结果-1">​</a></h2>
<p><img decoding="async" loading="lazy" alt="image-20250601235208565" src="/assets/images/image-20250601235208565-66c205343b77aadcdafb4b386a8db120.png" width="947" height="415" class="img_ev3q"></p>
<ul>
<li>
<p>融合策略越复杂，性能的提升似乎越差，<strong>简单的SA/CC稳定涨点</strong></p>
</li>
<li>
<p>由于SA需要处理边长的序列长度，所以后面用CC</p>
</li>
</ul>
<hr>
<h1>Pre-Alignment</h1>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2408.15998v2/x3.png" alt="Refer to caption" class="img_ev3q"></p>
<p>考虑对其他的视觉专家进行预先的文本模态对齐，再学会去融合不同视觉专家的特征。因此在目前的两阶段MLLM训练框架之前，添加了一个vision-language pre-alignment training阶段，首先使用next-token prediction监督每个视觉专家的特征+各自<strong>单独的</strong>projector（与LLaVA原始预训练策略不同）训练，让其与一个冻结的较小语言模型对齐。</p>
<hr>
<ul>
<li><strong>进行一个额外的预先对齐，可以比较好提升MLLM性能。</strong></li>
<li>预对齐后，再合并所有的视觉专家，训练projector和encoder</li>
<li>虽然在 SFT 期间解冻视觉专家有助于通过更新视觉专家以适应语言模型来提高性能，但<em>预对齐</em>策略更有效地减轻了每位视觉专家的固有偏差，并稳定了训练过程，从而提高了整体性能 （<strong>unfreeze + pre-align效果加性</strong>）</li>
</ul>
<hr>
<h1>Fusion choice</h1>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2408.15998v2/x4.png" alt="w h:600" class="img_ev3q"></p>
<hr>
<p>采用上述的3阶段训练和最好最简单的Channel concat策略，就可以进一步研究哪种视觉编码器组合最好。组合的策略是依次增加模型视觉编码器的数量，每次的选择基于上一个数量下最好的组合进行进一步添加。<strong>四到五个编码器（X4, X5）目前看来就已经比较合适了。</strong></p>
<p>最佳组合是 <em>CLIP</em> 、 <em>ConvNeXt</em> 、 <em>SAM</em> 、 <em>Pix2Struct</em> 和 <em>EVA-02</em></p>
<hr>
<h1>最终和benchmark的比较</h1>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2408.15998v2/x1.png" alt="Refer to caption" class="img_ev3q"></p>
<hr>
<h1>高分辨率的文档任务的展示: 红色baseline失败，蓝色eagle成功</h1>
<p><img decoding="async" loading="lazy" src="https://arxiv.org/html/2408.15998v2/x5.png" alt="h:600" class="img_ev3q"></p>
<hr>
<h1>结论</h1>
<ol>
<li>MLLM训练期间<strong>解锁视觉编码器</strong>matters</li>
<li>设计<strong>先进的融合策略并不能较简单的通道级联显露优势</strong></li>
<li>更多的视觉专家<strong>MoE能带来持续增益</strong>，是增强MLLM能力的有效途径</li>
<li>视觉专家如果开始时候设计的任务和文本无关（没有对齐），用<strong>冻结的LLM进行预对齐</strong>（+解锁）后再整体训练能显著提升性能</li>
</ol></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/llm">llm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ai">ai</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mllm">mllm</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/精读  Interleaved Scene Graph for Interleaved Text-and-Image Generation Assessment">Paper reading - Interleaved Scene Graph for Interleaved Text-and-Image Generation Assessment</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-05-30T00:00:00.000Z">May 30, 2025</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div class="markdown"><p>开发了一个<strong>交错文本和图像生成综合评估框架</strong>ISG</p>
<p>使用<code>scene graph</code>捕获文本和图像的关系，提供四个级别的评估：整体的、结构性的、块级别和特定于图像的，并引入了一个新benchmark，ISG-BENCH</p>
<p>作者实验认  为现有模型在端到端生成文本图像交错内容时，效果不好，于是做了一个Agent来完成这个任务</p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="motivation">motivation<a class="hash-link" aria-label="Direct link to motivation" title="Direct link to motivation" href="/blog/tags/mllm#motivation">​</a></h3>
<p><img decoding="async" loading="lazy" alt="image-20250530152606364" src="/assets/images/image-20250530152606364-d9605f8fed7f263b463ed75398a8cf8a.png" width="990" height="433" class="img_ev3q"></p>
<p>如图，现有MLLM<strong>不能直接生成交错文本和图像内容</strong>，需要将生成图像部分交给SD等外部模型再组合，带来了更大的开销与不一致性</p>
<hr>
<p>为了专注这一任务，作者的Benchmark优先考虑视觉为中心的任务，例如风格迁移等图像输出的特定要求。</p>
<ul>
<li>作者的数据集和人工标注比较有<strong>较高Pearson相似度，以此说明准确性</strong></li>
<li>作者表示先前没什么<strong>benchmark主要以视觉为中心，以此说明新颖度</strong></li>
<li>但有一说一，作者的表还是有点不公平的，例如它自己的<strong>sample很少</strong>(一千多)，同时评估级别是自己提出的这个四级别评估</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="作者的表">作者的表<a class="hash-link" aria-label="Direct link to 作者的表" title="Direct link to 作者的表" href="/blog/tags/mllm#作者的表">​</a></h2>
<p><img decoding="async" loading="lazy" alt="image-20250530160048840" src="/assets/images/image-20250530160048840-646ee93968c80f9867ea0f316414a5a5.png" width="1052" height="362" class="img_ev3q"></p>
<hr>
<h1>方法</h1>
<p><img decoding="async" loading="lazy" alt="image-20250530153213139 h:500" src="/assets/images/image-20250530153213139-4ceb43c19d4bcc07cdc1baeb75d2408b.png" width="1151" height="576" class="img_ev3q"></p>
<p>注意点: <strong>中间看起来很复杂, 实际上是很多组prompt  完成的</strong></p>
<hr>
<p>评估框架将query拆成scene-graph-like structure，<strong>其中图文作为节点，而它们的关系作为边</strong></p>
<p>在整体，结构，块和图四级别的评估中，每个级别都会生成一些用于评估的QA对。作者的意图是，<strong>让整体和结构评估连贯性和整体质量，块和图像评估指令完成的细节</strong></p>
<hr>
<p>结构性：用一个LLM预估图文交替内容的结构，然后与实际生成的内容进行比较</p>
<p><img decoding="async" loading="lazy" alt="image-20250530163448151" src="/assets/images/image-20250530163448151-71150c0f60bd09aee45e9107edd3eaa7.png" width="1060" height="523" class="img_ev3q"></p>
<hr>
<p>整体：MLLM-as-a-Judge和CoT，用1-10打分配合Yes/No判断</p>
<p>块： 将prompt P用LLM表示成三元组 （subj, obj, rel）,再用LLM生成问题，并用VQA评估</p>
<p><img decoding="async" loading="lazy" alt="image-20250530163519317" src="/assets/images/image-20250530163519317-1ba26e8e2cd40c56119403af2ba7b9b9.png" width="1047" height="770" class="img_ev3q"></p>
<hr>
<p>图像：从prompt 给的图像中用LLM抽出三元组关系和实体，判断query类别，根据类别不同使用不同的prompt产生判断的VQA，例如如果是&quot;How to&quot;，则需要包含特定实体，如果是“Painting”，则需要图像的准确生成</p>
<p><img decoding="async" loading="lazy" alt="image-20250530163331400 h:600" src="/assets/images/image-20250530163331400-1b1c3b6298aa1e9aad449957c2e03fd3.png" width="1039" height="679" class="img_ev3q"></p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="实验结果">实验结果<a class="hash-link" aria-label="Direct link to 实验结果" title="Direct link to 实验结果" href="/blog/tags/mllm#实验结果">​</a></h3>
<blockquote>
<p>所有统一模型在按照说明生成交错文本和图像内容方面都存在重大缺陷。许多模型只生成 1 到 3 张图像，而有些模型根本无法生成任何图像。</p>
</blockquote>
<blockquote>
<p>整体评估结果与三个细粒度级别的评估结果之间的不一致表明，即使同时提供用户指示和正确的黄金答案，MLLM-as-a-Judge 在全面评估回答方面也存在显着局限性。具体来说，Judge MLLM 努力根据细粒度的标准评估响应，例如输出结构（包括图像数量）和提示中规定的详细文本-图像关系。此外，我们对结果的分析揭示了 <strong>MLLM-as-a-Judge 中固有的偏见</strong>，即“图像质量偏见”，即<strong>具有更高质量图像内容的回答始终获得更高的分数，尽管这些回答可能违反用户的指导要求和评判指南</strong>。这种偏见表明，即使获得了黄金答案，MLLM-as-a-Judge 仍然无法正确地对符合指定要求的交错回答进行准确评估。</p>
</blockquote>
<hr>
<p><img decoding="async" loading="lazy" alt="image-20250530160948640" src="/assets/images/image-20250530160948640-8a5505eaeadfe2ed274a09937abf96eb.png" width="1200" height="519" class="img_ev3q"></p>
<hr>
<h1>效果展示: 跑一次它这个Benchmark要60美刀</h1>
<p><img decoding="async" loading="lazy" alt="image-20250530163815015 h:600" src="/assets/images/image-20250530163815015-79e642937f498c3c9f5bde75cd8d23e3.png" width="1051" height="1016" class="img_ev3q"></p>
<hr>
<h1>结论</h1>
<ol>
<li>MLLM-as-a-judge存在图像质量bias</li>
<li>现有端到端MLLM生成图文内容效果不佳, 可能需要在工程性上的agent做补救</li>
</ol></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mllm">mllm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ai">ai</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/llm">llm</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">notes</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/RL">课程笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/personal-essays">Personal Essays</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Ayanami, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>