<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">system-design-interview笔记 | Ayanami&#x27;s Cave</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ayanami1314.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ayanami1314.github.io/blog/系统架构设计笔记"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="system-design-interview笔记 | Ayanami&#x27;s Cave"><meta data-rh="true" name="description" content="限流器"><meta data-rh="true" property="og:description" content="限流器"><meta data-rh="true" name="keywords" content="系统架构,架构设计"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2025-01-19T06:37:33.783Z"><meta data-rh="true" property="article:tag" content="架构设计"><link data-rh="true" rel="icon" href="/img/ayanami.jpg"><link data-rh="true" rel="canonical" href="https://ayanami1314.github.io/blog/系统架构设计笔记"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/系统架构设计笔记" hreflang="en"><link data-rh="true" rel="alternate" href="https://ayanami1314.github.io/blog/系统架构设计笔记" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://ayanami1314.github.io/blog/系统架构设计笔记","mainEntityOfPage":"https://ayanami1314.github.io/blog/系统架构设计笔记","url":"https://ayanami1314.github.io/blog/系统架构设计笔记","headline":"system-design-interview笔记","name":"system-design-interview笔记","description":"限流器","datePublished":"2025-01-19T06:37:33.783Z","author":{"@type":"Person","name":"ayanami"},"keywords":["系统架构","架构设计"],"isPartOf":{"@type":"Blog","@id":"https://ayanami1314.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Ayanami&#39;s Cave Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/personal-essays/rss.xml" title="Ayanami&#39;s Cave RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/personal-essays/atom.xml" title="Ayanami&#39;s Cave Atom Feed">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.00dd3480.css">
<script src="/assets/js/runtime~main.3d7b1b16.js" defer="defer"></script>
<script src="/assets/js/main.740f58ee.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Ayanami&#x27;s Cave</b></a><a class="navbar__item navbar__link" href="/docs/Chcore源码阅读/">课程笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">技术博客</a><a class="navbar__item navbar__link" href="/personal-essays">个人随笔</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/local-llm">来本地部署大模型!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os-虚拟化">NJU操作系统(jyy OS)课程笔记-虚拟化部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs186-database-WIP">ucb cs186 课程笔记(更新中)</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/系统架构设计笔记">system-design-interview笔记</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ostep-chapter42-44">ostep阅读笔记：单机fs的崩溃一致性(chapter42-44)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/JUC">JUC</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs144 labs">cs144 labs(Winter 2024)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/jyy-os：并发">NJU操作系统(jyy OS)课程笔记-并发部分</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/nginx">nginx基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cs144/cs144 lec notes">CS144 Lecture Notes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/django-mosh">Django_mosh</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/splay-tree">splay tree</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/xv6book-notes">xv6book Notes(C1-4)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Go-Gin学习">Go,Gin学习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/godis源码阅读">godis源码阅读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/hibernate-jpa">hibernate&amp;jpa</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/linking-复习">linking 复习</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/ts基础">ts基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/实战2-mosh-gamehub">react practice:mosh gamehub</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/浅入理解断点和调试器">浅入理解断点和调试器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/黑马点评">黑马点评(速通版)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/js基础">js基础</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/11-14-11-26学习双周记">11-14-11-26学习双周记</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">system-design-interview笔记</h1><div class="container_mt6G margin-vert--md"><time datetime="2025-01-19T06:37:33.783Z">January 19, 2025</time> · <!-- -->27 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro"><div class="avatar__name"><span>ayanami</span></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><h3 class="anchor anchorWithStickyNavbar_LWe7" id="限流器">限流器<a class="hash-link" aria-label="Direct link to 限流器" title="Direct link to 限流器" href="/blog/系统架构设计笔记#限流器">​</a></h3>
<ul>
<li>
<p>放在哪里?</p>
<ul>
<li>客户端, 容易被伪造绕过</li>
<li>服务端应用代码, 灵活性高, 但占据工程资源</li>
<li>云上微服务, api网关等, 灵活性低</li>
</ul>
</li>
<li>
<p>经典算法:</p>
<ul>
<li>
<p>令牌桶: 固定速率产生令牌, 每个请求消耗令牌</p>
<ul>
<li>pros: 容易实现, 内存占用少, 允许突发流量</li>
<li>cons: 调参困难, 可能需要不断填充桶</li>
</ul>
</li>
<li>
<p>漏桶: 请求进入一个定长FIFO队列, server给定速度从队列取数据处理</p>
<ul>
<li>pros: 容易实现, 内存占用少, 请求以固定速率处理</li>
<li>cons: 突发请求占据队列使得新请求得不到处理, 调参困难,可能需要不断填充桶</li>
</ul>
</li>
<li>
<p>固定窗口计数器: 每一个给定时间窗口进行计数,例如每分钟100个请求</p>
<ul>
<li>pros: 容易实现, 内存占用少</li>
<li>cons: 突发请求可以达到两倍限制的QPS(在窗口边缘有突刺)</li>
</ul>
</li>
<li>
<p>滑动窗口日志: 记录请求时间戳, 数据保存在redis等缓存,每当新请求进来的时候把过时时间戳删除, 如果请求时间戳比时间窗口的最低值还低, 拒绝请求</p>
<ul>
<li>pros: 速率限制准确</li>
<li>cons: 内存开销  大, 需要存储多个时间戳</li>
</ul>
</li>
<li>
<p>滑动窗口计数器: 某时刻限制请求数 = 窗口上限 - 上一个窗口请求数 * 这一个窗口的和上一个窗口的重叠百分比。例如, 窗口为每分钟1000, 上一分钟800, 在这一分钟的30秒时, 限制这一分钟窗口的请求数最多为 1000 - 30 / 60 * 800 = 600</p>
<ul>
<li>
<p>相当于假设上一个窗口的平均速率</p>
</li>
<li>
<p>pros: 平滑了流量峰值, 内存高效(只需要计数)</p>
</li>
<li>
<p>cons: 不太严格, 然而其实可以</p>
<blockquote>
<p>然而，这个问题可能并不像它看起来那么糟糕。 根据Cloudflare[10]所做的实验，在4亿个请求中，只有0.003%的请求被错误地允许或限制速率</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>超过速率限制</strong></p>
<p>如果一个请求被限制了速率，API会向客户端返回一个HTTP响应代码429（请求太多）。根据不同的使用情况，我们可能会将速率受限的请求排队等候以后处理。 例如，如果一些订单由于系统过载而受到速率限制，我们可以保留这些订单以便以后处理。</p>
<p><strong>限流器请求头</strong></p>
<p>一个客户如何知道它是否被节流？客户端如何知道在被节流之前允许的剩余请求的数量？答案就在HTTP响应头中。限流器向客户端返回以下 HTTP 标头：</p>
<ul>
<li>X-Ratelimit-Remaining：窗口内允许请求的剩余数量</li>
<li>X-Ratelimit-limit：它表示客户端在每个时间窗口可以进行多少次调用</li>
<li>X-Ratelimit-Retry-After：等待的秒数，直到你可以再次提出请求而不被节流。</li>
</ul>
<p>当用户发送过多请求时，将向客户端返回 429 too many requests 错误和 X-Ratelimit-Retry-After 标头。</p>
</blockquote>
<ul>
<li>规则被存储在磁盘上。工作者经常从磁盘中提取规则，并将其存储在高速缓存中。</li>
<li>当客户端向服务器发送请求时，该请求  首先被发送到限流中间件。</li>
<li>限流中间件从缓存中加载规则。它从Redis缓存中获取计数器和最后一次请求的时间戳。根据响应，限流器决定：<!-- -->
<ul>
<li>如果请求没有速率限制，它将被转发到API服务器。</li>
<li>如果请求受到速率限制，限流器会向客户端返回 429 too many requests 错误。 同时，请求被丢弃或转发到队列。</li>
</ul>
</li>
</ul>
<p>分布式限流</p>
<p>redis:</p>
<ul>
<li>lua脚本</li>
<li>sorted set每个用户有一个自己的set,试图执行动作时,使用MULTI原子地执行下列操作: <code>ZREMRANGEBYSCORE</code> 删除给定时间间隔前的元素, ZADD 添加当前时间戳, ttl设置为rate limit,计算sorted set的数量,如果超过限额,就失败 (滑动窗口日志)(有一说一我觉得这个如果没有精确的需求不如滑动窗口计数器, 开销感觉有点大)</li>
</ul>
<p>多限流器同步: 用户hash redis集群分配之类, 尽量别做这种事情</p>
<p>其他层级的限流:</p>
<ul>
<li>iptables</li>
<li>...</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一致性hash">一致性hash<a class="hash-link" aria-label="Direct link to 一致性hash" title="Direct link to 一致性hash" href="/blog/系统架构设计笔记#一致性hash">​</a></h3>
<p>基本步骤如下：</p>
<ol>
<li>使用均匀分布的哈希函数将服务器和键映射到环上。</li>
<li>要想知道一个键被映射到哪个服务器，从键的位置顺时针查找，直到找到环上的第一个服务器。</li>
</ol>
<p>步骤是很简单的, 麻烦的是问题</p>
<p>环上服务器分区大小难以保证相同(添加删除服务器)</p>
<p>解决方法: 虚拟节点(分成更小的块)</p>
<p>每个服务器动态地分配小块(虚拟节点), 这样还可以考虑服务器容量自动缩放问题</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一致性模型">一致性模型<a class="hash-link" aria-label="Direct link to 一致性模型" title="Direct link to 一致性模型" href="/blog/系统架构设计笔记#一致性模型">​</a></h3>
<blockquote>
<p>N = 副本数</p>
<p>W = 大小为 W 的规定写入。要将写入操作视为成功，必须从 W 个副本确认写入操作。</p>
<p>R = 大小为 R 的读取规定人数。为了使读取操作被认为是成功的，读取操作必须等待至少R个副本的响应。</p>
<p>如何配置N、W和R以适应我们的使用情况？</p>
<p>下面是一些可能的设置：</p>
<ul>
<li>如果<code>R=1，W=N</code>，系统被优化为快速读取</li>
<li>如果<code>W=1，R=N</code>，系统被优化为快速写入</li>
<li>如果<code>W+R&gt;N</code>，就可以保证强一致性（通常<code>N=3，W=R=2</code>）。</li>
<li>如果<code>W+R&lt;=N</code>，则不能保证强一致性</li>
</ul>
</blockquote>
<p>复制<code>-&gt;</code>高可用<code>-&gt;</code>不一致</p>
<p>发现并解决冲突: 常用是向量时钟 vector clock, 但有几个问题</p>
<ul>
<li>处理冲突逻辑复杂</li>
<li>动态增加删除服务器逻辑复杂</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="https://juejin.cn/post/7205101745936203837" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7205101745936203837</a></li>
<li><a href="https://houbb.github.io/2018/08/31/lock-vector-clock-01" target="_blank" rel="noopener noreferrer">https://houbb.github.io/2018/08/31/lock-vector-clock-01</a></li>
</ul>
<p>实际业界的用例参考Dynamo</p>
<p>算法简介:在每个服务器内部维护一个所有服务器的vector</p>
<ul>
<li>当自己发生事件时,增加<code>vector[self]</code>, 并告诉需要告诉的服务器(<strong>核心就在于不广播, 没有全局时间!当然也因此不保证解决冲突</strong>)</li>
<li>当自己收到A server的事件时, <code>vector[A] += d</code></li>
</ul>
<p>最后想要觉得一个事件的全局顺序的时候, 查看所有的server的vec</p>
<p>如果有一个server的vec是最大的,那么严格有因果关系,取它的值就行</p>
<p>但如果没有最 大的vec, 就需要解决冲突的策略</p>
<p>策略</p>
<ol>
<li>交给客户端, 如dynamo</li>
<li>加上时间戳, <code>vec&#x27; = [...servers, timestamp]</code>冲突取ts最大的</li>
<li>随机取一个</li>
</ol>
<blockquote>
<p>所以向量时钟算法的实质是：</p>
<p>（1）将逻辑上可以合并的冲突成功合并；</p>
<p>（2）逻辑上无法合并的冲突依旧冲突；</p>
</blockquote>
<p>拓展: 向量时钟的剪枝, riak, 牺牲绝对的正确性(false merge)来换取对太长的vec clock的剪枝</p>
<p>gossip 协议 quorom</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="唯一id生成器">唯一ID生成器<a class="hash-link" aria-label="Direct link to 唯一ID生成器" title="Direct link to 唯一ID生成器" href="/blog/系统架构设计笔记#唯一id生成器">​</a></h3>
<ul>
<li>
<p>多主复制: 下一个id += k, k是服务器数量,拓展性差</p>
</li>
<li>
<p>uuid</p>
<ul>
<li>
<p>引自维基百科，&quot;在每秒产生10亿个UUIDs，大约100年后，创造一个重复的概率会达到50%&quot;。</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>
<p>生成 UUID 很简单。服务器之间不需要协调，因此不会有任何同步问题。</p>
</li>
<li>
<p>该系统易于扩展，因为每个 Web 服务器负责生成它们使用的 ID。 ID 生成器可以轻松地与 Web 服务器一起扩展。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>ID 是 128 位长, 空间开销。</li>
<li>ID 不会随时间上升</li>
<li>ID 可以是非数字的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ticket服务器, 在分布式系统之中维持一个唯一的ticket server用于签发id</p>
<ul>
<li>
<p>**优点：**数字 ID，易于实施，适用于中小型应用程序</p>
</li>
<li>
<p>**缺点：**单点故障</p>
</li>
</ul>
</li>
<li>
<p>twitter雪花算法</p>
<ul>
<li><strong>符号位</strong>：1 位，它将始终为 0。这是为将来使用保留的。它可以潜在地用于区分有符号数和无符号数。</li>
<li><strong>时 间戳</strong>：41 位。自纪元或自定义纪元以来的毫秒数。我们使用 Twitter 雪花默认纪元 1288834974657，相当于 2010 年 11 月 4 日 01:42:54 UTC。</li>
<li><strong>数据中心 ID</strong>：5 位，这给了我们 25=3225=32 个数据中心。</li>
<li><strong>机器 ID</strong>：5 位，每个数据中心有 25=3225=32 台机器</li>
<li><strong>序列号：12 位</strong>。<strong>对于在该机器/进程上生成的每个 ID，序列号都会递增 1。该数字每毫秒重置为 0。</strong></li>
</ul>
</li>
</ul>
<p>也就是说雪花在一台机器上1毫秒可以支持4096个新id</p>
<p>额外要点:</p>
<ul>
<li>时钟同步。在我们的设计中，我们假设 ID 生成服务器具有相同的时钟。当服务器在多个内核上运行时，此假设可能不成立。同样的挑战存在于多机场景中。时钟同步的解决方案超出了本书的范围；但是，了解问题的存在很重要。<strong>网络时间协议是这个问题最流行的解决方案。</strong></li>
<li>节段长度调整。例如，较少的序列号但较多的时间戳位对低并发性和长期应用是有效的。</li>
<li>高可用性。由于 ID 生成器是关键任务系统，因此它必须具有高可用性</li>
</ul>
<p>拓展阅读: 网络时间协议</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="短url">短URL<a class="hash-link" aria-label="Direct link to 短URL" title="Direct link to 短URL" href="/blog/系统架构设计笔记#短url">​</a></h3>
<p>点击较短的别名重定向到原始url</p>
<ul>
<li>
<p>URL缩短：给定一个长的URL =&gt; 返回一个短得多的URL</p>
</li>
<li>
<p>URL重定向：给定一个短的URL =&gt; 重定向到原来的URL</p>
</li>
<li>
<p>高可用性、可扩展性和容错考虑</p>
</li>
</ul>
<blockquote>
<p>值得在这里讨论的一件事是 301 重定向与 302 重定向。</p>
<ul>
<li>
<p><strong>301重定向</strong>。301重定向表明，请求的URL被 &quot;永久 &quot;地移到了长URL上。由  于是永久重定向，<strong>浏览器会缓存响应，对同一URL的后续请求将不会被发送到URL缩短服务上</strong>。相反，请求将直接被重定向到长网址服务器。</p>
</li>
<li>
<p><strong>302重定向</strong>。302重定向意味着URL被 &quot;暂时 &quot;移到长URL上，这意味着对同一URL的后续请求将首先被发送到URL缩短服务上。然后，它们会被重定向到长网址服务器。</p>
</li>
</ul>
<p>每种重定向方法都有其优点和缺点。如果优先考虑<strong>减少服务器负载</strong>，使用301重定向是有意义的，因为只有同一URL的第一个请求被发送到URL缩短服务器。然而，如果分析是重要的，302重定向是一个更好的选择，因为它可以更容易地<strong>跟踪点击率和点击的来源。</strong></p>
</blockquote>
<p>一个简单的解决方案 <code>&lt;shortURL, LongURL&gt;</code>的rdbms</p>
<p>假设系统支持3650亿个url=10年 * 每天1亿</p>
<p>可以使用<code>0-9a-zA-Z</code>62个字符， <code>62^n &gt; 3650 亿</code> n = 7</p>
<p>方法1: hash+碰撞解决</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">longURL -&gt; hash -&gt; short -&gt; exist on db?(opt bloomfilter + query) -&gt; save/return/collision</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">collision 的一种解决方法是 longURL -&gt; longURL + predefined string</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>方法2: base62转换</p>
<p>给每一个请求的长url分配一个数字类型的唯一id, 再对唯一id做base62转换</p>
<p>坏处是可能出现安全问题</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">longURL -&gt; in DB ? -&gt; yes,return short</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            -&gt; no, generate new ID -&gt; id to base62 -&gt; save id, longurl, shorturl in db </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>读多于写, 加缓存</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="爬虫系统">爬虫系统<a class="hash-link" aria-label="Direct link to 爬虫系统" title="Direct link to 爬虫系统" href="/blog/系统架构设计笔记#爬虫系统">​</a></h3>
<p>算法侧: 从url seed开始, 将link视为边, 用BFS去爬取不同的网页</p>
<p>架构侧:</p>
<p><code>seed url -&gt; url frontier -&gt; html downloader(DNS resolver) -&gt; content parser -&gt; content seen(重复检测器, 例如 hash, BF) + 存储-&gt; link extractor -&gt; url filter -&gt; url seen -&gt; url storage</code></p>
<p>优先级: 简单的做法是根据Url内容变化的速度(可以基于历史抓取记录)和本身的价值（例如是个人博客还是官方网站）设计一个优先级估价函数, 根据url区分k个工作队列, 保证一个队列内只有一个url（的多个请求）, 这样就可以实现优先级</p>
<p>爬虫需要考虑礼貌性, DDoS</p>
<p>做法是每个url作为一个后端队列, 在优先级的selector出来之后, 维护一张(url,back queue)的表, 将url放到back queue里面去</p>
<p>对每一个url(backqueue), 维护一个时间t, 是下一次抓取的最早时间(例如当前时间+10倍前一次获取时间)</p>
<p>而爬虫线程每次从时间的最小堆之中取出元素, (如需要, 等待到t), 然后爬取</p>
<p>html下载器: Robots 排除协议, 分布式抓取, 超时</p>
<p>其他问题: 冗余内容, 蜘蛛陷阱, 垃圾数据, js-需要动态渲染得到链接和其他数据</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="通知系统">通知系统<a class="hash-link" aria-label="Direct link to 通知系统" title="Direct link to 通知系统" href="/blog/系统架构设计笔记#通知系统">​</a></h3>
<p>删重, 跟踪, 限速, 用户设置(接受哪些通知), 失败时的重试机制, 安全性(客户验证)</p>
<p>推送流：</p>
<p>核心在fan out系统, 读扇出(拉模式)还是写扇出(推模式), 热键问题和速率问题</p>
<p>混合: 对大多数用户使用推送模式。对于名人或有很多朋  友/粉丝的用户，我们让粉丝按需提取信息内容以避免系统过载</p>
<p>get friend IDs: graph DB</p>
<p>fanout service先从graph DB拿到friend ids, 再从用户缓存(用户db)得到朋友相关信息:</p>
<blockquote>
<p>例如，如果你把某人调成静音，她的帖子将不会显示在你的信息流中，尽管你们仍然是朋友。帖子可能不显示的另一个原因是，用户可以有选择地与特定的朋友分享信息或对其他人隐藏信息。</p>
</blockquote>
<p>把更新的需求包成任务(例如<code>&lt;post_id, user_id&gt;</code>)丢到mq</p>
<p>mq入库, 写缓存</p>
<p>缓存层级:</p>
<ul>
<li>
<p>News Feed：它存储了信息的ID。</p>
</li>
<li>
<p>Content：它存储每个帖子的数据。受欢迎的内容被存储在热缓存中。</p>
</li>
<li>
<p>Social Graph：它存储用户关系数据。</p>
</li>
<li>
<p>Action：它存储有关用户是否喜欢帖子、回复帖子或对帖子执行其他操作的信息。</p>
</li>
<li>
<p>Counters：它存储点赞、回复、关注者、关注等的计数器。</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聊天系统">聊天系统<a class="hash-link" aria-label="Direct link to 聊天系统" title="Direct link to 聊天系统" href="/blog/系统架构设计笔记#聊天系统">​</a></h3>
<p>无状态有状态分离</p>
<ul>
<li>
<p>无状态的服务 http</p>
<p>无状态服务是传统的面向公众的请求/响应服务，用于管理登录、注册、用户资料等。这些是许多网站和应用程序中的常见功能。</p>
<p>无状态服务位于负载均衡器后面，其工作是根据请求路径将请求路由到正确的服务。这些服务可以是单体的，也可以是单独的微服务。我们不需要自己建立许多这样的无状态服务，因为市场上有一些服务可以很容易地被集成。</p>
<p>我们将深入讨论的一个服务是服务发现。它的主要工作是给客户提供一个客户可以连接到的聊天服务器的DNS  主机名列表。</p>
</li>
<li>
<p>有状态的服务 websocket</p>
<p>唯一有状态的服务是聊天服务。该服务是有状态的，因为每个客户都与一个聊天服务器保持持久的网络连接。在这个服务中，只要服务器仍然可用，客户通常不会切换到另一个聊天服务器。服务发现与聊天服务密切协调，以避免服务器过载。我们将在深入研究中详细介绍。</p>
</li>
</ul>
<p>服务器的切分:</p>
<ul>
<li>chat server 管理信息的收发</li>
<li>presence server 管理在线/离线状态</li>
<li>api server 处理无状态服务</li>
<li>notification server 推送通知</li>
</ul>
<p>DB选择: KV数据库</p>
<p>为什么？<strong>聊天数据的读写模式</strong></p>
<ul>
<li>数据量巨大 需要水平拓展</li>
<li>只有最近的聊天记录才会被频繁访问</li>
<li>但“最近”里面也不完全是顺序的, 引用, 跳转, 提及等</li>
<li>读写比约为1:1, 读并不远远高于写</li>
</ul>
<p>这样的wkld下kv比关系型的优势:</p>
<ul>
<li>水平拓展轻松</li>
<li>分层架构对热数据容易优化</li>
<li>关系型数据库的index在数据量变大时昂贵</li>
</ul>
<p>消息ID设计:</p>
<p>一对一聊天: 主键message id</p>
<p>群聊: 复合主键 <code>{channel_id, message_id}</code></p>
<p>问题: id用什么?</p>
<p>要求: 唯一性 + 可以按照时间排序</p>
<ul>
<li>自增: 分布式实现困难</li>
<li>全局序列号发生器: 将时间项提前就可以按照时间排序</li>
<li>本地序列号生成器: 只保证消息在一个组内(channel内)唯一, 实现比较简单</li>
</ul>
<p>发送信息的流程</p>
<ol>
<li>用户A向聊天服务器1发送了一条聊天信息。</li>
<li>聊天服务器1从ID生成器获得一个信息ID。</li>
<li>聊天服务器1将消息发送至消息同步队列。</li>
<li>消息被储存在一个键值存储中。</li>
<li>a. 如果用户B在线，信息被转发到用户B所连接的聊天服务器2。</li>
<li>b. 如果用户B处于  离线状态，则从推送通知（PN）服务器发送推送通知。</li>
<li>聊天服务器2将消息转发给用户B，用户B和聊天服务器2之间有一个持久的WebSocket连接。</li>
</ol>
<p>群组聊天:</p>
<p>第一种方法: A发消息, 在每一个成员的收件箱里面复制一个副本, 适用于群组人数较少的时候(例如微信的500人约束); 每个收件人有自己的收件箱(消息同步队列), 所以并不保证一致性</p>
<p>在线状态指示器:</p>
<ul>
<li>naive的做法: 建立连接就在线, 断开就离线。问题在网络波动时候, 变化太快</li>
<li>更优雅的做法, 心跳</li>
<li>推送, 类似微信这种小群(500人限制)可以直接查询实时的ws连接。大群需要懒加载</li>
</ul>
<p>扩展聊天应用程序以支持媒体文件，如照片和视频。媒体文件的大小明显大于文本。压缩、云存储和缩略图是值得讨论的话题。</p>
<ul>
<li>端到端加密。Whatsapp支持信息的端到端加密。只有发件人和收件人可以阅读信息。有兴趣的读者请参考参考资料中的文章[9]。</li>
<li>在客户端缓存信息，可以有效地减少客户端和服务器之间的数据传输。</li>
<li>提高加载时间。Slack建立了一个地理分布的网络来缓存用户的数据、频道等，以获得更好的加载时间[10]。</li>
<li>故障处理。<!-- -->
<ul>
<li>聊天服务器错误。可能有数十万，甚至更多的，坚持不懈的连接到一个聊天服务器。如果一个聊天服务器离线，服务发现（Zookeeper）会提供一个新的聊天服务器，让客户建立新的连接。</li>
<li>消息重发机制。重试和排队是重发消息的常用技术。</li>
</ul>
</li>
</ul>
<p>多媒体支持的大体流程</p>
<ul>
<li>client 通过 rest 将多媒体资源发送到服务器</li>
<li>服务器转换媒体文件(例如图片生成缩略图, 压缩)</li>
<li>服务器存到s3</li>
<li>服务器通过s3链接响应client</li>
<li>客户端再将s3链接通过ws发送(广播)给聊天的其他用户</li>
<li>其他client 收到s3连接, 根据定义的消息类型进行渲染</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单的搜索支持-trie">简单的搜索支持: trie<a class="hash-link" aria-label="Direct link to 简单的搜索支持: trie" title="Direct link to 简单的搜索支持: trie" href="/blog/系统架构设计笔记#简单的搜索支持-trie">​</a></h3>
<p>topK: 先找到前缀, 再遍历子树</p>
<p>问题: 太慢</p>
<p>解决方法:</p>
<ul>
<li>在每个节点缓存常用的前k个查询</li>
<li>控制前缀的最大长度</li>
</ul>
<p>更新trie: 数据搜集, 对于实时应用服务, 短时间间隔; 对于非实时的, 可以例如一周定时更新一次</p>
<p>合法性: 自动完成可以根据hash等过一个filter, 避免补出禁止的网站等</p>
<p>多语言：unicode trie</p>
<p>分片: 可以基于字母, 但是要考虑到频率问题</p>
<p>实时(趋势)搜索: 流式, 领域特定, AI</p>
<p>视频流</p>
<p>核心是分成几个部分, 一部分类似传统的server, 提供视频metadata</p>
<p>另一部分依托云服务和CDN, 做好视频传输和解码编码</p>
<p>其中特定部分的逻辑复杂, 例如解编码的模块化和引擎化, CDN贵所以视频基于历史数据做冷热分离, 冷视频走自建而不是CDN</p>
<p>还有比如错误处理, 数字版权之类</p>
<p><a href="https://learning-guide.gitbook.io/system-design-interview/xi-tong-she-ji-mian-shi-nei-mu-zhi-nan-di-yi-juan/chapter-14-design-youtube" target="_blank" rel="noopener noreferrer">具体好多细节</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="临近服务">临近服务<a class="hash-link" aria-label="Direct link to 临近服务" title="Direct link to 临近服务" href="/blog/系统架构设计笔记#临近服务">​</a></h3>
<p>由于是读远多于写的情况, 所以常见用关系型db</p>
<p>关系型的问题是, 如果是经纬度, 二维数据index利用率低</p>
<p>解决方法是二维转一维再index搜索, 例如geohash, R tree, 四叉树, google s2</p>
<p>geohash: 经纬度网格编码再转base32, 共享前缀越长, 越接近</p>
<p>边界问题: 反过来不成立, 接近的两个地块可能共享前缀并不长(在子午线/赤道等大格子边界), 所以<code>geohash LIKE &#x27;sth%&#x27;</code>检索出来结果不全</p>
<p>方法是不仅检索自己格子的geohash, 也把邻居格子的一起检索</p>
<p>业务问题：范围内部商家不够, 解决方法是放大格子继续检索</p>
<p>google s2: 基于希尔伯特曲线的<code>球面-&gt;1d</code>算法, 保证2d上接近在1d上也接近</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/架构设计">架构设计</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/cs186-database-WIP"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">ucb cs186 课程笔记(更新中)</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/ostep-chapter42-44"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">ostep阅读笔记：单机fs的崩溃一致性(chapter42-44)</div></a></nav><div>Loading Comments...</div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#限流器">限流器</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#一致性hash">一致性hash</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#一致性  模型">一致性模型</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#唯一id生成器">唯一ID生成器</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#短url">短URL</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#爬虫系统">爬虫系统</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#通知系统">通知系统</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#聊天系统">聊天系统</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#简单的搜索支持-trie">简单的搜索支持: trie</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/系统架构设计笔记#临近服务">临近服务</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">notes</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs">课程笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/personal-essays">Personal Essays</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Ayanami, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>