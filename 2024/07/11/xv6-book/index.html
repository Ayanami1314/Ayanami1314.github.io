<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Ayanami">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://ayanami1314.github.io/2024/07/11/xv6-book/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="一些细节和思考： Q: wait for reading the source code and thinking A: after reading the source code and thinking Chapter 1">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6 book">
<meta property="og:url" content="https://ayanami1314.github.io/2024/07/11/xv6-book/index.html">
<meta property="og:site_name" content="Ayanami&#39;s Cave">
<meta property="og:description" content="一些细节和思考： Q: wait for reading the source code and thinking A: after reading the source code and thinking Chapter 1">
<meta property="og:locale">
<meta property="article:published_time" content="2024-07-10T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-11T15:54:52.493Z">
<meta property="article:author" content="Ayanami">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/ayanami.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/ayanami.jpg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/ayanami.jpg">
    <!--- Page Info-->
    
    <title>
        
            xv6 book -
        
        Ayanami&#39;s Cave
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    

    
        
<script src="/js/libs/anime.min.js"></script>

    

    <script id="hexo-configurations">
    window.config = {"hostname":"ayanami1314.github.io","root":"/","language":"zh","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"make code matter, make life better","subtitle":{"text":[],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":"https://github.com/Ayanami1314","instagram":null,"zhihu":"https://www.zhihu.com/people/85-36-64-12","twitter":null,"email":"lingbo_2022@sjtu.edu.cn"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.4","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



    <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        Ayanami&#39;s Cave
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [40,0],
                translateZ: 0,
                opacity: [0,1],
                filter: ['blur(5px)', 'blur(0px)'], // Starting from blurred to unblurred
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i,
            }).add({
                targets: '.ml13 .letter',
                translateY: [0,-40],
                opacity: [1,0],
                filter: ['blur(0px)', 'blur(5px)'], // Ending from unblurred to blurred
                easing: "easeInExpo",
                duration: 1200,
                delay: (el, i) => 100 + 30 * i,
                complete: function() {
                    hidePreloader(); // Call hidePreloader after the animation completes
                }
            });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Ayanami&#39;s Cave
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">27</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">xv6 book</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/ayanami.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Ayanami</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-07-11</span>
        <span class="mobile">2024-07-11</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-07-11 23:54:52</span>
            <span class="mobile">2024-07-11 23:54:52</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>一些细节和思考：</p>
<p>Q: wait for reading the source code and thinking</p>
<p>A: after reading the source code and thinking</p>
<h3 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h3><span id="more"></span>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p>close syscall just “Release the file fd”, don’t really operate on the file itself.</p>
<p>and correspandingly, the open syscall just ask for a fd and return</p>
<p>fd isn’t something new, just the an “alias” or “abstraction” of file store location in real world</p>
<blockquote>
<p>Q: Is fd a key-value mapping of inode which the kernel mainteins?</p>
</blockquote>
<p>wait syscall’s full def</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line"><span class="comment">// wait for a child to exit; exit status in *status, returns child PID</span></span><br></pre></td></tr></table></figure></div>

<p>exit syscall</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">// terminate the current process; status reported to wait().No return</span></span><br><span class="line"><span class="comment">// return 0 conventionally to indicate success, 1 to indicate failure</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Q: Is no return means the end of the process? FurtherMore, after exit syscall, OS is doing what during waiting(or scheding)? release resources, specific?</p>
</blockquote>
<p>wait return -1 when the process has no children(when return? killed or exited)</p>
<p>exec syscall</p>
<p>“replacing the calling process’s memory with a <strong>new memory image</strong> loaded file stored in the file sys”</p>
<p>not magic, the file must have some specific <strong>format</strong> to indicate which part of the file holds instruction, which part of the file holds data… etc</p>
<p>xv6 use <em>ELF format</em></p>
<blockquote>
<p>Link: Chapter 3</p>
</blockquote>
<p>the pipe implement in suer shell</p>
<p>assume that we have pipe syscall already</p>
<p>cmd, after parse, has been given a cmd type</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> PIPE:</span><br><span class="line">        pcmd = (<span class="keyword">struct</span> pipecmd *)cmd;</span><br><span class="line"><span class="comment">// pipecmd is just</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   struct pipecmd&#123;</span></span><br><span class="line"><span class="comment">   	 	int* type; // enum actually</span></span><br><span class="line"><span class="comment">   	 	cmd* leftcmd;</span></span><br><span class="line"><span class="comment">   	 	cmd* right; </span></span><br><span class="line"><span class="comment">   	 	// Q: cmd only has an element &quot;type&quot;, why?</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</span><br><span class="line">            close(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// close the write port</span></span><br><span class="line">            dup(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// duplicate the write port of the pipe, now it will occupy the 1</span></span><br><span class="line">            <span class="comment">// close the other pipe fd</span></span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            runcmd(pcmd-&gt;left);</span><br><span class="line">            <span class="comment">// now run the cmd</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// same</span></span><br><span class="line">            close(<span class="number">0</span>);</span><br><span class="line">            dup(p[<span class="number">0</span>]);</span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            runcmd(pcmd-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p>Attention: It calls twice <code>fork</code>. The left of pipe and the right of pipe are both the children of shell.</p>
<p>And there’ s a <strong>recursion</strong> here(<code>runcmd</code>):</p>
<p>the cmd struct only needs an element “type” because the cmd runs only when its type is “EXECCMD”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> *eargv[MAXARGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>The entire shell actual only has such a simple core in main function</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Read and run input commands.</span></span><br><span class="line">   <span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="keyword">if</span> (fork1() == <span class="number">0</span>) <span class="comment">// fork a child process</span></span><br><span class="line">           runcmd(parsecmd(buf)); <span class="comment">// run cmd</span></span><br><span class="line">       wait(<span class="number">0</span>); <span class="comment">// wait for the child be killed or exit</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// never return</span></span><br></pre></td></tr></table></figure></div>

<p>So that’s a reason why Unix(xv6) separate <code>fork</code> and <code>exec</code>. We need the possibility to execute some code between fork and exec, like implementing pipe(doing some operation on fd)</p>
<p>Also, another reason is to waste the resources: Based on COPY-ON-WRITE</p>
<p>xv6 allocates the memory of <strong>user</strong> implicitly using fork and exec</p>
<p>user process can also explicitly call <code>sbrk</code>to ask for more memory</p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><blockquote>
<p>A file descriptor is a small integer representing <strong>a kernel-managed object</strong> that a process may read&#x2F;write to</p>
</blockquote>
<p>source:</p>
<ul>
<li>open: file， dir, device</li>
<li>create: pipe</li>
<li>dup</li>
</ul>
<p>An <strong>abstraction</strong> of a file, device, pipe, <strong>making them all look like streams of bytes</strong></p>
<p><strong>The shell ensures three fd open(which is the shell process’s stdin, stdout and stderr)</strong> (console)</p>
<p>There’s an offset binding with each fd, making it possible to write code like</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;world&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>fork &amp;&amp; dup will copy the fd and the offset</p>
<p>dup is used to implement the shell command like this</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[somecommand] 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p>which means redirect the err message to the stdout</p>
<p>It can be implemented by</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(<span class="number">2</span>);</span><br><span class="line">fd = dup(<span class="number">1</span>);<span class="comment">// so it copies the 1&#x27;s fd and offset, and occupy the loc of 2(stderr).</span></span><br></pre></td></tr></table></figure></div>

<h4 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h4><blockquote>
<p>A pipe is a kernel buffer that exposed to process as a pair of file discriptors</p>
</blockquote>
<p>If there is no data available, the read side of a pipe will be blocked. A <code>read</code> on a pipe waits:</p>
<ul>
<li>write data</li>
<li><strong>the ref count of the write fd of the pipe is 0</strong></li>
</ul>
<p>So it’s very important to close write fd in the child process</p>
<blockquote>
<p>if one of wc’s fd refers to the pipe, the wc would never see the end-of-file</p>
</blockquote>
<p>验证：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// wc the std input</span></span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  pipe(p);</span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;switched to child process\n&quot;</span>);</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// 此处若注释......</span></span><br><span class="line">    execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;switched to parent process\n&quot;</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果是</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ gcc pipe.c</span><br><span class="line">❯ ./a.out</span><br><span class="line">switched to parent process</span><br><span class="line">switched to child process</span><br><span class="line">      0       2      11  </span><br></pre></td></tr></table></figure></div>

<p>如果将<code>close(p[1])</code>注释掉，不会输出 0 2 11, 因为wc根本没看到end-of-file（管道写端引用计数不为0），确实如此</p>
<p>这里其实有一些有趣的事情：</p>
<ul>
<li>代码之中没有使用<code>wait</code>，因而不保证父子进程的先后顺序；但是，如果先切换到子进程，会因为管道内部没有可读的数据而堵塞，再次发生进程调度。</li>
<li>可能还有疑问，如果父进程在write中间发生进程切换呢？实际上是不会发生的，也就是说<code>write</code>是atomic operation, <strong>在Unix和Linux系统中，对于管道和普通文件的write操作，如果写入的数据量小于PIPE_BUF（通常是4096字节），那么write操作是原子的</strong></li>
</ul>
<p>read the code of sh.c 100</p>
<blockquote>
<p>Thus, the shell may create the tree of process; The leaves of tree are command and the interior nodes are processes that wait the left and the right children complete.</p>
</blockquote>
<p>书下面几段对这种fork两次，左右中的执行顺序的design也做了很有意思的探讨</p>
<p>pipe’s advtanges over temp file(why <code>echo hi | wc</code> is better than <code>echo hi &gt; tmp; wc &lt; tmp</code>)</p>
<ul>
<li>pipes clean themselves up</li>
<li>pipes can pass arbitrarily long streams of data, while tmp file need enough space in disk and may be slower</li>
<li>pipes allows paralel execution(recall the pipe tree)</li>
<li>pipe’s blocking reads</li>
</ul>
<h4 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h4><p>file system: a tree starting at <code>root</code></p>
<p>tree node: data file: <strong>uninterpreted byte arrays</strong></p>
<p>dir: a <strong>named ref</strong> of data files and other dir</p>
<p><code>chdir</code> and <code>open</code> syscall</p>
<p>create new files or dirs?</p>
<ul>
<li><code>open(&quot;path&quot;, O_CREATE)</code></li>
<li><code>mkdir(&quot;path&quot;)</code></li>
<li><code>mknod(&quot;path&quot;, major-dev-number, minor-dev-number)</code></li>
</ul>
<p>mknod这个syscall比较特殊，可以用来创建命名管道FIFO或者设备文件</p>
<p>命名管道就是带名字的管道</p>
<p>设备文件分成两种</p>
<blockquote>
<p>在Unix和Linux系统中，设备被表示为设备文件，这是一种特殊的文件类型。设备文件分为两种：字符设备文件和块设备文件。</p>
<ul>
<li>字符设备文件：提供不带缓冲的、串行的数据访问，应用程序读写的是设备提供的原始数据。键盘和鼠标等输入设备通常是字符设备。</li>
<li>块设备文件：提供带缓冲的、随机访问的数据访问，数据以块为单位进行读写。硬盘和光驱等存储设备通常是块设备。</li>
</ul>
<p>设备文件与普通文件的主要区别在于，设备文件提供了一种访问硬件设备的接口。当你对设备文件进行读写操作时，实际上是在与相应的设备进行通信。</p>
<p>主设备号和次设备号是设备文件的重要属性，它们用于标识系统中的设备。</p>
<ul>
<li>主设备号：用于标识设备的类型或设备驱动。例如，所有的SCSI硬盘都有相同的主设备号。</li>
<li>次设备号：用于标识同一类型的设备中的具体设备。例如，系统中的第一个SCSI硬盘的次设备号是0，第二个SCSI硬盘的次设备号是1，以此类推。</li>
</ul>
<p>设备号是设备驱动程序使用的，应用程序通常不需要直接处理设备号。当你打开一个设备文件时，系统会根据设备文件的设备号找到相应的设备驱动，然后由设备驱动处理你的读写请求。(也就是说内核维护了一个设备号-&gt;驱动的jump table)</p>
</blockquote>
<p>文件和文件名在文件系统之中是两个东西：</p>
<ul>
<li>文件file: 是存储在磁盘上的metadata，或者叫inode</li>
<li>文件名：是对文件的一个link或者ref, 文件名是由文件夹dir来维护的一个dir entry</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>file是由一些类型信息、权限信息、引用计数等信息+data组成的（其中的data就是inode）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>link</code> : 给指定的inode加上另一个名字</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>); <span class="comment">// 现在名字“b”也指向“a”对应的inode了</span></span><br></pre></td></tr></table></figure></div>

<p><code>unlink</code>: 删除一个名字</p>
<p>一个有趣的应用是创建临时文件</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;temp&quot;</span>, O_CREATE|O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;temp&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>此时只有open返回的或者其它地方的拿到的fd还能访问临时文件</p>
<p>当这个进程退出，回收fd的时候，temp这个文件的引用计数为0，会被清除</p>
<p>一个小细节，shell大部分的命令都是放在其他文件之中调用来实现的，即fork+exec，但cd是在shell里面的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">    <span class="keyword">while</span> ((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read and run input commands.</span></span><br><span class="line">    <span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// chop \n</span></span><br><span class="line">            <span class="keyword">if</span> (chdir(buf + <span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>)</span><br><span class="line">            runcmd(parsecmd(buf));</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为cd的时候是shell进程cd而不是子进程cd</p>
<h4 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h4><p>Unix syscall interface standard: POSIX(Portable Operating System Interface)</p>
<h4 id="lab01-Utils"><a href="#lab01-Utils" class="headerlink" title="lab01 Utils"></a>lab01 Utils</h4><p>boot xv6：照做即可，或参照踩坑记录</p>
<p>sleep: 知道user.h是syscall定义的地方即可，可以了解一下syscall是啥意思</p>
<p>pingpong: 注意child process和parent process的收发顺序，不要让两个管道都block了，除此之外，注意打印的fd是什么</p>
<p>参考代码实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ping-pong: two thread byte communication</span></span><br><span class="line">  <span class="comment">// note the pipe is unidirectional</span></span><br><span class="line">  <span class="type">int</span> p2c_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> c2p_pipe[<span class="number">2</span>];</span><br><span class="line">  pipe(p2c_pipe);</span><br><span class="line">  pipe(c2p_pipe);</span><br><span class="line">  <span class="keyword">if</span> ((fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p2c_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(p2c_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(p2c_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *send = <span class="string">&quot;pong\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *received = <span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    read(<span class="number">0</span>, received, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s&quot;</span>, pid, received);</span><br><span class="line">    write(c2p_pipe[<span class="number">1</span>], send, <span class="keyword">sizeof</span>(send)); <span class="comment">// write back</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(received);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(c2p_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(c2p_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(c2p_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep the STDOUT&#x27;s fd: 1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *send = <span class="string">&quot;ping\n&quot;</span>;</span><br><span class="line">    write(p2c_pipe[<span class="number">1</span>], send, <span class="keyword">sizeof</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *received = <span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    read(<span class="number">0</span>, received, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received %s&quot;</span>, pid, received);</span><br><span class="line">    <span class="built_in">free</span>(received);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>primes: 这个lab有一些难度</p>
<p>在第一次做的时候其实没搞懂</p>
<p>首先要理解题目意思：背景材料给出了这样的素数并行筛法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br></pre></td></tr></table></figure></div>

<p>其中每一次筛之间都是管道，而每一轮筛本身是一个进程</p>
<p>也就是说我们要在某个循环之中，完成 “从上一个管道的输入读取上一次筛剩下的数” 到 “采用读取到的第一个数作为新的筛子，并将它打印” 到 “新建管道，向管道里面写入数据”</p>
<p>而最关键的其实在于：</p>
<ul>
<li>我们怎么样去指示读到的数是不是第一个，怎样判定前面的数已经读完和整个方法已经结束</li>
<li>我们怎么处理新建管道和新建子进程，包括它们之间的先后顺序</li>
<li>每个子进程都有自己的堆和栈，所以上述的标识符应该要么是本地量，要么是管道这种全局维护的</li>
</ul>
<p>还有就是注意提示，例如:</p>
<ul>
<li>提示里面说了<code>Be careful to close file descriptors that a process doesn&#39;t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</code>这实际上说明了当你的输出里面 <code>$</code>符号夹在输出中间的时候，是因为你的祖先进程没有等到所有的子进程都结束就退出了（所以xv6 shell认为要执行下一次命令输入，输出了<code>$</code>)</li>
<li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed. 这一条实际上提示了循环的写法</li>
</ul>
<p>下面给出个人实现：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> curNumber = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  pipe(p);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> div = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newpipe[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// if there are primes in the pipe.</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// now pipe input is fd: 0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      ret = read(<span class="number">0</span>, &amp;curNumber, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">      <span class="comment">//   fprintf(1, &quot;cnt=%d, curNumber=%d\n&quot;, cnt, curNumber); </span></span><br><span class="line">      <span class="comment">//   all commented fprintf are some log info </span></span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        div = curNumber; <span class="comment">// the prime to div</span></span><br><span class="line">        pipe(newpipe); <span class="comment">// new pipe</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// the parent process has written all the numbers and exit</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// no prime left</span></span><br><span class="line">          <span class="comment">// fprintf(1, &quot;over\n&quot;);</span></span><br><span class="line">          close(p[<span class="number">0</span>]);</span><br><span class="line">          close(p[<span class="number">1</span>]);</span><br><span class="line">          close(newpipe[<span class="number">0</span>]);</span><br><span class="line">          close(newpipe[<span class="number">1</span>]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// the new child process(next stage)</span></span><br><span class="line">          <span class="comment">// reset cnt and flag </span></span><br><span class="line">          cnt = <span class="number">0</span>;</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">          close(<span class="number">0</span>);</span><br><span class="line">          dup(newpipe[<span class="number">0</span>]);</span><br><span class="line">          close(newpipe[<span class="number">0</span>]);</span><br><span class="line">          close(newpipe[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          close(<span class="number">0</span>); <span class="comment">// release the pipe and process</span></span><br><span class="line">          close(<span class="number">1</span>);</span><br><span class="line">          close(p[<span class="number">0</span>]);</span><br><span class="line">          close(p[<span class="number">1</span>]);</span><br><span class="line">          wait(<span class="number">0</span>); <span class="comment">// wait for the latest process to exit, a wait &quot;stack&quot;</span></span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// fprintf(1, &quot;process: %d\n&quot;, getpid());</span></span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;prime %d\n&quot;</span>, curNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNumber % div != <span class="number">0</span>) &#123;</span><br><span class="line">          write(newpipe[<span class="number">1</span>], &amp;curNumber, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  close(p[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[<span class="number">1</span>]);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上是，先创建pipe，然后把数据放在pipe里面，等到read返回一个0（父进程写完，管道读完，管道写端已经没有引用）的时候，去fork一个进程，然后“承接”这个管道的数据</p>
<p>find:</p>
<p>根据它的hint去看ls.c，依葫芦画瓢即可</p>
<p>xargs：</p>
<p>也是理解就不难，注意不需要自己写管道和执行分词之类，只需要读输入即可</p>
<hr>
<h3 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h3><blockquote>
<p>An operating system must fulfill three requirements: multiplexing, isolation and interaction</p>
</blockquote>
<p>xv6 runs on a multi-core RISC-V microprocessor and is written in “LP64”C</p>
<p>The CPU in a complete computer is surrounded by support hardware, <strong>much of it in the form of I&#x2F;O interfaces</strong></p>
<p>in xv6, this includes a RAM, a ROM containg boot code, a serial connection to the user’s board&#x2F;screen, and a disk for storage</p>
<h4 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h4><p>why?</p>
<p>为什么操作系统不做成一个库？——事实上在嵌入式和一些实时系统里面是这样的</p>
<p>也就是说，为什么要提供强隔离性</p>
<blockquote>
<p>Such a cooperative time-sharing scheme may be OK if all applications trust each other and have no <a class="link"   target="_blank" rel="noopener" href="http://bugs.it/" >bugs.It <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘s more typical for applications to not trust each other, and to have bugs</p>
</blockquote>
<p>为了实现强隔离性，避免程序对于硬件资源的直接访问是很有帮助的，也就是说操作系统需要<strong>将resource抽象成service</strong></p>
<p>例如在Unix里面，程序对磁盘没有直接的概念，读写是通过文件系统和pathname完成的；程序对于CPU和时分共享没有直接的概念，这部分是由系统的调度策略掌控的；程序对于物理内存没有直接的概念，对内存的操作是通过<code>exec</code>syscall实现的，如果内存紧张的话，一些进程的数据甚至会被存储在磁盘上</p>
<h4 id="2-2-User-mode-supervisor-mode-and-syscalls"><a href="#2-2-User-mode-supervisor-mode-and-syscalls" class="headerlink" title="2.2 User mode, supervisor mode, and syscalls"></a>2.2 User mode, supervisor mode, and syscalls</h4><p>为了维持强隔离性，用户程序必然不能改写系统程序，这是由CPU来实现的</p>
<p>硬件上提供三种mode: machine mode, supervisor mode and user mode</p>
<p>其中machine mode在经过一些初始的引导和配置计算机的代码之后就转到supervisor mode</p>
<p>然后，也是CPU硬件，提供了一些特权指令，如果在用户态执行了特权指令就会</p>
<blockquote>
<p>“then the CPU doesn’t execute the instruction, but switch to supervisor-mode code that can terminate the application”</p>
</blockquote>
<p>更具体来说，CPU会产生一个异常，然后会发生中断，根据中断向量表，跳转到对应的代码处执行</p>
<p>Q：代码怎么知道要终止哪个进程呢？</p>
<p>A：RISCV之中有一堆中断相关的寄存器，在xv6这种模拟器之中是stvec, sepc, scause,stval……这些寄存器保存了中断发生的地址，中断的原因（中断类型+编号），中断处理器状态信息,…..这是其一；中断内部一般不发生进程调度（保证了进程没有发生变化），而操作系统是知道当前进程的（xv6之中proc.c的myproc）</p>
<blockquote>
<p>通常情况下，在处理中断的过程中，操作系统不会进行进程调度。中断处理程序（ISR）的目的是快速响应硬件事件，如I&#x2F;O完成、定时器到期等。为了保持系统的响应性，中断处理程序需要尽可能短且高效，以便尽快完成中断处理并返回到被中断的进程。</p>
<p>中断处理程序执行期间，CPU处于内核模式（或称为特权模式），此时操作系统会暂停当前用户进程的执行，保存其上下文，然后执行中断处理程序。在中断处理程序执行期间，其他进程的调度和执行被暂停，直到中断处理完成。</p>
<p>一旦中断处理程序执行完毕，操作系统会恢复之前被中断的进程的上下文，然后继续执行该进程。这个过程称为上下文切换（Context Switching），它涉及到将CPU的控制权从中断处理程序切换回用户进程。</p>
<p>在某些情况下，如果中断处理程序执行时间较长，可能会影响系统的实时性。为了解决这个问题，操作系统可能会采用中断嵌套（Nested Interrupts）或使用软中断（Soft Interrupts）等技术来处理更复杂的中断处理逻辑，同时允许其他进程继续执行。但这些技术通常用于特定的场景，如实时操作系统（RTOS）或需要处理大量中断的系统。在大多数通用操作系统中，中断处理仍然是一个快速且不涉及进程调度的过程。</p>
</blockquote>
<p>在Linux之中，中断可以被优先级更高的中断中断，形成中断嵌套</p>
<blockquote>
<p>Linux将中断处理程序分为上下两部分，需要紧急处理立即执行的归为上半部，不那么紧急的归为下半部。</p>
<p>这便涉及到了开关中断的问题。开中断，即EFLAGS的IF位置1，表示允许响应中断；关中断，即EFLAGS的IF位置0，表示不允许响应中断。</p>
<p>**1、**上半部分是刻不容缓的，需要立即执行的部分，所以要在关中断的状态下执行。</p>
<p>**2、**而下半部分不那么紧急，在开中断的情况下进行，如果此时有新的中断发生，当前中断处理程序便会换下CPU，CPU会另寻时间重新调度，完成整个中断处理程序。</p>
</blockquote>
<p>而对于这样的中断嵌套，实际上是保存了前面中断的信息，也就是中断栈，在过程之中不会切到正常运行的进程</p>
<p>用户级指令构成了user space，再加上特权级构成了kernel space</p>
<p>运行再kernel space的software就是kernel</p>
<p>用户程序不能直接执行特权指令，CPU提供了特殊的指令（在RISCV里面是ecall）来将user mode切换到supervisor mode并<strong>enter the kernel at an entry point specified by kernel</strong>(这就是syscall)</p>
<p>当切换到supervisor mode的时候，kernel会对syscall提供的argument做validation，以此来决定后续的操作</p>
<h4 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h4><p>monolithic kernel and micro kernel: 宏内核和微内核</p>
<p>OS首先要解决的设计是，有多少OS的部分运行在supervisor mode?</p>
<p>让全部的OS运行在supervisor mode上是宏内核，例如Linux的思路，好处是效率（例如内核内部各模块之间的通信更简单了），坏处是对代码的更高要求（内核代码数量的膨胀，一旦内核错误就必须重启电脑）</p>
<p>新兴的微内核思路是OS把文件系统等大量部分作为server运行在用户态，只将必要的少量代码和server之间通信的代码放在supervisor mode下面运行，这样的好处有比如supervisor mode下面的代码此时少到可以做程序安全性验证</p>
<p><strong>Fig2.2 xv6 kernel 各文件的用途</strong></p>
<p>(各个文件近似模块化，各个模块之间的接口定义在kernel&#x2F;defs.h)</p>
<h4 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4 Code: xv6 organization"></a>2.4 Code: xv6 organization</h4><h4 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h4><blockquote>
<p>The unit of isolation in xv6 (as in other Unix operating systems)is a process. The process abstraction prevents one process from wrecking or spying on other process’s memory, CPU, fd, etc</p>
</blockquote>
<blockquote>
<p>The process provides the illusion to a program that it has its own private machine.(e.g own memory system(<strong>address space</strong>), own CPU, own disk)</p>
</blockquote>
<p>kernel&#x2F;proc.h</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// the sscratch register points here.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>每个process有自己的pagetable, which defines each process’s address space</p>
</li>
<li><p>At the top of the address space xv6 reserves a page for a trampoline and a map mapping the process’s trapframe(详细的解释留待Chapter4补). Xv6 use these two pages to transition into the kernel and back;</p>
</li>
<li><p>process vs thread: thread**线程是“give the process an illusion of its own CPU”**对CPU的抽象，所以当我们讨论进程的切换和调度的时候，实际上是在讨论不同进程之间thread的状态的变化，切换进程就是将这个进程的thread挂起（suspend），再切换到另一个进程的某个线程执行。xv6之中一个process只有一个thread，但是现代的系统有多个thread来利用多核cpu（Linux的thread概念和Windows又有一些不同，这里是Linux的thread概念）</p>
</li>
<li><p>每个进程有自己的kernel stack和user stack，当syscall&#x2F;IO等，需要进入kernel的时候，<strong>内核的代码放在kernel stack里面执行，user stack是维持不动的</strong>（实际上在ecall指令发起的时候，代码就不在用户态了，那执行从用户态-&gt;内核态这部分代码也要使用寄存器，如何保存原有寄存器的值呢？这会在lab4之中讲解，大体来说是使用特殊的额外寄存器（存放trapframe基址）和对应的特殊指令，先把a0上的值和额外寄存器的值做交换，然后我们就有了一个可用的寄存器，同时在额外寄存器上保留了原来的地址，然后通过a0相对寻址，就可以将其他寄存器的值保存在trapframe的page上，最后从额外寄存器读回来a0并保存）</p>
</li>
</ol>
<h4 id="2-6-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-6-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.6 Code: starting xv6, the first process and system call"></a>2.6 Code: starting xv6, the first process and system call</h4><p>启动xv6的过程概述：</p>
<ol>
<li>When the risc-v computer powers on, it initializes itself and start boot loader in read-only memory.The boot loader load xv6 kernel into memory.(这部分应该是qemu模拟的)</li>
<li>in machine mode, the CPU executes xv6 at _entry(kernel&#x2F;entry.S)</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	# qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each CPU to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line">	# set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">	csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">	# jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure></div>

<p>其中有三个注意的地方：一是从0x80000000开始是因为0x0到0x80000000留下来做IO用了；二个是start函数“performs some configuration in machine mode and then switches to supervisor mode”；三是此时页表是被禁用的，都是direct-mapping</p>
<p>start还干了启用中断，启用时钟，设置返回到main等操作</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// entry.S jumps here in machine mode on stack0.</span><br><span class="line">void</span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">  // set M Previous Privilege mode to Supervisor, for mret.</span><br><span class="line">  unsigned long x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  // set M Exception Program Counter to main, for mret.</span><br><span class="line">  // requires gcc -mcmodel=medany</span><br><span class="line">  w_mepc((uint64)main); // 返回到main(设置pc)</span><br><span class="line"></span><br><span class="line">  // disable paging for now.</span><br><span class="line">  w_satp(0);</span><br><span class="line"></span><br><span class="line">  // delegate all interrupts and exceptions to supervisor mode.</span><br><span class="line">  w_medeleg(0xffff);</span><br><span class="line">  w_mideleg(0xffff);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  // ask for clock interrupts.</span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  // keep each CPU&#x27;s hartid in its tp register, for cpuid().</span><br><span class="line">  int id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  // switch to supervisor mode and jump to main().</span><br><span class="line">  asm volatile(&quot;mret&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后进入到main</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>先是一些设置的初始化</p>
<p>初始化完毕后，调用userinit()进入第一个进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>是这玩意的二进制</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># exec(init, argv)</span></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"><span class="meta"># for(;;) exit();</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># char init[] = <span class="string">&quot;/init\0&quot;</span>;</span></span><br><span class="line">init:</span><br><span class="line">  .<span class="built_in">string</span> <span class="string">&quot;/init\0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># char *argv[] = &#123; init, 0 &#125;;</span></span><br><span class="line">.p2align <span class="number">2</span></span><br><span class="line">argv:</span><br><span class="line">  .<span class="type">long</span> init</span><br><span class="line">  .<span class="type">long</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p>然后通过调用SYS_exec进行syscall再次进入内核态执行init.c,启动shell,the system is up</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init: The initial user-level program</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>后面还要回来加深理解，还是迷迷糊糊的</p>
<h4 id="2-7-Security-Model-2-8-Real-World"><a href="#2-7-Security-Model-2-8-Real-World" class="headerlink" title="2.7 Security Model &amp; 2.8 Real World"></a>2.7 Security Model &amp; 2.8 Real World</h4><p>闲聊段</p>
<h3 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3: Page tables"></a>Chapter 3: Page tables</h3><h4 id="3-1-Paging-Hardware"><a href="#3-1-Paging-Hardware" class="headerlink" title="3.1 Paging Hardware"></a>3.1 Paging Hardware</h4><p>page table: allow xv6 to isolate different address space to multiplex them onto a single physical memory</p>
<p>xv6 performs a few tricks: mapping the same memory(a trampoline page)in several address space, and guarding kernel and user stacks with an unmapped page</p>
<p>xv6: Sv39 RISCV</p>
<p>Fig 3.1</p>
<p>VA：从高位到低位 25位额外位（不参与转换）， 27位页表index, 12位 Offset</p>
<p>PTE： 10位可拓展位，3级页表 * 9位index（512^3^条）,每条PTE 44 位PPN（Physical Page Number），10位标志位Flag</p>
<p>PA: 44位PPN+12位Offset</p>
<p>三级页表：</p>
<p>Pros:空间效率，只有被使用的页（VALID标志位为1），才会被分配内存，相当于页表树上，许多叶子的深度都只有1或2</p>
<p>Cons:一条指令必须在PTE之中走三次（通过移位操作），降低了一部分时间效率</p>
<p>补偿：TLB（Translation Look-Aside Buffer）</p>
<p>important Fig 3.2 detail</p>
<p>告诉硬件启用页表：kernel把最高级页表的基址存入 satp register</p>
<p>每个CPU都有自己的satp，所以不同CPU可以运行不同的进程（各自有自己的地址空间和页表）</p>
<p>每个process(包括内核)读写的都是VA，VA通过<strong>进程自己的页表</strong>转换成PA，再去读写实际的物理存储</p>
<p>内核应该保持对整个物理存储的操控权，所以整个物理的存储空间都被映射到了内核的页表之中，而xv6为了实现的简洁性，基本都是直接映射，也就是VA&#x3D;PA，这样<strong>在内核之中</strong>读写VA就等同于读写PA了。</p>
<h4 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h4><p>内核总要知道各个设备的PA和它自己页表VA的关系，这个实际上是一种配置或者约定（QEMU的配置）</p>
<p>这里</p>
<blockquote>
<p>The kernel gets at RAM and memory-mapped device registers using “direct mapping”.That is, mapping the resources at virtual addresses that are equal to physical addresses</p>
</blockquote>
<p>简化内核读写的代码，比如fork实际上给子进程申请到的是PA（物理内存），但是内核之后就直接把它当作是虚拟地址在对他进行代码操作了</p>
<p>在fork调用的uvmcopy之中</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err; <span class="comment">// 这里的mem是PA（kalloc返回的地址）</span></span><br><span class="line">memmove(mem, (<span class="type">char</span> *)pa, PGSIZE); <span class="comment">// 这里就直接把mem当VA了(一个进程自己“看到”的是VA)</span></span><br></pre></td></tr></table></figure></div>

<p>两个不是直接映射的内存页</p>
<ul>
<li><p>The trampoline page: 它在每一个进程的虚拟内存上都占据了最顶端的一页，所以在内核的VA地址空间之中，它两次映射到同一个PA,一次是内核的kernel text代码段，另一次是kernel的VA的最顶端</p>
</li>
<li><p>The guard page: 每个进程的内核栈下面有一个guard page，它的PTE_V设置为了0，防溢出，如果栈溢出了就会产生pagefault</p>
</li>
</ul>
<p>此时内核栈对应的PA也被两个VA映射，一个是kernel data段的直接映射；另一个是VA顶部的Kstack段</p>
<p>为什么要维持这样两个映射是因为，如果只有kernel data段的直接映射，那我们想要加上guard page，就必须要将这一段设置成invalid，也就是取消guard page的映射；那莫名其妙地，RAM里面的某部分物理内存对内核就不能用了</p>
<p>所以要扣扣搜搜，两个映射之后，内核的保护页不放在实际的kernel data段，而是放在VA的top段，而并没有实际“对应”的物理页，省下了不少页面的内存，也保证了物理页的连续性</p>
<p>（本质上就是：</p>
<ol>
<li><p>想保证kernel data&#x2F;text段是直接映射的</p>
</li>
<li><p>想保证物理内存RAM的使用是连续的</p>
</li>
<li><p>想要加guard page</p>
</li>
</ol>
<p>如果没有两次映射，12和3不能同时成立；</p>
<p>）</p>
<h4 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3 Code:creating an address space"></a>3.3 Code:creating an address space</h4><p>kvm相关的函数建立在kernel的直接映射之上</p>
<p>例如walk里面</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!alloc || (pagetable = (<span class="type">pde_t</span> *)kalloc()) == <span class="number">0</span>) <span class="comment">// 这里的pagetable是PA</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE); <span class="comment">// 传进入当函数参数的是VA</span></span><br></pre></td></tr></table></figure></div>

<p>什么时候页表被启用呢？kvminithart函数被调用的时候</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">kvminithart();   <span class="comment">// turn on paging</span></span><br></pre></td></tr></table></figure></div>

<p>也就是我们先kvminit()初始化kernel pagetable(把整个RAM全部映射到kernel pagetable)</p>
<p>对照上面的图理解下面的代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the kernel&#x27;s page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pagetable_t</span> kernel_pagetable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[]; <span class="comment">// kernel.ld sets this to end of kernel code.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[]; <span class="comment">// trampoline.S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span> &#123;</span><br><span class="line">    kernel_pagetable = (<span class="type">pagetable_t</span>)kalloc();</span><br><span class="line">    <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uart registers</span></span><br><span class="line">    kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">    kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLINT</span></span><br><span class="line">    kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PLIC</span></span><br><span class="line">    kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">    kvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">    kvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext,</span><br><span class="line">           PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">    <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">    kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后启用页表</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span> &#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable)); <span class="comment">// write the stap register</span></span><br><span class="line">  sfence_vma(); <span class="comment">// clean TLB, 这个函数实际上是对RISCV指令sfence.vma的模拟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际的RISCV CPU还会有一些地址空间标识符，使进程切换的时候不需要冲洗整个TLB</p>
<h4 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4 Physical memory allocation"></a>3.4 Physical memory allocation</h4><h4 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5 Code: Physical memory allocator"></a>3.5 Code: Physical memory allocator</h4><p>维护了一个struct run的链表freelist，然后每次分配就是取链表的第一个元素，free就是将该页连接到链表末尾</p>
<p>每次分配和free都会acquire spinlock，来维持并发的robust</p>
<h4 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6 Process address space"></a>3.6 Process address space</h4><p>讲完了内核空间的处理方法，接下来讲user space,也就是各个用户进程</p>
<p>主要是用户进程的栈，在xv6之中就是简单的single page的实现，参见exec.c</p>
<p>这个page上从顶到底放着</p>
<ul>
<li>argument 0~N (N个字符串，argv[]的值)</li>
<li>address of argument （N个pointer）</li>
<li>argc</li>
<li>return PC</li>
<li>…（其他）</li>
</ul>
<p>然后这个stack page下面还有一个guard page，它的PTE_V是0，用于在stack overflow的时候产生pagefault</p>
<p>Q：也就是xv6的用户程序的栈的大小最多只有4kb?</p>
<p>A：测试了一下，是的</p>
<p>在用户程序里面加上</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    a[i] = i;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;a:alloc %d pages.\n&quot;</span>, <span class="keyword">sizeof</span>(a) / PGSIZE);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;the address of a is %p&quot;</span>, a);</span><br></pre></td></tr></table></figure></div>

<p>就会出现</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span></span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=4</span><br><span class="line">            sepc=0x000000000000002e stval=0xfffffffffffa1540</span><br></pre></td></tr></table></figure></div>

<p>scause寄存器记录了这次异常的原因</p>
<p>查询<a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/riscv/virtual-memory/main/specs/663-Svpbmt.pdf" >riscv手册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可知, 000f是Store&#x2F;AMO pagefault，验证了我们栈溢出的猜想</p>
<blockquote>
<p>AMO page fault（Atomic Memory Operation page fault）是指在RISC-V架构中，当执行原子内存操作（如<code>amoadd</code>、<code>amoxor</code>等）时，由于访问的虚拟地址对应的物理页没有映射到物理内存（即没有对应的物理页帧），或者访问的页没有写权限，而触发的页错误（Page Fault）异常。</p>
<p>在RISC-V中，原子内存操作（AMO）是一种特殊的内存访问指令，它允许在多处理器系统中同步地执行原子操作，如加法、减法、交换等，而不需要额外的同步机制。这些操作通常用于实现锁和其他并发控制结构。</p>
<p>当处理器尝试执行AMO指令时，如果遇到以下情况之一，就会触发AMO page fault：</p>
<ol>
<li><strong>虚拟地址未映射</strong>：处理器尝试访问的虚拟地址在当前进程的页表中没有找到对应的物理地址映射。</li>
<li><strong>写权限不足</strong>：即使虚拟地址已经映射到物理内存，但该页没有写权限（在页表项中，写权限位W被设置为0）。</li>
</ol>
<p>在发生AMO page fault时，处理器会将控制权交给操作系统的中断处理程序（在RISC-V中称为中断向量），操作系统需要处理这个异常。处理程序会检查导致异常的虚拟地址，如果地址合法，操作系统可能会从磁盘或其他存储介质中加载缺失的页到物理内存，并更新页表以赋予相应的权限。如果地址不合法，操作系统可能会终止相关进程。</p>
<p>AMO page fault是RISC-V架构中处理并发和同步问题的一部分，它确保了在多处理器系统中原子操作的正确性和一致性。</p>
</blockquote>
<p>但有个奇怪的地方，如果没有</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;the address of a is %p&quot;</span>, a);</span><br></pre></td></tr></table></figure></div>

<p>这一行</p>
<p>实际上不会触发, 查看了fprintf内部，并没有什么奇怪的地方</p>
<p>怀疑是如果不调用fprintf的话，编译器优化了这一段无用代码？</p>
<h4 id="3-7-Code-sbrk"><a href="#3-7-Code-sbrk" class="headerlink" title="3.7 Code:sbrk"></a>3.7 Code:sbrk</h4><p>上面固定了Stack是一个PAGE之后有一个好处就是大大简化了后面的内存分配</p>
<p>之前看得不仔细，没看到栈只有一页，一直没太搞懂为啥它的growproc给了一个sz作为参数，一个进程的sz（如果是传统的栈从上往下增长，堆从下往上增长的模型）本身就令人迷惑，allocproc的时候尚可解释为是堆+栈+其他，dealloc的时候如何根据减小的sz直接确定释放的页呢？还有就是它的sz是如何动态监控栈的增长的呢？</p>
<p>答案是根本没有监控，上面的text段是代码文本，data段是全局变量，都是编译时确定的东西，而stack只有一个page，guard page也只有一个page，也就是说运行前，堆底部有多少个page已经被指定，并且栈在堆下面（看图），我们的内存分配变成只对堆操作了，这个sz也变成了很直接的从底部向上数的page数量（看源码可以知道，trampoline page和trapframe page没有被计入p-&gt;sz里面，而是被放在kalloc的kernel的空间里面，不需要user process知道相关的信息）</p>
<p>这也是页表的另一个作用体现的时候：</p>
<p>xv6的所有内存分配都是通过kalloc()实现的，如何知晓user process是否有权释放某个物理空间呢？又或者说怎么维护哪个物理空间是被哪个进程拿到的呢？就是通过页表，在释放空间之前进行此进程的页表上到底有没有这个合法PA的检查(uvmunmap)</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="3-8-Code-exec"><a href="#3-8-Code-exec" class="headerlink" title="3.8 Code:exec"></a>3.8 Code:exec</h4><p>exec.c源码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">loadseg</span><span class="params">(<span class="type">pde_t</span> *pgdir, uint64 addr, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load a program segment into pagetable at virtual address va.</span></span><br><span class="line"><span class="comment">// va must be page-aligned</span></span><br><span class="line"><span class="comment">// and the pages from va to va+sz must already be mapped.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">loadseg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="keyword">struct</span> inode *ip, uint offset, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint i, n;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;loadseg: va must be page aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    pa = walkaddr(pagetable, va + i);</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;loadseg: address should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sz - i &lt; PGSIZE)</span><br><span class="line">      n = sz - i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      n = PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)pa, offset+i, n) != n)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>它先后干了这么几件事</p>
<ul>
<li><p>使用<code>namei</code>和文件系统交互，拿到了<code>path</code>文件的<code>inode</code></p>
</li>
<li><p>检查文件的ELF编码（使用int（4 Byte） ELF magic number, ‘0x7F’,’E’,’L’,’F’），并从文件之中先读取相关数据，例如文件的offset和结束位置、物理地址等</p>
</li>
<li><p>特别地，有<code>if(ph.vaddr + ph.memsz &lt; ph.vaddr) goto bad;</code>的检查；</p>
</li>
<li><p>检查完毕后，使用<code>loadseg</code>将文件的内容读入内核数据（进程相关）和准备的页表</p>
</li>
<li><p>再去按照user space去分配user process的一些page，并将前面约定的一些args的参数以约定顺序填入，并填好进程新的sz,按照文件的elf给的数据填程序的入口（main），初始化用户栈指针</p>
</li>
<li><p>如果到最后也没出错，就更新整个进程（commit image）；否则撤销前面的操作。这也就是保证相关操作的原子性</p>
</li>
</ul>
<p>ps 关于有<code>if(ph.vaddr + ph.memsz &lt; ph.vaddr) goto bad;</code>的检查，书上说了不少</p>
<p>如果没有这个检查，那么攻击者可以伪造一个ph.vaddr和ph.memsz，使得它们加起来<strong>溢出</strong>，从而达到0x1000这种kernel space；而又因为exec是syscall，原来没有权限的用户进程现在有了权限，exec会使用loadseg将elf文件里面的内容写到特定的kernel space之中，就完成了攻击</p>
<p>这段代码值得多看，很漂亮</p>
<h4 id="3-9-Real-world"><a href="#3-9-Real-world" class="headerlink" title="3.9 Real world"></a>3.9 Real world</h4><p>现实世界的OS有以下xv6没有的机制：</p>
<ul>
<li>使用pagefault配合paging来进行权限保护（xv6只使用paging）</li>
<li>kernel位置的随机化来防范攻击（xv6的kernel是direct-map+ 0x80000000的固定RAM）</li>
<li>RISCV提供的物理页的硬件保护</li>
<li>超级页（super page），来提高大块页的页表相关操作效率（比如内核）</li>
<li>更精巧的内存分配策略：例如处理不同大小的内存请求，给不同大小的内存块；而不是xv6始终固定给PAGESIZE的倍数（这样对于频繁小请求表现不好）</li>
</ul>
<h3 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4: Traps and system calls"></a>Chapter 4: Traps and system calls</h3><p>ps（看代码时可能有用）：hartid 是 hardware thread id的缩写，在xv6之中是cpu的id，tp寄存器里面会有它的值</p>
<p>控制流在三种情况下可能发生转移：</p>
<ul>
<li>syscall</li>
<li>exception：something illegeal</li>
<li>device interrupt: indicate the device needs attention(like the finish of IO)</li>
</ul>
<p>统称这三种（系统调用，异常，中断）为trap，在xv6之中，所有的trap都是kernel处理的</p>
<blockquote>
<p><a class="link"   target="_blank" rel="noopener" href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf" >RISCV文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>给出的定义见下：</p>
<p>We use the term <strong>exception</strong> to refer to <strong>an unusual condition occurring at run time</strong> associated with an instruction in the current RISC-V thread. We use the term <strong>trap</strong> to refer to the <strong>synchronous transfer of control to a trap handler caused by an exceptional condition occurring</strong> within a RISC-V thread. Trap handlers usually execute in a more privileged environment. We use the term <strong>interrupt</strong> to refer to <strong>an external event that occurs asynchronously</strong> to the current RISC-V thread. When an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and subsequently experiences a trap.</p>
</blockquote>
<p>trap的一般流程是：</p>
<ol>
<li>转移控制权到kernel</li>
<li>kernel保存用户进程寄存器状态和其它状态以便返回</li>
<li>调用合适的handler code</li>
<li>返回</li>
</ol>
<p>不同的trap最好有不同的handler code，比如user space的trap， kernel的trap，timer interrupt等等</p>
<h4 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h4><p>kernel怎么知道如何处理trap呢？</p>
<p>RISCV有许多特殊的寄存器（kernel&#x2F;riscv.h）用于记录和trap有关的信息、</p>
<ul>
<li>stvec：The kernel write <strong>the address of its trap handler</strong> here</li>
<li>sepc: <strong>When(pc) a trap occurs</strong></li>
<li>scause: A number describe <strong>the reason of trap</strong></li>
<li>sscratch: 用于保存上下文的额外寄存器</li>
<li>sstatus: 其中的SIE bit标志着是否允许设备中断，其中的SPP bit标志着中断是从user mode还是super mode触发的（同时这也决定了sret会回到什么mode）</li>
</ul>
<p><strong>具体细节：</strong></p>
<ol>
<li>If the trap is a device interrupt and the sstatus SIE bit is clear, don’t do any of the following*</li>
<li>Disable interrupts by clearing the SIE bit in sstatus</li>
<li>Copy the pc to sepc</li>
<li>Save the current mode (user or supervisor mode) in SPP bit in sstatus</li>
<li>Set scause to reflect the trap’s cause</li>
<li>Set the mode to supervisor</li>
<li>Copy the stvec to the pc</li>
<li>Start executing at new pc</li>
</ol>
<p>注意CPU<strong>没做切换内核页表，没做使用内核栈，没做保存和更新pc之外的寄存器</strong>，这些都留给kernel software去完成，简化设计，留下灵活性</p>
<h4 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h4><blockquote>
<p>我们不想让用户代码介入到这里的user&#x2F;kernel切换，否则有可能会破坏安全性。所以这意味着，trap中涉及到的硬件和内核机制不能依赖任何来自用户空间东西。比如说我们不能依赖32个用户寄存器，它们可能保存的是恶意的数据，所以，XV6的trap机制不会查看这些寄存器，而只是将它们保存起来。</p>
</blockquote>
<p>trap代码执行流程</p>
<p>syscall:以write为例</p>
<p>write-&gt;查找该函数-&gt;usys.pl产生的汇编(.global write)</p>
<div class="highlight-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate usys.S, the stubs for syscalls.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">my</span> <span class="variable">$name</span> = <span class="keyword">shift</span>;   <span class="comment"># shift是perl脚本之中第一个参数的意思</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;.global <span class="variable">$name</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;<span class="subst">$&#123;name&#125;</span>:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; li a7, SYS_<span class="subst">$&#123;name&#125;</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="regexp">//</span> ......</span><br></pre></td></tr></table></figure></div>

<p>-&gt;ecall-&gt;trampoline.S</p>
<hr>
<p>Q:这一步是怎么过去的？（下面整个流程挺长的）</p>
<p>我查询了一下RISC特权指令文档</p>
<blockquote>
<p>The ECALL instruction is used to make a request to the supporting execution environment, which is usually an operating system. <strong>The ABI for the system will define how parameters for the environment request are passed</strong>, but usually these will be in defined locations in the integer register file.</p>
</blockquote>
<p>文档说让OS设计者自己决定怎么传参数</p>
<p>lec4里面说ecall干了三件事（这是硬件支持的）</p>
<ul>
<li>将代码从user mode改到supervisor mode</li>
<li>将pc保存到sepc</li>
<li>跳转到stvec指向的指令</li>
</ul>
<p>那stvec指向哪里呢？</p>
<p>根据我们Chapter 2里面讲的那个流程往下找，entry.S-&gt;start()-&gt;main-&gt;userinit (注意ecall需要在user space调用)</p>
<p>-&gt; allocproc-&gt;proc_pagetable</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An empty page table.</span></span><br><span class="line">    pagetable = uvmcreate();</span><br><span class="line">    <span class="keyword">if</span> (pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">    <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">    <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">    <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline,</span><br><span class="line">                 PTE_R | PTE_X) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-&gt;trapframe),</span><br><span class="line">                 PTE_R | PTE_W) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里已经发现每个proc都会在alloc的时候有TRAMPOLINE的PTE了，那到底是在哪里改变了stvec呢？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trapinit</span><span class="params">(<span class="type">void</span>)</span> &#123; initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up to take exceptions and traps while in the kernel.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trapinithart</span><span class="params">(<span class="type">void</span>)</span> &#123; w_stvec((uint64)kernelvec); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">    <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">    w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save user program counter.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">        <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">        <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">        intr_on();</span><br><span class="line"></span><br><span class="line">        syscall();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">    <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">    <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">    intr_off();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">    w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">    <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">    p-&gt;trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">    <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">    x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">    x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">    w_sstatus(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">    w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">    uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jump to trampoline.S at the top of memory, which</span></span><br><span class="line">    <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">    <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">    uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">    ((<span class="type">void</span> (*)(uint64, uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>很阴险啊，这个stvec是在forkret调用的userret里面改掉的</p>
<p>userinit并没有改掉stvec</p>
<p>具体地说，回看init.c的代码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>shell实际上是init进程fork的子进程</p>
<p>有趣的是，看syscall.c可以发现，kernel&#x2F;proc里面的fork函数实际上是“sys_fork”，用户的syscall fork只不过是直接再调用一次fork罢了</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">    release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">        <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">        <span class="comment">// be run from main().</span></span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        fsinit(ROOTDEV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个forkret在只在allocproc里面被调用（fork和uvminit调用了allocproc）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br></pre></td></tr></table></figure></div>

<p>init进程是不会返回的，但是在scheduler里面，会调用swtch()</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = RUNNING;</span><br><span class="line"> c-&gt;proc = p;</span><br><span class="line"> swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure></div>

<p>然后swtch会调用下面的swtch.S</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># Context <span class="keyword">switch</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#   void swtch(struct context *old, struct context *new);</span></span><br><span class="line"># </span><br><span class="line"># Save current registers in old. Load from new.	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line"># a0 是c-&gt;context的地址，a1是p-&gt;context的地址</span><br><span class="line">swtch:</span><br><span class="line">        # 把当前cpu的寄存器数据存下来</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 加载调度的p的寄存器数据</span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret  </span><br><span class="line">        # 此时，ra已经被改掉！！！</span><br><span class="line">        # 回去的位置就是forkret了</span><br></pre></td></tr></table></figure></div>

<p>init调度到shell时，swtch.S ret的时候就跳转到了forkret</p>
<p>然后forkret-&gt;usertrapret-&gt;w_stvec</p>
<p><strong>也就是说，第一次的usertrapret是在usertrap前面执行的！</strong></p>
<p>所以，绕了这么大一圈回来</p>
<blockquote>
<p>lec4里面说ecall干了三件事（这是硬件支持的）</p>
<ul>
<li>将代码从user mode改到supervisor mode</li>
<li>将pc保存到sepc</li>
<li>跳转到stvec指向的指令</li>
</ul>
</blockquote>
<p>在下面那个usertrapret之中，stvec改为指向trampoline.S的uservec，并且指定了usertrap位置等信息</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line"><span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">p-&gt;trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br></pre></td></tr></table></figure></div>

<p>所以这就是注释之中<code>re-enter</code>的意思</p>
<p>再后面就是lec里面说的，再后面的syscall</p>
<p>ecall跳转到stvec（uservec），trampoline.S的最后跳转到 TRAMPOLINE + 16</p>
<p>参考trapframe</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">    <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">    <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap(), 就在上面p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>就是跳转到了usertrap</p>
<p>然后usertrap-&gt;syscall()-&gt;根据a7找到sys_write()</p>
<p>之后再通过usertrapret-&gt;userret-&gt;sret返回用户空间，继续执行指令</p>
<blockquote>
<p>sret是我们在kernel中的最后一条指令，当我执行完这条指令：</p>
<ul>
<li><p>程序会切换回user mode</p>
</li>
<li><p>SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</p>
</li>
<li><p>重新打开中断</p>
</li>
</ul>
</blockquote>
<hr>
<p>ps1 如果在kernel space里面调用ecall会怎么样？</p>
<p>在lab3之中，经常能看到在userinit成功启动之前，内核就出错了，但是我们依然能得到一些打印信息</p>
<p>首先说说为什么能够打印，</p>
<p>从printf一步步往里面看，找到console.c里面的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send one character to the uart.</span></span><br><span class="line"><span class="comment">// called by printf, and to echo input characters,</span></span><br><span class="line"><span class="comment">// but not from write().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意没有用write!!</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说xv6只是将数据发送到UART的control register（qemu模拟且约定位置），而qemu负责将UART的地址上的数据输出到终端</p>
<blockquote>
<p>在xv6操作系统中，打印操作是通过UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发器）的控制寄存器实现的。当xv6需要打印字符时，它会将字符写入UART的数据寄存器。UART硬件会自动将数据寄存器中的字符发送出去。</p>
<p>在QEMU模拟器中，UART被模拟为一个虚拟设备。当xv6将字符写入UART数据寄存器时，QEMU会捕获这个操作，并将字符输出到宿主机的终端或者其他输出设备。这样，虽然xv6认为它是在操作UART硬件，但实际上它的输出被QEMU重定向到了宿主机的终端</p>
</blockquote>
<p>在kernel&#x2F;main.c的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">trapinithart();  <span class="comment">// install kernel trap vector</span></span><br></pre></td></tr></table></figure></div>

<p>里面</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trapinit</span><span class="params">(<span class="type">void</span>)</span> &#123; initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up to take exceptions and traps while in the kernel.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trapinithart</span><span class="params">(<span class="type">void</span>)</span> &#123; w_stvec((uint64)kernelvec); &#125; <span class="comment">// 初始化stvec为kernelvec</span></span><br></pre></td></tr></table></figure></div>

<p>kernelvec里面又有啥呢？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap // 这里call,ret是伪指令，被汇编器转换成jal和jalr</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        // not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br><span class="line"></span><br><span class="line">        #</span><br><span class="line">        # machine-mode timer interrupt.</span><br><span class="line">        #</span><br></pre></td></tr></table></figure></div>

<p>其中kerneltrap</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kerneltrap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">    uint64 sepc = r_sepc();</span><br><span class="line">    uint64 sstatus = r_sstatus();</span><br><span class="line">    uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (intr_get() != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((which_dev = devintr()) == <span class="number">0</span>) &#123; <span class="comment">// 这里是我们常见报错的地方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">    <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">    w_sepc(sepc);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>devintr,由于我们代码写错的scause比如页表的错误（0x000000000000000f），既不是0x8开头的外部设备中断，也不是计时器中断，就会触发panic</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">devintr</span><span class="params">()</span> &#123;</span><br><span class="line">    uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp; (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">        <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (irq == UART0_IRQ) &#123;</span><br><span class="line">            uartintr();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (irq == VIRTIO0_IRQ) &#123;</span><br><span class="line">            virtio_disk_intr();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (irq) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">        <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">        <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">        <span class="keyword">if</span> (irq)</span><br><span class="line">            plic_complete(irq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scause == <span class="number">0x8000000000000001</span>L) &#123;</span><br><span class="line">        <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">        <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            clockintr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">        <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">        w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而如果devintr没有问题，通过sepc再次改变了控制流</p>
<p>那sepc现在在哪里呢？前面保存的原来的pc，也就是回到原来代码继续执行了</p>
<hr>
<p>ps2 （ecall的时候）为什么是a7?</p>
<blockquote>
<p>The ECALL instruction is used to make a request to the supporting execution environment, which is usually an operating system. <strong>The ABI for the system will define how parameters for the environment request are passed</strong>, but usually these will be in defined locations in the integer register file.</p>
</blockquote>
<p>文档说让OS设计者自己决定怎么传参数</p>
<p>而riscv-gnu-toolchain 和Linux的做法（设计）是</p>
<p>a0~a5可以放参数，a7放syscall number，所以单纯是一个约定问题</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64 <span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>由于riscv没有硬件指令上强制ecall的时候更新页表</p>
<p>也就是说执行ecall前后，都还是user pagetable</p>
<p>所以stvec的地址必须在user space的页表上存在</p>
<p>但trap handler需要在kernel space运行</p>
<p>所以stvec的地址必须在kernel space也存在，并且两者（user space &amp;&amp; kernel space）统一</p>
<p><strong>这就是为什么xv6设计了一个在kernel space和user space都在同一个位置的TRAMPOLINE页</strong>（看Chapter 3的图）</p>
<p>lec6的学生提问很有意思</p>
<blockquote>
<p>学生提问：这个问题或许并不完全相关，read和write系统调用，相比内存的读写，他们的代价都高的多，因为它们需要切换模式，并来回捣腾。有没有可能当你执行打开一个文件的系统调用时， 直接得到一个page table映射，而不是返回一个文件描述符？这样只需要向对应于设备的特定的地址写数据，程序就能通过page table访问特定的设备。你可以设置好限制，就像文件描述符只允许修改特定文件一样，这样就不用像系统调用一样在用户空间和内核空间来回捣腾了。</p>
<p>Robert教授：这是个很好的想法。实际上很多操作系统都提供这种叫做内存映射文件（Memory-mapped file access）的机制，在这个机制里面通过page table，可以将用户空间的虚拟地址空间，对应到文件内容，这样你就可以通过内存地址直接读写文件。实际上，你们将在mmap 实验中完成这个机制。对于许多程序来说，这个机制的确会比直接调用read&#x2F;write系统调用要快的多。</p>
</blockquote>
<p>lec6在这里也插入了一段设计相关的</p>
<blockquote>
<p>所以你现在就会问，为什么ecall不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换page table指针来指向kernel page table，或者自动的设置Stack Pointer指向kernel stack，或者直接跳转到kernel的C代码，而不是在这里运行复杂的汇编代码？</p>
<p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是RISC-V并不会，RISC-V秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。</p>
<ul>
<li><p>举个例子，因为这里的ecall是如此的简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</p>
</li>
<li><p>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不用切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</p>
</li>
<li><p>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要ecall迫使你保存所有的寄存器。</p>
</li>
<li><p>最后，对于某些简单的系统调用或许根本就不需要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动为你完成stack切换是极好的。</p>
</li>
</ul>
<p>所以，ecall尽量的简单可以提升软件设计的灵活性。</p>
</blockquote>
<p>接下来详细讲trap的过程</p>
<p>通过ecall我们达到了trampoline.S</p>
<blockquote>
<p>回到XV6和RISC-V，现在程序位于trampoline page的起始，也是uservec函数的起始。我们现在需要做的第一件事情就是保存寄存器的内容。在RISC-V上，如果不能使用寄存器，基本上不能做任何事情。所以，对于保存这些寄存器，我们有什么样的选择呢？</p>
<p>在一些其他的机器中，<strong>我们或许直接就将32个寄存器中的内容写到物理内存中某些合适的位置。但是我们不能在RISC-V中这样做，因为在RISC-V中，supervisor mode下的代码不允许直接访问物理内存</strong>。所以我们只能使用page table中的内容，但是从前面的输出来看，page table中也没有多少内容</p>
<p>虽然XV6并没有使用，但是另一种可能的操作是，直接将SATP寄存器指向kernel page table，之后我们就可以直接使用所有的kernel mapping来帮助我们存储用户寄存器。这是合法的，因为supervisor mode可以更改SATP寄存器。但是在trap代码当前的位置，也就是trap机制的最开始，我们并不知道kernel page table的地址。并且更改SATP寄存器的指令，要求写入SATP寄存器的内容来自于另一个寄存器。所以，为了能执行更新page table的指令，我们需要一些空闲的寄存器，这样我们才能先将page table的地址存在这些寄存器中，然后再执行修改SATP寄存器的指令。</p>
</blockquote>
<p>关于寄存器在xv6之中是怎么保存和加载的，是使用了csrrw这个指令和sscratch这个额外寄存器，前面提过一些，具体可以看</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert/6.5-uservec" >https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert/6.5-uservec <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>lec6之中还有一个有趣的讨论</p>
<blockquote>
<p>另一个问题是，为什么这些寄存器保存在trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，对于这些编程语言的程序，Stack Pointer不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。比如，编程语言以堆中以小块来分配栈，编程语言的运行时知道如何使用这些小块的内存来作为栈，但是内核并不知道。所以，如果我们想要运行任意编程语言实现的用户程序，内核就不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。所以内核需要自己管理这些寄存器的保存，这就是为什么内核将这些内容保存在属于内核内存的trapframe中，而不是用户内存</p>
</blockquote>
<p>然后lec6在讲usertrap函数的时候有几个值得注意的点</p>
<blockquote>
<p>接下来我们要保存用户程序计数器，它仍然保存在SEPC寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器。</p>
<p>XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。</p>
</blockquote>
<blockquote>
<p>最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</p>
</blockquote>
<blockquote>
<p>另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：</p>
<ul>
<li><p>硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。</p>
</li>
<li><p>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</p>
</li>
</ul>
</blockquote>
<h4 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3 Code: Calling system calls"></a>4.3 Code: Calling system calls</h4><h4 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4 Code: System call arguments"></a>4.4 Code: System call arguments</h4><p>由上所述，调用syscall的时候，实际上内核中真正执行逻辑的sys_xxx函数需要从trapframe而不是寄存器里面取参数</p>
<p>这对应syscall.c的argint, argaddr,argfd等辅助函数</p>
<p>对于别的参数，只是繁琐与否的问题；对于指针参数，有两个挑战：</p>
<ul>
<li>kernel pagetable和user pagetable不同</li>
<li>如何避免恶意指针（例如，指向某个内核特定区域；空指针）</li>
</ul>
<p>fetchstr是一个很好的示范</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);</span><br><span class="line">    <span class="comment">// 这里传入p-&gt;pagetable而不是使用kernel-&gt;pagetable</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样从user space里面，我们得到了物理地址pa</p>
<p>又因为kernel是direct-mapped并且已经映射了所有pa，直接当作kernel的va就行</p>
<h4 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5 Traps from kernel space"></a>4.5 Traps from kernel space</h4><p>在kernel的trap有以下的优势：</p>
<ul>
<li>此时的页表已经是kernel pagetable，不需要切换</li>
<li>此时我们可以确信有一个kernel stack(正如上面讨论的，user process可能没有stack，所以必须要放在trapframe这个实际上是kernel的内存里面)，那么trap的过程之中，可以直接将寄存器存储在内核栈上</li>
</ul>
<p>不同的硬件线程（cpu）当然有不同的kernel stack，这使得kernel trap的进程调度更加方便</p>
<p>鉴于kerneltrap之中yield放弃自己的cpu（发生进程调度）之后，sepc可能被修改，所以在kerneltrap的local variable（在本cpu的kernel stack里面）存储了<code>uint sepc;</code> yield()结束后使用w_sepc(sepc)重新加载自己的trap返回值</p>
<p>在usertrap之中，先是ecall进入trampoline.S的uservec,再进入usertrap</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">    <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">    w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save user program counter.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">        <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">        <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">        intr_on();</span><br><span class="line"></span><br><span class="line">        syscall();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这里改成<code>w_stvec((uint64)kernelvec);</code>切换成kernel的stvec是因为此时在内核态了，如果在处理trap的中间再发生trap（虽然这里关闭了中断但还有其他可能的trap）,此时应该是kernel trap</p>
<p>然后后面ret的时候再改回uservec，这样反复横跳，达成稳定的循环</p>
<blockquote>
<p>即使关闭了中断，处理器仍然可以响应一些特定的trap。例如，处理器可以响应同步异常，如除以零、访问无效内存地址等。这些异常是由执行指令本身引起的，与是否开启中断无关。此外，处理器也可以响应一些非屏蔽中断（non-maskable interrupts），这些中断是由严重的硬件错误引起的，如电源故障或内存错误，它们不能被普通的中断关闭指令阻止。</p>
</blockquote>
<p>而关闭中断是因为此时在kernel space，再ecall的话就寄了</p>
<h4 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h4><p>xv6对exception的处理非常的简单粗暴：</p>
<p>如果是user process触发的exception，kernel就会杀掉这个process</p>
<p>如果是kernel触发的exception，就会触发panic</p>
<p>成熟的OS有COW（Copy On Write）等机制，RISCV实际上能分辨page fault是从load，store还是instruction page fault</p>
<p>实现COW还需要有book keeping机制，此时判断一个物理页是否被释放，就需要额外的一些计数机制，一个物理页可以在多个页表之中出现（出现的数量依赖于fork和page fault,exec和exit）</p>
<p>另一个非常重要的优化是COW机制下，如果只有一个pagetable持有对某个物理页的引用的话，完全可以不copy这个物理页到进程的user memory</p>
<p>pagetable和pagefault结合在一起，能整出一些有趣的机制，比如lazy allocation</p>
<p>当一个进程调用sbrk去尝试取得更多的内存的时候，内核只增长进程的size，但不实际alloc物理页，也不更新PTE</p>
<p>就行COW一样，触发page fault的时候才去实际alloc</p>
<p>这个feature的好处比初步设想的还多：比如对于大的内存申请，lazy allocation能使得内存的增长是随时间慢慢增长的（而不是一口气分配一个大内存）；又比如对于大内存申请，OS实际可以一次page fault给a batch of pages，而不是一个一个page alloc</p>
<p>还有一个广泛使用的feature是demand paging</p>
<p>xv6是eagerly加载的，也就是说会一口气加载整个内核的.text和.data段到内存之中</p>
<p>而现代OS使用demand paging，在加载的时候只是简单的创建pagetable，并将PTE设置成invalid，然后等到访问了这个PTE，触发page fault的时候才会加载数据</p>
<p>还有就是paging in disk，只在内存里面放最常用的数据和代码段，剩下的存到disk里面（称之为page out）并设置PTE为invalid，然后触发page fault之后再从disk里面加载回来（page in）</p>
<p>Linux里面还有比如将一个稀疏大矩阵全部映射到几个page的page fault trick，多种trick综合作用之下，使得Linux进程占用的VA大小反而一般远远大于实际物理实际空间</p>
<p>而使用demand paging,lazy alloction等的另一个好处是：由于现代计算机应用基本都不是空间友好的，都会尽可能取得更多的算力和空间资源来保证响应等特性，所以再大的RAM也会出现内存不足，需要频繁evict内存页的情况，而evict是一个开销不小的操作，alloc的更多，evict的也更多，lazy而不是eagar的策略优势就越明显</p>
<h4 id="4-7-Real-World"><a href="#4-7-Real-World" class="headerlink" title="4.7 Real World"></a>4.7 Real World</h4><p>xv6整个trapframe和TRAMPOLINE的复杂设计实际是RISCV “指令（ecall）尽可能做少的工作”的设计原则推动的</p>
<p>但实际上，一个最简单消除这个复杂转换的机制就是把kernel pagetable复制到每一个user pagetable，然后只是用权限位来控制权限</p>
<p>这样的好处有很多，syscall的代码大大简化，kernel可以直接解引用user pointer，etc；许多生产级操作系统采用了这种设计</p>
<p>xv6之所以设计成trapframe这样是为了保证代码的安全性以及避免考虑上述的kernel PTE和user PTE如何避免重叠的问题。</p>
<p>生产级的OS之中，不仅要有前面的COW, demand paging, paging in disk,lazy allocation，还要有mmap, cache buffer等许多机制，以及爆内存时候的妥善处理方法（xv6如果爆内存了就直接返回error或者kill应用程序）</p>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> xv6 book</li>
        <li><strong>Author:</strong> Ayanami</li>
        <li><strong>Created at
                :</strong> 2024-07-11 00:00:00</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-07-11 23:54:52
            </li>
        
        <li>
            <strong>Link:</strong> https://ayanami1314.github.io/2024/07/11/xv6-book/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        

        
  <div class="recommended-article px-2 sm:px-6 md:px-8">
   <div class="recommended-desktop">
    <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/2024/07/11/11-14-11-26学习双周记：/" title="11.14-11.26学习双周记" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="11.14-11.26学习双周记" class="!max-w-none">
  <span class="title">11.14-11.26学习双周记</span>
</a><a class="recommended-article-item" href="/2024/07/11/ics备考/" title="ics备考" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="ics备考" class="!max-w-none">
  <span class="title">ics备考</span>
</a><a class="recommended-article-item" href="/2024/07/11/浅入理解断点和调试器/" title="浅入理解断点和调试器" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="浅入理解断点和调试器" class="!max-w-none">
  <span class="title">浅入理解断点和调试器</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/2024/07/11/11-14-11-26学习双周记：/" title="11.14-11.26学习双周记" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="11.14-11.26学习双周记" class="!max-w-none">
  <span class="title">11.14-11.26学习双周记</span>
</a><a class="recommended-article-item" href="/2024/07/11/ics备考/" title="ics备考" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="ics备考" class="!max-w-none">
  <span class="title">ics备考</span>
</a></div>
   </div>
  </div>

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/07/11/ts%E5%9F%BA%E7%A1%80/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">ts基础</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/07/11/%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E8%B7%91cpp%E6%B5%8B%E8%AF%95%E7%9A%84%E7%8A%AF%E8%A0%A2%E8%AE%B0%E5%BD%95/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">一次使用python脚本跑cpp测试的犯蠢记录</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">xv6 book</div>
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-1"><span class="nav-text">Chapter 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-2"><span class="nav-text">Chapter 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-3-Page-tables"><span class="nav-text">Chapter 3: Page tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-4-Traps-and-system-calls"><span class="nav-text">Chapter 4: Traps and system calls</span></a></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Ayanami</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        27 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.4</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
