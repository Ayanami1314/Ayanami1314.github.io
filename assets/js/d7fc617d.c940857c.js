"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1375],{7539:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>d,toc:()=>_});var s=t(4848),r=t(8453);const i={title:"cs144 labs(Winter 2024)",author:"ayanami",tags:["cs144","network","labs"],keywords:["cs144","computer networks","labs"],summary:"labs-for-cs144(2024-winter)"},a=void 0,d={permalink:"/blog/cs144 labs",source:"@site/blog/cs144 labs.md",title:"cs144 labs(Winter 2024)",description:"Lab0",date:"2024-11-01T14:11:25.136Z",tags:[{inline:!0,label:"cs144",permalink:"/blog/tags/cs-144"},{inline:!0,label:"network",permalink:"/blog/tags/network"},{inline:!0,label:"labs",permalink:"/blog/tags/labs"}],readingTime:30.18,hasTruncateMarker:!0,authors:[{name:"ayanami"}],frontMatter:{title:"cs144 labs(Winter 2024)",author:"ayanami",tags:["cs144","network","labs"],keywords:["cs144","computer networks","labs"],summary:"labs-for-cs144(2024-winter)"},unlisted:!1,nextItem:{title:"nginx\u57fa\u7840",permalink:"/blog/nginx"}},o={authorsImageUrls:[void 0]},_=[{value:"Lab0",id:"lab0",level:3},{value:"Lab1",id:"lab1",level:3},{value:"Lab2",id:"lab2",level:3},{value:"Lab3",id:"lab3",level:3},{value:"Lab4",id:"lab4",level:3},{value:"Lab5",id:"lab5",level:3},{value:"Lab6",id:"lab6",level:3},{value:"Lab7",id:"lab7",level:3}];function c(e){const n={blockquote:"blockquote",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"lab0",children:"Lab0"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u7eaf\u7eaf\u7684\u70ed\u8eablab, part1\u662f\u7528webget\u7b80\u5355\u8fdb\u884c\u4e2a\u8bf7\u6c42, \u7c7b\u4f3ccsapp\u7684\u7f51\u7edclab part1"}),"\n",(0,s.jsx)(n.p,{children:"part2\u5b57\u7b26\u4e32\u64cd\u4f5c, \u6076\u5fc3\u4e00\u70b9\u7684\u5c31\u662fstring_view\u7684peek\u548c\u4e00\u4e2aring buffer\u4e0d\u592a\u80fd\u517c\u5bb9, \u603b\u4e4b\u6211\u7684\u4ee3\u7801\u6548\u7387\u4e5f\u633a\u4f4e\u7684\u5c31\u4e0d\u62ff\u51fa\u6765\u732e\u4e11\u4e86()"}),"\n",(0,s.jsx)(n.h3,{id:"lab1",children:"Lab1"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u6c42\u5b9e\u73b0tcp\u5b57\u8282\u6d41\u62bd\u8c61\u7684\u91cd\u7ec4\u90e8\u5206Reassembler"}),"\n",(0,s.jsx)(n.p,{children:"\u8c03\u7684\u65f6\u5019\u8fd8\u662f\u5f88\u6076\u5fc3\u7684, \u975e\u5e38\u591a\u7684edge case, \u5efa\u8bae\u597d\u597d\u770b\u6d4b\u8bd5\u662f\u600e\u4e48\u6784\u9020\u7684"}),"\n",(0,s.jsx)(n.p,{children:"\u5199\u7684\u65f6\u95f4\u6700\u4e45\u7684\u4e00\u4e2alab, \u4f46\u8fd9\u91cc\u7b14\u8bb0\u6ca1\u6709\u591a\u5c11, \u56e0\u4e3aLab1\u7ed3\u675f\u5230Lab2\u5f00\u59cb\u7684\u4e24\u4e2a\u661f\u671f\u5e72\u522b\u7684\u53bb\u8bb0\u4e0d\u6e05\u5f53\u65f6\u7684\u611f\u53d7\u4e86()"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd8\u662f\u653e\u4e2a\u6e90\u4ee3\u7801"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "reassembler.hh"\n\x3c!--truncate--\x3e#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iostream>\nusing namespace std;\n\nvoid Reassembler::insert( uint64_t first_index, string data, bool is_last_substring )\n{\n  // Your code here.\n  (void)first_index;\n  (void)data;\n  (void)is_last_substring;\n\n  // NOTE: every byte pushed is valid sequence.\n  // NOTE: cur index to be pushed might be partially pushed before, so need to check\n  // NOTE: "That is, you can assume that there is a unique underlying byte-stream, and all\n  // NOTE: substrings are (accurate) slices of it" ----  package may be lost but not corrupted\n  // NOTE: buffer: start marker next_index, len is available_capacity\n  std::cerr << "first_index: " << first_index << " data: " << data << " is_last_substring: " << is_last_substring\n            << std::endl;\n\n  if ( output_.writer().available_capacity() > buffer.size() ) {\n    // buffer = string( output_.writer().available_capacity() - buffer.size(), \'x\' ) + buffer;\n    buffer.resize( output_.writer().available_capacity() );\n  }\n  // duplicate one, drop\n  if ( first_index + data.size() < next_index ) {\n    return;\n  }\n  if ( first_index + data.size() == next_index ) {\n    if ( is_last_substring ) {\n      output_.writer().close();\n      clear_buffer();\n    }\n    return;\n  }\n  // overlap\n  if ( first_index < next_index ) {\n    assert( first_index + data.size() > next_index );\n    data = data.substr( next_index - first_index, output_.writer().available_capacity() );\n    // add\n    if ( !data.empty() ) {\n      // has some space to contain data\n      write_in_space( data, is_last_substring );\n    }\n    return;\n  }\n  // gap, exceed capacity\n  if ( first_index >= next_index + buffer.size() ) {\n    cerr << "gap: drop package" << endl;\n    return;\n  }\n  // gap, (partially) in capacity, store in buffer\n  if ( first_index > next_index ) {\n    if ( first_index + data.size() > next_index + buffer.size() ) {\n      auto input_size = buffer.size() - ( first_index - next_index );\n      // NOTE: partial overlap cannot be the last\n      find_replace_buffer_item( data.substr( 0, input_size ), first_index, false );\n    } else {\n      find_replace_buffer_item( data, first_index, is_last_substring );\n    }\n    return;\n  }\n\n  // exactly equal, write\n  assert( first_index == next_index );\n  // when data.size() < buffer.size(), substr return data\n  // NOTE: partial overlap cannot be the last\n  if ( data.size() > buffer.size() ) {\n    data = data.substr( 0, buffer.size() );\n    write_in_space( data, false );\n  } else {\n    write_in_space( data, is_last_substring );\n  }\n}\n\nuint64_t Reassembler::bytes_pending() const\n{\n  // Your code here.\n  return bytes_pending_;\n}\n\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#pragma once\n#include \"byte_stream.hh\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <set>\n#include <vector>\nclass Reassembler\n{\nprivate:\n  /**\n   * @brief cut all items start before index\n   */\n  void rebuild_buffer_items( uint64_t index )\n  {\n    int cnt = 0;\n    for ( const auto& item : buffered_items ) {\n      if ( item.index + item.size <= index ) {\n        // NOTE:can be partially overlapped\n        bytes_pending_ -= item.size;\n        cnt++;\n      } else {\n        break;\n      }\n    }\n    if ( cnt > 0 ) {\n      buffered_items.erase( buffered_items.begin(), std::next( buffered_items.begin(), cnt ) );\n    }\n  }\n  void clear_buffer()\n  {\n    buffered_items.clear();\n    buffer.resize( 0 );\n    bytes_pending_ = 0;\n    next_index = 0;\n  }\n  /**\n   * @brief DO buffer opeartions and capacity check OUTSIDE!!!\n   * @param  data\n   * @param  start\n   * @param  is_last_substring\n   */\n  void find_replace_buffer_item( const std::string& data, uint64_t start, bool is_last_substring )\n  {\n    // auto it = find_if( buffered_items.begin(), buffered_items.end(), [start, size]( const auto& item ) {\n    //   return ( item.index <= start && start <= item.size + item.index )\n    //          || ( start <= item.index && item.index <= start + size );\n    // } );\n    assert( start > next_index );\n    auto size = data.size();\n    buffer.replace( start - next_index, size, data );\n    buffered_items.emplace( start, size, is_last_substring );\n    // combine the next item\n    // NOTE: now the set has been sorted\n    std::set<SubStringTuple> new_buffer;\n    uint64_t seg_start = start;\n    uint64_t seg_end = start + size;\n    bool seg_is_last = is_last_substring;\n    for ( const auto& item : buffered_items ) {\n      if ( item.index + item.size >= seg_start && item.index <= seg_start ) {\n        seg_start = item.index;\n      }\n      if ( item.index <= seg_end && item.size + item.index >= seg_end ) {\n        seg_end = item.index + item.size;\n        seg_is_last = item.is_last_substring;\n      }\n    }\n    bytes_pending_ = 0;\n    for ( const auto& item : buffered_items ) {\n      if ( item.index + item.size < seg_start || item.index > seg_end ) {\n        new_buffer.insert( item );\n        bytes_pending_ += item.size;\n      }\n    }\n    new_buffer.emplace( seg_start, seg_end - seg_start, seg_is_last );\n    bytes_pending_ += seg_end - seg_start;\n    buffered_items.clear();\n    buffered_items = new_buffer;\n  }\n  /**\n   * @brief there has enough space(from next_index) to write data in buffer\n   * @param  data\n   */\n  void write_in_space( const std::string& data, bool is_last_substring )\n  {\n    output_.writer().push( data );\n    buffer = buffer.substr( data.size() );\n    next_index += data.size();\n    rebuild_buffer_items( next_index );\n    bool end = is_last_substring;\n    while ( !end ) {\n      auto it = std::find_if( buffered_items.begin(), buffered_items.end(), [this]( const auto& item ) {\n        return item.index <= next_index && item.index + item.size > next_index;\n      } );\n      if ( it == buffered_items.end() ) {\n        break;\n      }\n      assert( it->size > ( next_index - it->index ) );\n      auto append_len = it->size - ( next_index - it->index );\n      output_.writer().push( buffer.substr( 0, append_len ) );\n      buffer = buffer.substr( append_len );\n      next_index += append_len;\n      end = it->is_last_substring;\n      rebuild_buffer_items( next_index );\n    }\n    if ( end ) {\n      clear_buffer();\n      output_.writer().close();\n    }\n  }\n\npublic:\n  // Construct Reassembler to write into given ByteStream.\n  explicit Reassembler( ByteStream&& output )\n    : output_( std::move( output ) )\n    , bytes_pending_( 0 )\n    , buffered_items()\n    , buffer( output.writer().available_capacity(), '\\0' )\n    , next_index( 0 )\n  {}\n\n  /*\n   * Insert a new substring to be reassembled into a ByteStream.\n   *   `first_index`: the index of the first byte of the substring\n   *   `data`: the substring itself\n   *   `is_last_substring`: this substring represents the end of the stream\n   *   `output`: a mutable reference to the Writer\n   *\n   * The Reassembler's job is to reassemble the indexed substrings (possibly out-of-order\n   * and possibly overlapping) back into the original ByteStream. As soon as the Reassembler\n   * learns the next byte in the stream, it should write it to the output.\n   *\n   * If the Reassembler learns about bytes that fit within the stream's available capacity\n   * but can't yet be written (because earlier bytes remain unknown), it should store them\n   * internally until the gaps are filled in.\n   *\n   * The Reassembler should discard any bytes that lie beyond the stream's available capacity\n   * (i.e., bytes that couldn't be written even if earlier gaps get filled in).\n   *\n   * The Reassembler should close the stream after writing the last byte.\n   */\n  void insert( uint64_t first_index, std::string data, bool is_last_substring );\n\n  // How many bytes are stored in the Reassembler itself?\n  uint64_t bytes_pending() const;\n\n  // Access output stream reader\n  Reader& reader() { return output_.reader(); }\n  const Reader& reader() const { return output_.reader(); }\n\n  // Access output stream writer, but const-only (can't write from outside)\n  const Writer& writer() const { return output_.writer(); }\n  struct SubStringTuple\n  {\n    uint64_t index;\n    uint64_t size;\n    bool is_last_substring;\n    bool operator<( const SubStringTuple& rhs ) const\n    {\n      return index < rhs.index || ( index == rhs.index && size < rhs.size );\n    }\n    void setIndex( uint64_t i ) { this->index = i; }\n    void setSize( uint64_t s ) { this->size = s; }\n    void setLast( bool l ) { this->is_last_substring = l; }\n  };\n  uint64_t get_next_index() const { return next_index; }\n  // auto get_remain_capacity() const { return buffer.size(); };\n\nprivate:\n  ByteStream output_;      // the Reassembler writes to this ByteStream\n  uint64_t bytes_pending_; // number of bytes stored in the Reassembler itself\n  std::set<SubStringTuple> buffered_items;\n  std::string buffer;\n  uint64_t next_index;\n};\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lab2",children:"Lab2"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u6c42\u5b9e\u73b0\u4e00\u4e2aTCP receiver, \u5e76\u548cLab1\u4e4b\u4e2d\u7684Reassembler\u5bf9\u63a5, \u5c06\u53d1\u8fc7\u6765\u7684\u4e00\u7cfb\u5217tcp\u5305\u89e3\u5f00\u5e76\u5904\u7406\u5b57\u8282\u6d41"}),"\n",(0,s.jsx)(n.p,{children:"\u9762\u5411\u6d4b\u8bd5\u7f16\u7a0b\u6700\u723d\u7684\u4e00\u96c6"}),"\n",(0,s.jsx)(n.p,{children:"\u4e0d\u5982\u8bf4\u8fd9\u4e2alab\u5c31\u662f\u5728\u5c55\u793a\u4e00\u4e2a\u4e30\u5bcc\u7684\u6d4b\u8bd5\u5e94\u8be5\u662f\u4ec0\u4e48\u6837\u5b50\u7684(15\u884c\u4ee3\u7801\u4e0a\u5343\u884c\u6d4b\u8bd5(\u96fe))"}),"\n",(0,s.jsx)(n.p,{children:"\u4ee3\u7801\u903b\u8f91\u5f88\u7b80\u5355,\u4f46\u6d4b\u8bd5\u4e4b\u4e30\u5bcc\u8ba9\u4f60\u5fc5\u987b\u8003\u8651\u6240\u6709\u7684edge case"}),"\n",(0,s.jsxs)(n.p,{children:["part1 \u662f\u5904\u7406TCP\u534f\u8bae\u4e4b\u4e2d, SeqNo\u662f\u752832\u4f4d\u6574\u6570\u5b58, \u5177\u67094G\u7684\u4e0a\u9650(\u5e76\u4e14\u8fd8\u8981\u8003\u8651\u5230\u968f\u673a\u521d\u59cb\u7684ISN\u6765\u9632\u6b62\u653b\u51fb, \u5b9e\u9645\u53ef\u7528\u8fd8\u4e0d\u52304G),\u4f46\u6211\u4eec\u7684\u7f51\u7edc\u80af\u5b9a\u4e0d\u80fd\u53ea\u80fd\u6700\u591a\u4f204G\u6570\u636e,\u6240\u4ee5\u6211\u4eec\u7684\u5e95\u5c42\u7528\u7684\u662f",(0,s.jsx)(n.code,{children:"uint64_t"}),', \u5c31\u5e26\u6765\u4e86\u4ece32\u4f4d\u7684SeqNo\u548c\u521d\u59cb\u768432\u4f4dISN\u8f6c\u523064\u4f4d\u7684,\u7528\u4e8ereassamble\u768464\u4f4d\u7edd\u5bf9seqNo, \u91c7\u7528\u7684\u662f\u4e00\u4e2a"\u96f6\u70b9+\u6e38\u6807"\u7684\u65b9\u6cd5, ISN\u5c31\u662f\u96f6\u70b9,\u800c\u4f7f\u7528\u5df2\u6709\u7684\u4e0b\u4e00\u4e2a\u7edd\u5bf9SeqNo\u4f5c\u4e3a\u53c2\u8003\u7684\u6e38\u6807\u4ee5\u907f\u514d\u591a\u503c\u6027, \u4eceSeqNo\u548cISN\u7684"\u5dee\u503c"\u53ef\u4ee5\u5f97\u5230\u5b9e\u9645\u4e0a64\u4f4d\u7684\u7edd\u5bf9index\u7684\u4f4e32\u4f4d, \u800c\u9ad8\u4f4d\u662f\u8fdb\u4f4d\u8fd8\u662f\u9000\u4f4d\u8fd8\u662f\u4e0d\u53d8\u5219\u6839\u636e\u6e38\u6807\u51b3\u5b9a.']}),"\n",(0,s.jsx)(n.p,{children:"\u6211\u7684\u4ee3\u7801\u5982\u4e0b, \u611f\u89c9\u5176\u5b9e\u662f\u5199\u590d\u6742\u4e86, \u4f46\u601d\u8def\u8fd8\u662f\u6e05\u6670\u7684"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'Wrap32 Wrap32::wrap( uint64_t n, Wrap32 zero_point )\n{\n  // Your code here.\n  (void)n;\n  (void)zero_point;\n  return zero_point + static_cast<uint32_t>( n );\n}\n\nuint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const\n{\n  // Your code here.\n  (void)zero_point;\n  (void)checkpoint;\n  uint32_t mask = 0xFFFFFFFF;\n  uint32_t cp_low = checkpoint & mask;\n  uint32_t diff = 0;\n  if ( this->raw_value_ > zero_point.raw_value_ ) {\n    diff = this->raw_value_ - zero_point.raw_value_;\n  } else {\n    uint32_t gap = zero_point.raw_value_ - this->raw_value_;\n    diff = 0xFFFFFFFF - gap + 1;\n  }\n  // std::cout << "cp_low:" << cp_low << " ,diff:" << diff << ",checkpoint:" << checkpoint << std::endl;\n  if ( diff > cp_low ) {\n    if ( diff - cp_low < 0x80000000 ) {\n      return checkpoint - cp_low + diff;\n    } else {\n      uint64_t a = static_cast<uint64_t>( 0x80000000 ) << 1;\n      // HINT: a "less than 0" abs seqNo means nothing\n      return checkpoint - cp_low + diff > a ? checkpoint - cp_low + diff - a : checkpoint - cp_low + diff;\n    }\n  } else {\n\n    if ( cp_low - diff < 0x80000000 ) {\n      return checkpoint - cp_low + diff;\n    } else {\n      return checkpoint - cp_low + diff + ( static_cast<uint64_t>( 0x80000000 ) << 1 );\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"\u5728part2\u4e4b\u4e2d, TCP receiver\u9700\u8981\u4f20\u7ed9lab1\u4e4b\u4e2d\u5199\u597d\u7684reassembler index\u6570\u636e"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u91cc\u7684index\u53c8\u662f\u5b57\u8282\u6d41\u7684index, \u548c\u6211\u4eecabs SeqNo\u53c8\u6709\u5dee\u522b:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SYN, FIN\u8fd9\u79cd\u5305\u662f\u53ef\u4ee5\u5e26\u4e00\u4e2a\u7a7adata\u7684, \u5e76\u4e14\u8fd9\u4e9b\u5360\u636e\u4e86SeqNo\u7684\u5305\u53ef\u4ee5\u5199\u5165\u6570\u636e\u6d41(\u5982\u679c\u4e0d\u5e26data)"}),"\n",(0,s.jsx)(n.li,{children:"SYN, FIN\u8fd9\u79cd\u6807\u5fd7\u4f4d\u662f\u53ef\u4ee5\u5171\u5b58\u7684, \u867d\u7136\u8fd9\u4e0d\u662f\u4e00\u4e2a\u6807\u51c6TCP\u884c\u4e3a, \u4f46\u53ef\u4ee5\u662f\u5bf9\u65b9\u7684bug, \u4e5f\u53ef\u4ee5\u662f\u9b54\u6539\u534f\u8bae, \u786c\u4ef6\u4e0a\u5e76\u6ca1\u6709\u5bf9\u5171\u5b58\u6027\u505a\u6821\u9a8c, \u672c\u673a\u9700\u8981\u80fd\u5904\u7406, \u5178\u578b\u7684\u5982 SYN+data+FIN"}),"\n",(0,s.jsxs)(n.li,{children:["RST\u7684\u5904\u7406\u662f\u7b80\u5316\u7684, \u6587\u6863\u5bf9RST\u7684\u8bf4\u660e\u5e76\u4e0d\u8be6\u7ec6, \u6d4b\u8bd5\u4e2d\u5c31\u662f\u7b80\u5355\u7684",(0,s.jsx)(n.code,{children:"RST bit <-> Stream Error"}),", \u67e5\u8be2\u4e86\u4e00\u4e0b\u8d44\u6599, \u4ee5\u4e0b\u60c5\u51b5\u90fd\u53ef\u4ee5\u4ea7\u751fRST","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u76ee\u7684\u5730\u4e3a\u67d0\u7aef\u53e3\u7684",(0,s.jsx)(n.code,{children:"SYN"}),"\u5230\u8fbe\uff0c\u7136\u800c\u5728\u8be5\u7aef\u53e3\u4e0a\u5e76\u6ca1\u6709\u6b63\u5728\u76d1\u542c\u7684\u670d\u52a1\u5668\uff1b"]}),"\n",(0,s.jsx)(n.li,{children:"TCP\u60f3\u53d6\u6d88\u4e00\u4e2a\u5df2\u6709\u8fde\u63a5\uff1b(\u5f02\u5e38\u4e2d\u6b62\u7b49, \u6b64\u65f6\u4f1a\u4e22\u5f03\u5df2\u6709\u7684\u4e00\u4e9b\u4fe1\u606f, \u5982\u7f13\u51b2\u533a\u6570\u636e, \u53c8\u6bd4\u5982TCP\u4fdd\u6d3b\u673a\u5236+\u68c0\u6d4b\u5230\u5bf9\u65b9\u4e0d\u53ef\u8fbe)"}),"\n",(0,s.jsx)(n.li,{children:"TCP\u63a5\u6536\u5230\u4e00\u4e2a\u6839\u672c\u4e0d\u5b58\u5728\u7684\u8fde\u63a5\u4e0a\u7684\u5206\u8282\u3002(\u4f8b\u5982\u5df2\u7ecf\u5173\u95ed\u53c8\u6536\u5230)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"\u9664\u4e86index\u548cabs SeqNo\u8f6c\u6362,\u8fd8\u6709\u5c31\u662fwindow size\u7684\u8bbe\u7f6e(\u4f9d\u8d56\u4e8e\u53ef\u7528\u7a7a\u95f4\u7684\u68c0\u6d4b)\u548cISN\u7684\u8bbe\u7f6e, RST\u7684\u5904\u7406, \u6700\u540e\u7684\u4ee3\u7801\u5982\u4e0b"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "tcp_receiver.hh"\n#include "tcp_sender_message.hh"\n#include "wrapping_integers.hh"\n#include <cstdint>\n\nusing namespace std;\n\nvoid TCPReceiver::receive( TCPSenderMessage message )\n{\n  // Your code here.\n  (void)message;\n  if ( message.SYN ) {\n    isn_ = Wrap32( message.seqno );\n  }\n  if ( message.RST ) {\n    reassembler_.reader().set_error();\n  }\n  if ( !isn_ ) {\n    return;\n  }\n  uint64_t checkpoint = reassembler_.get_next_index();\n  // 1: SYN\n  uint64_t data_index = message.seqno.unwrap( isn_.value(), checkpoint ) + message.SYN - 1;\n  reassembler_.insert( data_index, message.payload, message.FIN );\n}\n\nTCPReceiverMessage TCPReceiver::send() const\n{\n  // Your code here.\n  // return {};\n  TCPReceiverMessage msg;\n  msg.window_size = reassembler_.writer().available_capacity() > UINT16_MAX\n                      ? UINT16_MAX\n                      : reassembler_.writer().available_capacity();\n  // +1: SYN seqNo\n  if ( reassembler_.writer().has_error() ) {\n    msg.RST = true;\n  }\n  if ( !isn_.has_value() ) {\n    return msg;\n  }\n\n  msg.ackno\n    = Wrap32::wrap( reassembler_.writer().bytes_pushed() + 1 + reassembler_.writer().is_closed(), isn_.value() );\n  return msg;\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lab3",children:"Lab3"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u6c42\u5b9e\u73b0\u53d1\u9001\u7aefTCP Sender, \u4e3b\u8981\u662f\u5bf9\u6839\u636ewindow size\u7b49\u8fdb\u884c\u5206\u5305\u88c5\u5305\u5e76\u53d1\u9001"}),"\n",(0,s.jsx)(n.p,{children:"\u6709\u4e00\u8bf4\u4e00, \u6587\u6863\u867d\u7136\u633a\u8be6\u7ec6\u4e86, \u4f46\u6709\u5730\u65b9\u8fd8\u662f\u4e0d\u662f\u5f88\u6e05\u695a"}),"\n",(0,s.jsx)(n.p,{children:"\u57fa\u672c\u4e0a\u51e0\u4e2a\u51fd\u6570\u91cc\u9762\u600e\u4e48\u5199\u6587\u6863\u91cc\u90fd\u8bb2\u4e86"}),"\n",(0,s.jsx)(n.p,{children:"\u653e\u4e2a\u4e2a\u4eba\u5b9e\u73b0\u5427"}),"\n",(0,s.jsx)(n.p,{children:"\u53ef\u80fd\u9700\u8981\u6ce8\u610f\u7684\u662f\u51e0\u4e2a\u5730\u65b9:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TCPConfig::MAX_PAYLOAD_SIZE"}),"\u53ea\u8ba1\u7b97data\u7684payload, SYN,FIN\u4e0d\u8ba1\u7b97\u5728\u91cc\u9762"]}),"\n",(0,s.jsx)(n.li,{children:"\u5982\u679c\u6709\u521a\u597d\u653e\u4e0d\u4e0bFIN\u7684, \u6309\u7167\u6d4b\u8bd5\u7684\u60f3\u6cd5\u662f\u9700\u8981\u5728\u4e0b\u4e00\u6b21push\u4f20, \u4e0d\u80fd\u7b49\u5f85tick\u91cd\u4f20\u7b49"}),"\n",(0,s.jsx)(n.li,{children:'\u548c\u4e0a\u9762"\u521a\u597d\u653e\u4e0d\u4e0b"\u5bf9\u5e94, receive\u53ef\u4ee5\u63a5\u6536\u4e00\u4e2a\u4e0d\u53d8\u7684seqNo, \u4f46window size\u6539\u53d8, \u9700\u8981\u6ce8\u610f\u5230\u8fd9\u4e00\u70b9\u5e76\u5904\u7406'}),"\n",(0,s.jsx)(n.li,{children:"\u540c\u65f6, \u6839\u636e\u6d4b\u8bd5\u5f97, receive\u5bf9\u4f20\u5165\u7684seqno\u505a\u6821\u9a8c, \u4f46\u4e0d\u5bf9window size\u505a\u6821\u9a8c, \u4e5f\u5c31\u662f\u6539\u53d8window size\u548cseqNo\u600e\u4e48\u6837\u6ca1\u6709\u5173\u7cfb, \u5176\u5b9e\u7ec6\u60f3\u4e5f\u662f\u5408\u7406\u7684, \u6d4b\u8bd5\u7ed9\u4e86\u4e00\u79cd\u60c5\u51b5\u5c31\u662f\u5728\u8fde\u63a5\u5f00\u59cb\u65f6receive\u4e86\u4e00\u4e2aseqNo\u4e3a\u7a7a, \u4f46\u6539\u53d8window size"}),"\n",(0,s.jsx)(n.li,{children:"\u4e0d\u7528\u62c5\u5fc3RST, \u8fd9\u91cc\u57fa\u672c\u6ca1\u6709\u5bf9\u5b83\u8fdb\u884c\u4e25\u683c\u6d4b\u8bd5"}),"\n",(0,s.jsx)(n.li,{children:"\u6ce8\u610f\u6587\u6863\u91cc\u9762\u5199\u7684 window size\u4e3a0 \u7684\u7279\u6b8a\u60c5\u51b5\u4ec5\u5728push\u4e2d\u6210\u7acb, \u5e76\u4e14\u7279\u6b8a\u60c5\u51b5\u4e5f\u53ea\u662f\u6539\u53d8window size\u800c\u4e0d\u662f\u59cb\u7ec8\u67091\u7684\u5bb9\u91cf\u53d1(\u4e2d\u95f4\u5360\u4e86\u5c31\u4e0d\u884c)"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"make_empty_message()"}),"\u53ea\u662f\u6d4b\u8bd5\u7528\u7684, \u8bbe\u7f6e\u597dseqno\u5c31\u884c"]}),"\n",(0,s.jsx)(n.li,{children:"\u591a\u6ce8\u610f\u6d4b\u8bd5\u4e2d\u4ec0\u4e48\u65f6\u5019push\u548cclose\u7ba1\u9053\u4e86"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "tcp_sender.hh"\n#include "byte_stream.hh"\n#include "tcp_config.hh"\n#include "tcp_sender_message.hh"\n#include "wrapping_integers.hh"\n#include <algorithm>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\nuint64_t TCPSender::sequence_numbers_in_flight() const\n{\n  // Your code here.\n  return next_send_segno - received_max_ackno;\n}\n\nuint64_t TCPSender::consecutive_retransmissions() const\n{\n  // Your code here.\n  return timer.get_consecutive_retransmissions();\n}\n\nvoid TCPSender::push( const TransmitFunction& transmit )\n{\n  // Your code here.\n\n  uint64_t has_pushed = 0;\n  bool finished = false;\n  std::cerr << "--- Push Start" << std::endl;\n  if ( finish_send ) {\n    return;\n  }\n\n  if ( input_.reader().is_finished() && !finish_send && sequence_numbers_in_flight() < cur_window_size ) {\n    // HINT: extra fin not send\n    cerr << "extra fin" << endl;\n    auto msg = make_empty_message();\n    msg.FIN = true;\n    if ( next_send_segno == 0 ) {\n      msg.SYN = true;\n    }\n    outstanding_segs.push( { next_send_segno, msg } );\n    next_send_segno += msg.sequence_length();\n    finish_send = true;\n    transmit( msg );\n    return;\n  }\n\n  if ( !timer.is_active() ) {\n    timer.start();\n  }\n  // HINT: window size == 0 \'s push special case\n  auto fake_window_size = cur_window_size == 0 ? 1 : cur_window_size;\n  auto cur_space\n    = fake_window_size > sequence_numbers_in_flight() ? fake_window_size - sequence_numbers_in_flight() : 0;\n\n  while ( has_pushed < cur_space && !finished ) {\n    TCPSenderMessage msg;\n    if ( next_send_segno == 0 ) {\n      msg.SYN = true;\n    }\n    if ( input_.has_error() ) {\n      msg.RST = true;\n    }\n    if ( cur_space - has_pushed > TCPConfig::MAX_PAYLOAD_SIZE + msg.SYN ) {\n      // NOTE: window space > payload\n      uint16_t pkg_sz = TCPConfig::MAX_PAYLOAD_SIZE;\n      read( input_.reader(), pkg_sz, msg.payload );\n      if ( input_.reader().is_finished() ) {\n        msg.FIN = true;\n      }\n    } else {\n      // NOTE: window limit seqno gap instead of actual payload bytes\n      uint16_t pkg_sz = cur_space - has_pushed - msg.SYN;\n      if ( input_.reader().bytes_buffered() < pkg_sz ) {\n        read( input_.reader(), input_.reader().bytes_buffered(), msg.payload );\n        msg.FIN = input_.reader().is_finished();\n      } else {\n        // HINT:for == case, FIN can\'t be send during this push. The **test points** that it should be pushed in\n        // next call of push() if window has enough space (instead of placing it in outstanding segments or other\n        // solutions)\n        read( input_.reader(), pkg_sz, msg.payload );\n      }\n    }\n    if ( msg.FIN ) {\n      finished = true;\n      finish_send = true;\n    }\n\n    msg.seqno = Wrap32( isn_ + next_send_segno );\n\n    if ( msg.sequence_length() == 0 ) {\n      // nothing to send\n      break;\n    }\n    // update outstanding\n    outstanding_segs.push( { next_send_segno, msg } );\n\n    // update next_send\n    next_send_segno += msg.sequence_length();\n\n    std::cerr << "Send: " << msg << std::endl;\n    // send msg\n    transmit( msg );\n    has_pushed += msg.sequence_length();\n  }\n  std::cerr << "--- Push End" << std::endl;\n}\n\nTCPSenderMessage TCPSender::make_empty_message() const\n{\n  // Your code here.\n  TCPSenderMessage msg;\n  msg.seqno = Wrap32( isn_ + next_send_segno );\n  msg.RST = input_.has_error();\n  return msg;\n}\n\nvoid TCPSender::receive( const TCPReceiverMessage& msg )\n{\n  // Your code here.\n  (void)msg;\n  if ( msg.RST ) {\n    this->writer().set_error();\n    timer.reset_all();\n    while ( !outstanding_segs.empty() )\n      outstanding_segs.pop();\n  }\n  if ( msg.ackno.has_value() ) {\n    uint64_t abs_seq = msg.ackno->unwrap( this->isn_, writer().bytes_pushed() );\n    // HINT: check if valid\n    if ( abs_seq > received_max_ackno && abs_seq <= next_send_segno ) {\n      // fully received, remove it\n      while ( !outstanding_segs.empty()\n              && outstanding_segs.top().abs_seq + outstanding_segs.top().msg.sequence_length() <= abs_seq ) {\n        std::cerr << "Receive: " << outstanding_segs.top().msg << std::endl;\n        outstanding_segs.pop();\n      }\n      received_max_ackno = abs_seq;\n      timer.reset_all();\n      timer.start();\n    }\n  }\n  // HINT: not validate the window size change\n  cerr << "change window size to: " << msg.window_size << endl;\n  cur_window_size = msg.window_size;\n}\n\nvoid TCPSender::tick( uint64_t ms_since_last_tick, const TransmitFunction& transmit )\n{\n  // Your code here.\n  (void)ms_since_last_tick;\n  (void)transmit;\n  bool expired = timer.update( ms_since_last_tick );\n  if ( !expired ) {\n    // cerr << "Not expired" << endl;\n    return;\n  }\n  // retransmit earliest seg\n  if ( !outstanding_segs.empty() ) {\n    auto [_, msg] = outstanding_segs.top();\n    transmit( msg );\n    std::cerr << "Retransmit: " << msg << std::endl;\n    if ( cur_window_size != 0 ) {\n      // i. keep track of retransmission\n      timer.add_consecutive_retransmissions();\n      // ii. double the RTO and restart the timer\n      timer.set_rto( 2 * timer.get_rto() );\n      cerr << "Doubled RTO with window size " << cur_window_size << endl;\n    }\n    // reset the time and start\n    timer.clear_timer();\n    timer.start();\n  }\n}\n\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n\n#include "byte_stream.hh"\n#include "retransmit_timer.hh"\n#include "tcp_receiver_message.hh"\n#include "tcp_sender_message.hh"\n#include "wrapping_integers.hh"\n\n#include <cstdint>\n#include <functional>\n#include <list>\n#include <memory>\n#include <optional>\n#include <ostream>\n#include <queue>\n\nclass TCPSender\n{\npublic:\n  /* Construct TCP sender with given default Retransmission Timeout and possible ISN */\n  TCPSender( ByteStream&& input, Wrap32 isn, uint64_t initial_RTO_ms )\n    : input_( std::move( input ) )\n    , isn_( isn )\n    , outstanding_segs()\n    , received_max_ackno( 0 )\n    , next_send_segno( 0 )\n    , cur_window_size( 1 )\n    , timer( initial_RTO_ms )\n    , finish_send( false )\n  {}\n\n  /* Generate an empty TCPSenderMessage */\n  TCPSenderMessage make_empty_message() const;\n\n  /* Receive and process a TCPReceiverMessage from the peer\'s receiver */\n  void receive( const TCPReceiverMessage& msg );\n\n  /* Type of the `transmit` function that the push and tick methods can use to send messages */\n  using TransmitFunction = std::function<void( const TCPSenderMessage& )>;\n\n  /* Push bytes from the outbound stream */\n  void push( const TransmitFunction& transmit );\n\n  /* Time has passed by the given # of milliseconds since the last time the tick() method was called */\n  void tick( uint64_t ms_since_last_tick, const TransmitFunction& transmit );\n\n  // Accessors\n  uint64_t sequence_numbers_in_flight() const;  // How many sequence numbers are outstanding?\n  uint64_t consecutive_retransmissions() const; // How many consecutive *re*transmissions have happened?\n  Writer& writer() { return input_.writer(); }\n  const Writer& writer() const { return input_.writer(); }\n\n  // Access input stream reader, but const-only (can\'t read from outside)\n  const Reader& reader() const { return input_.reader(); }\n\nprivate:\n  // Variables initialized in constructor\n  ByteStream input_;\n  Wrap32 isn_;\n  struct outstanding_pair\n  {\n    uint64_t abs_seq;\n    TCPSenderMessage msg;\n    // priority less, abs_seq greater\n    bool operator<( const outstanding_pair& rhs ) const { return abs_seq > rhs.abs_seq; }\n  };\n  std::priority_queue<outstanding_pair> outstanding_segs;\n  uint64_t received_max_ackno;\n  uint64_t next_send_segno;\n  uint64_t cur_window_size;\n  RetransmitTimer timer;\n  bool finish_send;\n};\n\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n#include <stdexcept>\n#include <stdint.h>\nclass RetransmitTimer\n{\n  uint64_t cur_timer_ms_;\n  uint64_t consecutive_retransmissions;\n  const uint64_t initial_RTO_ms_;\n  uint64_t cur_RTO_ms_;\n  bool active;\n\npublic:\n  RetransmitTimer( uint64_t initial_RTO_ms )\n    : cur_timer_ms_( 0 )\n    , consecutive_retransmissions( 0 )\n    , initial_RTO_ms_( initial_RTO_ms )\n    , cur_RTO_ms_( initial_RTO_ms )\n    , active( false )\n  {}\n  uint64_t get_time_ms_() const { return cur_timer_ms_; }\n\n  // return if expired\n  bool update( uint64_t ms_since_last_tick )\n  {\n    if ( !active ) {\n      throw std::runtime_error( "try to update when timer is not active" );\n    }\n    cur_timer_ms_ += ms_since_last_tick;\n    return cur_timer_ms_ >= cur_RTO_ms_;\n  }\n  void start() { active = true; }\n  void stop() { active = false; }\n  // getter & setter\n  uint64_t get_rto() { return cur_RTO_ms_; }\n  uint64_t get_init_rto() const { return initial_RTO_ms_; }\n  uint64_t get_consecutive_retransmissions() const { return consecutive_retransmissions; }\n  void set_rto( uint64_t rto ) { cur_RTO_ms_ = rto; }\n  void clear_timer()\n  {\n    cur_timer_ms_ = 0;\n    active = false;\n  }\n  void set_consecutive_retransmissions( uint64_t num ) { consecutive_retransmissions = num; }\n  void add_consecutive_retransmissions() { consecutive_retransmissions++; }\n  void reset_rto() { cur_RTO_ms_ = initial_RTO_ms_; }\n  void reset_all()\n  {\n    cur_RTO_ms_ = initial_RTO_ms_;\n    consecutive_retransmissions = 0;\n    cur_timer_ms_ = 0;\n    active = false;\n  }\n  bool is_active() const { return active; }\n};\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lab4",children:"Lab4"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u6c42\u628a\u524d\u9762\u7684\u7ec4\u5408\u8d77\u6765, \u6d4b\u8bd5\u4e00\u4e0bLab1-3\u6784\u5efa\u7684tcp stack\u80fd\u4e0d\u80fd\u6b63\u5e38\u5de5\u4f5c, \u66ff\u6362Lab0\u4e2d\u7684TCPStack\u4e3a\u81ea\u5df1\u7684native\u7248\u672c"}),"\n",(0,s.jsx)(n.p,{children:"checkpoint4\u597d\u50cf\u6d4b\u4e0d\u4e86"}),"\n",(0,s.jsx)(n.p,{children:"\u4e00\u65b9\u9762\u4e0d\u662f\u5f88\u786e\u5b9a\u5b83\u8fd9\u4e2atun\u811a\u672c\u5728\u6211\u7684\u7535\u8111\u4e0a\u7684\u517c\u5bb9\u6027, \u53e6\u4e00\u65b9\u9762webget\u4ed6\u7684\u7f51\u7ad9\u662f\u5899\u7684( , \u8dd1\u6d4b\u8bd5\u5168\u662f\u91cd\u4f20\u91cd\u4f20"}),"\n",(0,s.jsxs)(n.p,{children:["\u770b\u6587\u6863\u4e0b\u9762\u53ef\u4ee5\u6709",(0,s.jsx)(n.code,{children:"./build/tcp_ipv4"}),"\u548c",(0,s.jsx)(n.code,{children:"./build/tcp_native"}),"\u53ef\u4ee5\u88c5\u6a21\u4f5c\u6837\u7684\u81ea\u5df1\u8fde\u81ea\u5df1, \u6211\u53cd\u6b63\u80fd\u8fde\u901a\u5c31\u5f53\u662f\u8dd1\u901a\u4e86(\u4e50)"]}),"\n",(0,s.jsx)(n.p,{children:"\u5173\u4e8e\u4ed6\u7684TUN\u6e90\u7801\u9605\u8bfb: TODO"}),"\n",(0,s.jsx)(n.h3,{id:"lab5",children:"Lab5"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u6c42\u5b9e\u73b0IP\u5c42\u4e4b\u4e2d\u7684ARP(Address Resolution Protocol)\u7684\u7b80\u5316\u7248\u672c, \u5305\u62ec\u6536\u53d1\u6d88\u606f\u548c\u8d85\u65f6\u5220\u9664\u7b49, \u4f46\u5bf9\u4e8e\u4e00\u4e9b\u73b0\u5b9e\u4e4b\u4e2d\u7684\u5176\u4ed6\u673a\u5236(\u4f8b\u5982\u8d85\u65f6\u91cd\u53d1\u548cICMP\u56de\u4fe1\u6ca1\u6709\u8981\u6c42)"}),"\n",(0,s.jsxs)(n.p,{children:["\u770b\u61c2\u4e86\u4ed6\u7684\u4ee3\u7801\u4e4b\u540e\u8fd9\u4e2alab\u5c31\u5f88\u7b80\u5355\u4e86, \u4e3b\u8981\u4ed6\u5df2\u7ecf\u628a\u8f85\u52a9\u51fd\u6570\u90fd\u5199\u5b8c\u4e86(\u8fd9\u4e2a",(0,s.jsx)(n.code,{children:"parse"}),"\u548c",(0,s.jsx)(n.code,{children:"serialize"}),"\u7684\u5b9e\u73b0\u786e\u5b9e\u5f88\u6f02\u4eae, \u4e5f\u7b97\u662f\u5c55\u793a\u4e86cpp\u4e4b\u4e2d\u7684Duck Type\u600e\u4e48\u505a), \u518d\u52a0\u4e0a\u975e\u5e38\u8be6\u7ec6\u7684\u6587\u6863\u548c\u6ce8\u91ca\u8fd8\u6709\u53ef\u4ee5\u4f5c\u4e3a\u6ce8\u91ca\u76f4\u63a5\u8bfb\u7684\u6e90\u4ee3\u7801"]}),"\n",(0,s.jsxs)(n.p,{children:["\u4e5f\u6ca1\u4ec0\u4e48\u8981\u6ce8\u610f\u7684\u5730\u65b9, \u552f\u4e00\u53ef\u4ee5\u6ce8\u610f\u4e0b\u7684\u662f\u5728",(0,s.jsx)(n.code,{children:"recv_frame"})," \u4e4b\u4e2d, \u53ea\u66f4\u65b0sender\u7684",(0,s.jsx)(n.code,{children:"ip, ethernet_addr"}),"\u5bf9, \u4e0d\u7ba1target\u7684"]}),"\n",(0,s.jsx)(n.p,{children:"\u8d34\u4e2a\u4ee3\u7801"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"//......\n\nprivate:\n  // ......\n  std::vector<std::pair<InternetDatagram, Address>> datagrams_to_send_ {};\n  std::map<Address, std::pair<EthernetAddress, uint64_t>> arp_table_;\n  std::map<Address, std::optional<uint64_t>> arp_time_table_;\n  uint64_t now_;\n};\n\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <optional>\n#include <stdexcept>\n#include <utility>\n\n#include "address.hh"\n#include "arp_message.hh"\n#include "ethernet_frame.hh"\n#include "ethernet_header.hh"\n#include "exception.hh"\n#include "ipv4_datagram.hh"\n#include "network_interface.hh"\n#include "parser.hh"\n\nusing namespace std;\n\n//! \\param[in] ethernet_address Ethernet (what ARP calls "hardware") address of the interface\n//! \\param[in] ip_address IP (what ARP calls "protocol") address of the interface\nNetworkInterface::NetworkInterface( string_view name,\n                                    shared_ptr<OutputPort> port,\n                                    const EthernetAddress& ethernet_address,\n                                    const Address& ip_address )\n  : name_( name )\n  , port_( notnull( "OutputPort", move( port ) ) )\n  , ethernet_address_( ethernet_address )\n  , ip_address_( ip_address )\n  , arp_table_()\n  , arp_time_table_()\n  , now_( 0 )\n{\n  cerr << "DEBUG: Network interface has Ethernet address " << to_string( ethernet_address ) << " and IP address "\n       << ip_address.ip() << "\\n";\n}\n\n//! \\param[in] dgram the IPv4 datagram to be sent\n//! \\param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but\n//! may also be another host if directly connected to the same network as the destination) Note: the Address type\n//! can be converted to a uint32_t (raw 32-bit IP address) by using the Address::ipv4_numeric() method.\nvoid NetworkInterface::send_datagram( const InternetDatagram& dgram, const Address& next_hop )\n{\n  // Your code here.\n  (void)dgram;\n  (void)next_hop;\n\n  if ( next_hop != ip_address_ && !arp_table_.contains( next_hop ) ) {\n    cout << "Wait " << next_hop.to_string() << " for arp response" << endl;\n    // ARP broadcast\n    if ( !arp_time_table_.contains( next_hop ) ) {\n      arp_time_table_[next_hop] = std::nullopt;\n    }\n    if ( arp_time_table_[next_hop].has_value() && now_ - arp_time_table_[next_hop].value() < 5000 ) {\n      // < 5s from last arp broadcast\n      datagrams_to_send_.push_back( { dgram, next_hop } ); // wait for arp table update and send.\n      return;\n    }\n    // arp broadcast\n    arp_time_table_[next_hop] = now_;\n    EthernetHeader header { .dst = ETHERNET_BROADCAST, .src = ethernet_address_, .type = EthernetHeader::TYPE_ARP };\n    ARPMessage msg { .opcode = ARPMessage::OPCODE_REQUEST,\n                     .sender_ethernet_address = ethernet_address_,\n                     .sender_ip_address = ip_address_.ipv4_numeric(),\n                     .target_ip_address = next_hop.ipv4_numeric() };\n    auto payload = serialize<ARPMessage>( msg );\n    EthernetFrame frame { .header = header, .payload = payload };\n    datagrams_to_send_.push_back( { dgram, next_hop } ); // wait for arp table update and send.\n    output().transmit( *this, frame );\n\n    return;\n  }\n\n  EthernetAddress dst_ethernet_addr;\n  if ( next_hop == ip_address_ ) {\n    dst_ethernet_addr = ethernet_address_;\n  } else {\n    dst_ethernet_addr = arp_table_.at( next_hop ).first;\n  }\n  // cout << "send datagram to " << next_hop.to_string() << " with ethernet address " << to_string(\n  // dst_ethernet_addr )\n  //      << endl;\n  EthernetHeader header { .dst = dst_ethernet_addr, .src = ethernet_address_, .type = EthernetHeader::TYPE_IPv4 };\n\n  auto payload = serialize<InternetDatagram>( dgram );\n  EthernetFrame frame { .header = header, .payload = payload };\n  output().transmit( *this, frame );\n}\n\n//! \\param[in] frame the incoming Ethernet frame\nvoid NetworkInterface::recv_frame( const EthernetFrame& frame )\n{\n  // Your code here.\n  (void)frame;\n  if ( frame.header.dst != ethernet_address_ && frame.header.dst != ETHERNET_BROADCAST ) {\n    return;\n  }\n  // cout << "recv frame" << endl;\n  bool ok = false;\n  if ( frame.header.type == EthernetHeader::TYPE_IPv4 ) {\n    InternetDatagram received_ipv4;\n    ok = parse<InternetDatagram>( received_ipv4, frame.payload );\n    if ( ok ) {\n      datagrams_received_.push( received_ipv4 );\n    }\n  } else if ( frame.header.type == EthernetHeader::TYPE_ARP ) {\n    ARPMessage received_arp;\n    ok = parse<ARPMessage>( received_arp, frame.payload );\n    if ( !ok ) {\n      std::cerr << "Incorrect arp message" << std::endl;\n    }\n    Address sender_ip = Address::from_ipv4_numeric( received_arp.sender_ip_address );\n    arp_table_.insert( std::make_pair( sender_ip, std::make_pair( received_arp.sender_ethernet_address, now_ ) ) );\n    arp_time_table_.insert( { sender_ip, now_ } );\n\n    // cout << "update " << ip_address_.ip() << "\'s table from arp response: " << sender_ip.ip() << " -> "\n    //      << to_string( received_arp.sender_ethernet_address ) << endl;\n    // cout << "Waiting datagrams: " << datagrams_to_send_.size() << endl;\n    for ( auto it = datagrams_to_send_.begin(); it != datagrams_to_send_.end(); ) {\n      // cout << "check " << ip.to_string() << endl;\n      auto [d, ip] = *it;\n      if ( sender_ip == ip ) {\n        // std::cerr << "send " << ip.ipv4_numeric() << std::endl;\n        send_datagram( d, ip );\n        it = datagrams_to_send_.erase( it );\n      } else {\n        it++;\n      }\n    }\n    if ( received_arp.opcode == ARPMessage::OPCODE_REQUEST\n         && received_arp.target_ip_address == ip_address_.ipv4_numeric() ) {\n      ARPMessage respond;\n      respond.target_ethernet_address = received_arp.sender_ethernet_address;\n      respond.target_ip_address = received_arp.sender_ip_address;\n      respond.sender_ip_address = ip_address_.ipv4_numeric();\n      respond.sender_ethernet_address = ethernet_address_;\n      respond.opcode = ARPMessage::OPCODE_REPLY;\n      EthernetHeader respond_header {\n        .dst = respond.target_ethernet_address, .src = ethernet_address_, .type = EthernetHeader::TYPE_ARP };\n      EthernetFrame respond_frame { .header = respond_header, .payload = serialize<ARPMessage>( respond ) };\n      output().transmit( *this, respond_frame );\n    }\n  } else {\n    throw std::runtime_error( "Not Implemented" );\n  }\n}\n\n//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method\nvoid NetworkInterface::tick( const size_t ms_since_last_tick )\n{\n  // Your code here.\n  (void)ms_since_last_tick;\n  now_ += ms_since_last_tick;\n  cout << "tick " << ms_since_last_tick << endl;\n  for ( auto it = arp_table_.begin(); it != arp_table_.end(); ) {\n    if ( now_ - it->second.second >= 30000 ) {\n      // expired\n\n      for ( auto to_send_it = datagrams_to_send_.begin(); to_send_it != datagrams_to_send_.end(); ) {\n        if ( to_send_it->second == it->first ) {\n          to_send_it = datagrams_to_send_.erase( to_send_it );\n        } else {\n          to_send_it++;\n        }\n      }\n      it = arp_table_.erase( it );\n\n    } else {\n      it++;\n    }\n  }\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lab6",children:"Lab6"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u4e2alab\u8981\u5728lab5\u7684\u57fa\u7840\u4e0a\u5199\u4e2arouter(\u4e0d\u5305\u62ec\u5efa\u8868\u7b97\u6cd5, \u5047\u8bbe\u8868\u5df2\u7ecf\u5efa\u597d, \u5199follow\u8868\u7684\u90e8\u5206)"}),"\n",(0,s.jsx)(n.p,{children:"\u6709\u4e00\u4e2a\u5927\u5751"}),"\n",(0,s.jsx)(n.p,{children:'\u8fd9\u4e2atransmit\u4e4b\u540e\u505a\u68c0\u67e5\u5728\u6a21\u62df\u7f51\u7edc\u91cc\u9762\u662f\u7acb\u5373\u53d1\u751f\u7684\u4e8b\u60c5\u800c\u4e0d\u662f\u4e00\u4e2a"\u5f02\u6b65\u64cd\u4f5c", \u6240\u4ee5\u5982\u679c\u5148transmit, \u518d\u4fee\u6539\u672c\u5730, \u6bd4\u5982\u8fd9\u6837'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"    output().transmit( *this, frame );\n    datagrams_to_send_.push_back( { dgram, next_hop } ); // wait for arp table update and send.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["\u5728checkpoint5\u4e4b\u4e2d\u6ca1\u6709\u4efb\u4f55\u95ee\u9898, \u4f46\u5728checkpoint6\u4e4b\u4e2d\u5c31\u4f1a\u4e00\u76f4\u5224\u65ad",(0,s.jsx)(n.code,{children:"datagrams_to_send_"}),"\u662f\u7a7a, \u4ece\u800c\u4e00\u76f4\u62a5",(0,s.jsx)(n.code,{children:"not received"})]}),"\n",(0,s.jsx)(n.p,{children:"(\u4e5f\u5c31\u662ftransmit\u4e86arp req, \u518d\u8fd4\u56de\u4e86 arp res, \u6b64\u65f6\u7b49\u5f85\u7684datagrams\u8fd8\u6ca1\u6709\u88ab\u66f4\u65b0)"}),"\n",(0,s.jsx)(n.p,{children:"\u8fd8\u6709\u51e0\u4e2a\u6211\u6389\u8fdb\u53bb\u7684\u5751\u70b9"}),"\n",(0,s.jsxs)(n.p,{children:["\u4e00\u4e2a\u662f",(0,s.jsx)(n.code,{children:" datagrams_received()"}),"\u8fd4\u56de\u7684\u5f15\u7528\u5982\u679c\u76f4\u63a5\u7528",(0,s.jsx)(n.code,{children:"auto"}),"\u63a5, auto\u63a5\u5f15\u7528\u4f1a\u8f6c\u6362\u6210\u526f\u672c, \u540e\u9762\u5c31\u4f1a\u51fa\u9519, \u5e76\u4e14\u6781\u5176\u96bede"]}),"\n",(0,s.jsx)(n.p,{children:"\u53e6\u4e00\u4e2a\u662f\u4e00\u4e2ainterface\u4e0b\u53ef\u4ee5\u6709\u591a\u4e2ahost, \u6240\u4ee5\u5728\u5b58\u7684\u65f6\u5019\u9700\u8981\u628a\u540c\u4e00\u4e2arule\u4e0b\u7684\u4e0d\u540c\u7684next_hop\u5b58\u597d,\u800c\u4e0d\u662f\u76f4\u63a5insert"}),"\n",(0,s.jsxs)(n.p,{children:["\u5176\u5b9e\u5f00\u59cb\u7684\u65f6\u5019\u6211\u4e00\u76f4\u6ca1\u641e\u6e05\u695a\u4e3a\u5565\u6446\u4e86\u4e00\u4e2a",(0,s.jsx)(n.code,{children:"void route(void)"})," , \u6211\u7684\u60f3\u6cd5\u603b\u662f",(0,s.jsx)(n.code,{children:"void route(const InternetDatagram& dgram)"})]}),"\n",(0,s.jsx)(n.p,{children:"\u540e\u6765\u624d\u60f3\u660e\u767d\u4ed6\u662f\u8981\u5bf9receive\u7684\u6570\u636e\u5305\u505a\u5904\u7406, \u6bcf\u4e00\u4e2aNetworkInterface\u5c31\u7b49\u6548\u4e8erouter\u7684\u4e00\u4e2a\u51fa\u5165\u53e3, \u800c\u4e0d\u662f\u67d0\u79cd\u7ec8\u7aef, \u6240\u4ee5\u6536\u5305\u4e4b\u540e\u9700\u8981\u8fc7\u8def\u7531"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["There\u2019s a beauty (or at least a successful abstraction) in the Internet\u2019s design here: the router never thinks about TCP, about ARP, or about Ethernet frames. The router doesn\u2019t even know what the link layer looks like. The router only thinks about Internet datagrams, and only interacts with the link layer through the NetworkInterface\nabstraction. When it comes to questions like, \u201cHow are link-layer addresses resolved?\u201d or \u201cDoes the link layer even have its own addressing scheme distinct from IP?\u201d or \u201cWhat\u2019s the format of the link-layer frames?\u201d or \u201cWhat\u2019s the meaning of the datagram\u2019s payload?\u201d, ",(0,s.jsx)(n.strong,{children:"the router just doesn\u2019t care."})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"\u8fd9\u91cc\u76f8\u5f53\u4e8e\u8f6f\u4ef6\u4e0a\u8f6e\u8be2\u6bcf\u4e2a\u63a5\u53e3\u6a21\u62df\u4e00\u4e2a\u786c\u4ef6\u4e0a\u7684\u6536\u5305"}),"\n",(0,s.jsx)(n.p,{children:"\u4ee3\u7801\u5012\u662f\u5f88\u7b80\u5355, \u6bd5\u7adf\u6ca1\u8981\u6c42\u524d\u7f00\u6811\u4e4b\u7c7b, \u5c31\u76f4\u63a5\u7b80\u5355\u5316\u4e86"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "router.hh"\n#include "address.hh"\n#include "ipv4_datagram.hh"\n\n#include <algorithm>\n#include <iostream>\n#include <optional>\n#include <stdexcept>\n\nusing namespace std;\n\nbool Router::match( uint32_t address, const RuleKey& r ) const\n{\n  if ( r.len > 32 ) {\n    throw std::runtime_error( "Invalid len" );\n  }\n  uint32_t mask = 0xFFFFFFFF;\n  for ( int i = 0; i < 32 - r.len; ++i ) {\n    mask <<= 1;\n  }\n  // cout << "DEBUG: mask: " << mask << "Rule: " << r.rule << endl;\n\n  return ( address & mask ) == ( r.rule & mask );\n}\n\n// route_prefix: The "up-to-32-bit" IPv4 address prefix to match the datagram\'s destination address against\n// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of\n//    the route_prefix will need to match the corresponding bits of the datagram\'s destination address?\n// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in\n//    which case, the next hop address should be the datagram\'s final destination).\n// interface_num: The index of the interface to send the datagram out on.\nvoid Router::add_route( const uint32_t route_prefix,\n                        const uint8_t prefix_length,\n                        const optional<Address> next_hop,\n                        const size_t interface_num )\n{\n  cerr << "DEBUG: adding route " << Address::from_ipv4_numeric( route_prefix ).ip() << "/"\n       << static_cast<int>( prefix_length ) << " => " << ( next_hop.has_value() ? next_hop->ip() : "(direct)" )\n       << " on interface " << interface_num << "\\n";\n\n  // Your code here.\n  _rules[{ route_prefix, prefix_length }].interface_num = interface_num;\n  _rules[{ route_prefix, prefix_length }].next_hop.push_back( next_hop );\n}\n\n// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.\nvoid Router::route()\n{\n  // Your code here.\n  // cout << "DEBUG: routing from " << _rules.size() << "rules and " << _interfaces.size() << " interfaces" << endl;\n  for ( auto interface : _interfaces ) {\n    // NOTE: & is important\n    auto& queue = interface->datagrams_received();\n    while ( !queue.empty() ) {\n      auto datagram = queue.front();\n\n      cout << interface->name() << " received datagram " << datagram.header.to_string() << endl;\n      cout << endl << endl;\n      queue.pop();\n      if ( datagram.header.ttl <= 1 ) {\n\n        continue;\n      }\n      // decrease ttl and re-calculate the checksum\n      datagram.header.ttl--;\n      datagram.header.compute_checksum();\n      // route: find the interface to send next\n      RuleKey target_key = {};\n      RuleValue target_value = {};\n      target_key.len = 0;\n      bool found = false;\n      // for ( const auto& r : _rules ) {\n      //   cout << r.to_string() << endl;\n      // }\n\n      for ( const auto& r : _rules ) {\n        // NOTE: =, len = 0, 0.0.0.0/0\n        if ( match( datagram.header.dst, r.first ) && r.first.len >= target_key.len ) {\n          target_key = r.first;\n          target_value = r.second;\n          found = true;\n        }\n      } // \u8fd9\u91cc\u663e\u7136\u4e0d\u9700\u8981\u8fd9\u4e2a\u5faa\u73af, \u4f46for simply first\n      if ( !found ) {\n        continue;\n      }\n      cout << Address::from_ipv4_numeric( datagram.header.dst ).ip()\n           << " matched ip: " << Address::from_ipv4_numeric( target_key.rule ).ip() << endl;\n      // cout << "found" << endl;\n      auto send_interface = this->interface( target_value.interface_num );\n      auto next_hops = target_value.next_hop;\n      for ( const auto& hop : next_hops ) {\n        if ( !hop.has_value() ) {\n          send_interface->send_datagram( datagram, Address::from_ipv4_numeric( datagram.header.dst ) );\n          break;\n        }\n        send_interface->send_datagram( datagram, hop.value() );\n      }\n    }\n  }\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lab7",children:"Lab7"}),"\n",(0,s.jsx)(n.p,{children:"\u6ca1\u6709\u961f\u53cb, \u4e5f\u4e0d\u80fd\u7528144\u7684\u670d\u52a1\u5668, \u6d4b\u4e0d\u4e86, \u8fc7"})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>d});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);