"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8844],{55536:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>_,toc:()=>o});var t=r(74848),c=r(28453);const i={},s=void 0,_={id:"Chcore\u6e90\u7801\u9605\u8bfb/rpc/rpc\u57fa\u7840",title:"rpc\u57fa\u7840",description:"\u8fd9\u7ae0\u7684\u4e66\u7c4d\u90e8\u5206\uff08\u7b2c\u516b\u7ae0\uff09\u8bb2\u4e86\u975e\u5e38\u591a\u8bbe\u8ba1\u7684\u6f14\u5316",source:"@site/docs/Chcore\u6e90\u7801\u9605\u8bfb/rpc/rpc\u57fa\u7840.md",sourceDirName:"Chcore\u6e90\u7801\u9605\u8bfb/rpc",slug:"/Chcore\u6e90\u7801\u9605\u8bfb/rpc/rpc\u57fa\u7840",permalink:"/docs/Chcore\u6e90\u7801\u9605\u8bfb/rpc/rpc\u57fa\u7840",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"notesSidebar",previous:{title:"Chcore\u6e90\u7801\u9605\u8bfb",permalink:"/docs/Chcore\u6e90\u7801\u9605\u8bfb/"},next:{title:"\u5b9e\u673a\u4e0e\u6027\u80fd\u4f18\u5316",permalink:"/docs/Chcore\u6e90\u7801\u9605\u8bfb/rpc/\u5b9e\u673a\u4e0e\u6027\u80fd\u4f18\u5316"}},a={},o=[{value:"\u6982\u5ff5\u6f14\u5316\u548c\u8bbe\u8ba1\u601d\u8def",id:"\u6982\u5ff5\u6f14\u5316\u548c\u8bbe\u8ba1\u601d\u8def",level:3},{value:"chcore\u7684ipc\u6e90\u7801\u5206\u6790",id:"chcore\u7684ipc\u6e90\u7801\u5206\u6790",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"\u8fd9\u7ae0\u7684\u4e66\u7c4d\u90e8\u5206\uff08\u7b2c\u516b\u7ae0\uff09\u8bb2\u4e86\u975e\u5e38\u591a\u8bbe\u8ba1\u7684\u6f14\u5316"}),"\n",(0,t.jsx)(n.p,{children:"\u63a8\u8350\u90fd\u53bb\u770b\u770b"}),"\n",(0,t.jsx)(n.h3,{id:"\u6982\u5ff5\u6f14\u5316\u548c\u8bbe\u8ba1\u601d\u8def",children:"\u6982\u5ff5\u6f14\u5316\u548c\u8bbe\u8ba1\u601d\u8def"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u7b80\u5355IPC"}),"\n",(0,t.jsxs)(n.li,{children:["\u6570\u636e\u4f20\u9012","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u57fa\u4e8e\u5171\u4eab\u5185\u5b58\u7684request/response\u6a21\u578b\uff0czero copy"}),"\n",(0,t.jsx)(n.li,{children:"\u57fa\u4e8eOS\u5185\u6838: \u4e24\u6b21\u62f7\u8d1d"}),"\n",(0,t.jsx)(n.li,{children:"L4 \u5fae\u5185\u6838\u7cfb\u7edf\uff1a\u5185\u5b58\u91cd\u6620\u5c04\uff08memory remapping\uff09\u4f18\u5316\uff0c\u4e24\u6b21\u7f29\u5230\u4e00\u6b21\uff08\u4ee5\u53ca\u5b83\u7684\u95ee\u9898\uff09"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\u901a\u77e5\u673a\u5236\uff1a\u63a7\u5236\u6d41\u8f6c\u79fb","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u5355\u5411/\u53cc\u5411\u901a\u4fe1\uff1a\u5171\u4eab\u5185\u5b58\uff0c\u7ba1\u9053\uff0c\u4fe1\u53f7\uff0c\u5957\u63a5\u5b57\uff0c\u2026"}),"\n",(0,t.jsx)(n.li,{children:"\u540c\u6b65/\u5f02\u6b65\u901a\u4fe1\uff1a\u963b\u585e\u8fd8\u662f\u4e0d\u963b\u585e\uff0c \u963b\u585e\u7684\u8bddDoS\u548c\u8d85\u65f6\u65f6\u95f4"}),"\n",(0,t.jsx)(n.li,{children:"\u53cc\u65b9/\u591a\u65b9\u901a\u4fe1"}),"\n",(0,t.jsxs)(n.li,{children:["\u76f4\u63a5/\u95f4\u63a5\u901a\u4fe1\uff1a","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u6743\u9650\u7ba1\u7406\u548c\u5b89\u5168\u95ee\u9898\uff08linux\u7684\u7ed3\u5408fs\u6743\u9650\u68c0\u67e5\uff0c\u73b0\u4ee3\u5fae\u5185\u6838\u7684capability\uff09"}),"\n",(0,t.jsx)(n.li,{children:"\u63a5\u6536\u65b9\u7684\u9009\u62e9\uff08\u8fdb\u7a0b\uff1f\u7ebf\u7a0b\uff1f\u5982\u4f55\u4fdd\u8bc1\u547d\u540d\u670d\u52a1\uff0c\u4f9d\u8d56\u6587\u4ef6\u7cfb\u7edf\u8fd8\u662f\u5168\u5c40\u6807\u8bc6\u7b26\uff0c\u5168\u5c40\u6807\u8bc6\u7b26\u5982\u4f55\u907f\u514d\u653b\u51fb\uff1f\uff09"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"linux\u7684\u7ba1\u9053"}),"\n",(0,t.jsx)(n.li,{children:"\u57fa\u4e8e\u5171\u4eab\u5185\u5b58\u7684IPC"}),"\n",(0,t.jsxs)(n.li,{children:["L4 IPC","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u5bc4\u5b58\u5668\u4e0e\u865a\u62df\u5bc4\u5b58\u5668\u4f20\u9012\u7684\u77ed\u6d88\u606f"}),"\n",(0,t.jsx)(n.li,{children:"\u4ece\u5185\u5b58\u91cd\u6620\u5c04\u5230\u5171\u4eab\u5185\u5b58\u7684\u957f\u6d88\u606f"}),"\n",(0,t.jsxs)(n.li,{children:["\u60f0\u6027\u8c03\u5ea6\u7684\u8bbe\u8ba1\u53d6\u820d","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u4f18\u70b9\uff1a\u5728ipc\u963b\u585e\u6682\u65f6\u7684\u60c5\u51b5\u4e0b\uff0c\u53ea\u4fee\u6539TCB\u51cf\u5c11\u961f\u5217\u64cd\u4f5c\uff0c\u964d\u4f4eTLB miss\u7b49\u5f00\u9500"}),"\n",(0,t.jsx)(n.li,{children:"\u7f3a\u70b9\uff1a\u589e\u52a0\u8c03\u5ea6\u7cfb\u7edf\u590d\u6742\u5ea6\uff0c\u8c03\u5ea6\u65f6\u95f4\u4e0e\u5f53\u524dipc\u5bc6\u5ea6\u8026\u5408\uff0c\u5b9e\u65f6\u7cfb\u7edf\u4e0d\u9002\u7528"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"\u76f4\u63a5\u8fdb\u7a0b\u5207\u6362\u7684\u8bbe\u8ba1\u53d6\u820d\uff1a\u7f13\u5b58\u547d\u4e2d\uff0c\u52a0\u901f\u63a7\u5236\u6d41\u8f6c\u79fb\uff0c\u4ee3\u4ef7\u662f\u53ef\u80fd\u7684\u4f18\u5148\u7ea7\u5931\u6548"}),"\n",(0,t.jsx)(n.li,{children:"\u901a\u4fe1\u8fde\u63a5\uff1a\u76f4\u63a5\u7ebf\u7a0b\u901a\u4fe1\u5e26\u6765\u5168\u5c40ID\u7684\u5b89\u5168\u6027\u95ee\u9898\uff0c\u540e\u7eed\u7cfb\u7edf\u66f4\u503e\u5411\u4e8e\u95f4\u63a5\u901a\u4fe1\uff0c\u91c7\u7528capability\u6743\u9650\u7cfb\u7edf"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"LRPC\u7684\u8bbe\u8ba1\uff1a\u4e0e\u5176\u4f20\u8f93\u6570\u636e\u4e0d\u5982\u4f20\u8f93\u4ee3\u7801\uff08\u8fc1\u79fb\u7ebf\u7a0b\u6a21\u578b\uff09\uff0c\u901a\u8fc7\u4f20\u9012IPC\u670d\u52a1\u8fdb\u7a0b\u7684\u51fd\u6570\u548c\u9875\u8868\uff0c\u4f7f\u5f97\u80fd\u591f\u5728\u672c\u5730\u8fdb\u7a0b\u548c\u672c\u5730\u6838\u4e0a\u4e0d\u901a\u8fc7\u6838\u95f4\u901a\u4fe1\uff0c\u5c06IPI\u53d8\u6210syscall"}),"\n",(0,t.jsx)(n.li,{children:"Chcore\u7684\u8bbe\u8ba1\uff1a\u7c7b\u4f3cL4\u548cLRPC\uff0cserver client\u6ce8\u518c\u670d\u52a1\u540e\u901a\u8fc7capability\u5b50\u7cfb\u7edf\u5b8c\u6210conn\u7684\u5efa\u7acb\uff0c\u4e4b\u540e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6f14\u53d8\u6210syscall sys_ipc_call\u548csys_ipc_ret"}),"\n",(0,t.jsxs)(n.li,{children:["Android\u7684\u8bbe\u8ba1 Binder IPC: \u5f3a\u4f9d\u8d56\u7528\u6237\u6001\u670d\u52a1","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"context manager\u8bbe\u8ba1"}),"\n",(0,t.jsx)(n.li,{children:"\u7ebf\u7a0b\u6c60\u6a21\u578b"}),"\n",(0,t.jsx)(n.li,{children:"binder \u53e5\u67c4\u7684\u4f20\u8f93\u8bbe\u8ba1\uff1a\u7279\u6b8a\u6570\u636e + offset\u907f\u514d\u626b\u63cf\uff0c\u53ef\u4ee5\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49"}),"\n",(0,t.jsx)(n.li,{children:"\u533f\u540d\u5171\u4eab\u5185\u5b58Ashmem\uff1a\u89e3\u51b3mmap\u548csystem v+ipc key\u4e0d\u591f\u7075\u6d3b\u7684\u95ee\u9898"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"chcore\u7684ipc\u6e90\u7801\u5206\u6790",children:"chcore\u7684ipc\u6e90\u7801\u5206\u6790"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"ipc",src:r(56908).A+"",width:"851",height:"569"})}),"\n",(0,t.jsx)(n.p,{children:"\u5148\u6765\u770b\u5934\u6587\u4ef6\u91cc\u9762\u662f\u5982\u4f55\u5b9a\u4e49server_handler\u7684"}),"\n",(0,t.jsx)(n.p,{children:"\u53ef\u4ee5\u770b\u7528\u4e8e\u901a\u4fe1\u7684memory\u4e4b\u4e2d\uff0c\u5934\u90e8\u76848\u4e2a\u5b57\u8282\u7528\u4e8e\u5b58\u50a8ipc response\u7684header(\u5b9e\u9645\u4e0a\u53ea\u6709\u8fd4\u56de\u503c)\uff0c\u800cserver_handler\u4f1a\u63a5\u53d7\u5171\u4eab\u5185\u5b58\u5757\u7684\u5730\u5740\u3001\u957f\u5ea6\u3001\u80fd\u529b\u7684\u4e2a\u6570\u548c\u80fd\u529b\u7ec4ID"}),"\n",(0,t.jsxs)(n.p,{children:["(\u5fd8\u4e86\u80fd\u529b\u7ec4\u4e86\uff1f\u53c2\u8003 ",(0,t.jsx)(n.a,{href:"https://sjtu-ipads.github.io/OS-Course-Lab/Lab3/RTFSC.html",children:"https://sjtu-ipads.github.io/OS-Course-Lab/Lab3/RTFSC.html"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// build/chcore-libc/include/uapi/ipc.h\n// clang-format off\n/**\n * This structure would be placed at the front of shared memory\n * of an IPC connection. So it should be 8 bytes aligned, letting\n * any kinds of data structures following it can be properly aligned.\n * \n * This structure is written by IPC server, and read by client. \n * IPC server should never read from it. \n * \n * Layout of shared memory is shown as follows:\n *           \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *           \u2502   \u2502                                              \u2502\n *           \u2502   \u2502                                              \u2502\n *           \u2502   \u2502     custom data(defined by IPC protocol)     \u2502\n *           \u2502   \u2502                                              \u2502\n *           \u2502   \u2502                                              \u2502\n *           \u2514\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n *             \u2502\n *             \u2502\n *             \u25bc\n *   struct ipc_response_hdr\n */\n// clang-format on\nstruct ipc_response_hdr {\n    unsigned int return_cap_num;\n} __attribute__((aligned(8)));\n\n#define SHM_PTR_TO_CUSTOM_DATA_PTR(shm_ptr) ((void *)((char *)(shm_ptr) + sizeof(struct ipc_response_hdr)))\n\n/**\n * @brief This type specifies the function signature that an IPC server \n * should follow to be properly called by the kernel.\n * \n * @param shm_ptr: pointer to start address of IPC shared memory. Use\n * SHM_PTR_TO_CUSTOM_DATA_PTR macro to convert it to concrete custom\n * data pointer.\n * @param max_data_len: length of IPC shared memory.\n * @param send_cap_num: number of capabilites sent by client in this request.\n * @param client_badge: badge of client.\n */\ntypedef void (*server_handler)(void *shm_ptr, unsigned int max_data_len, unsigned int send_cap_num, badge_t client_badge);\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"\u7136\u540e\u6211\u4eec\u6765\u770b\u5982\u4f55register server"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// user/system-services/chcore-libc/libchcore/porting/overrides/src/chcore-port/ipc.c\n/*\n * Currently, a server thread can only invoke this interface once.\n * But, a server can use another thread to register a new service.\n */\nint ipc_register_server_with_destructor(server_handler server_handler,\n                                        void *(*client_register_handler)(void *),\n                                        server_destructor server_destructor)\n{\n        cap_t register_cb_thread_cap;\n        int ret;\n\n/*\n * Create a passive thread for handling IPC registration.\n * - run after a client wants to register\n * - be responsible for initializing the ipc connection\n */\n#define ARG_SET_BY_KERNEL 0\n        pthread_t handler_tid;\n        register_cb_thread_cap =\n                chcore_pthread_create_register_cb(&handler_tid,\n                                                  NULL,\n                                                  client_register_handler,\n                                                  (void *)ARG_SET_BY_KERNEL);\n        BUG_ON(register_cb_thread_cap < 0);\n        /*\n         * Kernel will pass server_handler as the argument for the\n         * register_cb_thread.\n         */\n        ret = usys_register_server((unsigned long)server_handler,\n                                   (unsigned long)register_cb_thread_cap,\n                                   (unsigned long)server_destructor);\n        if (ret != 0) {\n                printf("%s failed (retval is %d)\\n", __func__, ret);\n        }\n        return ret;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u6838\u5fc3\u662f\u4e24\u4e2a\u51fd\u6570\uff0c"}),"\n",(0,t.jsx)(n.p,{children:"\u4e00\u662fchcore_pthread_create_register_cb\uff0c\u521b\u5efa\u6267\u884c\u6ce8\u518c\u7684pthread\u7ebf\u7a0b\uff0c \u5c06\u5176\u63d2\u5165kernel\u8c03\u5ea6\u542f\u7684ready queue\u4e4b\u4e2d\uff0c\u5e76\u5f97\u5230\u5176\u80fd\u529b\u7ec4\u4f5c\u4e3a\u8fd4\u56de\u503c"}),"\n",(0,t.jsx)(n.p,{children:"\u5728\u51fd\u6570\u4e4b\u4e2d\u8fd8\u5904\u7406\u4e86\u5f88\u591adirty walk, \u4f8b\u5982\u7ebf\u7a0b\u5165\u53e3\u70b9\u6a21\u62df\u51fd\u6570\u8c03\u7528\u7684arch ABI, \u5185\u6838\u6808\u548ctls\u7684\u5de5\u4f5c\u7b49\u7b49"}),"\n",(0,t.jsx)(n.p,{children:"\u4e8c\u662fusys_register_server\uff0c\u4ed6\u53ea\u662f\u6267\u884c\u4e00\u4e2asyscall"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int usys_register_server(unsigned long callback,\n                         cap_t register_thread_cap,\n                         unsigned long destructor)\n{\n        return chcore_syscall3(CHCORE_SYS_register_server,\n                               callback,\n                               register_thread_cap,\n                               destructor);\n}\nint sys_register_server(unsigned long ipc_routine, cap_t register_thread_cap,\n                        unsigned long destructor)\n{\n        return register_server(\n                current_thread, ipc_routine, register_thread_cap, destructor);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"\u8fd9\u4e2asyscall\u5b9e\u9645\u8c03\u7528\u7684\u51fd\u6570\u5982\u4e0b"}),"\n",(0,t.jsx)(n.p,{children:"server\u5c31\u662fcurrent_thread\uff0c\u4e5f\u5c31\u662f\u5b9e\u73b0\u4e86\u7c7b\u4f3cLRPC\u4f18\u5316\u7684\u8bbe\u8ba1"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["\u968f\u540e\u8c03\u7528ChCore\u63d0\u4f9b\u7684\u7684\u7cfb\u7edf\u8c03\u7528\uff1a",(0,t.jsx)(n.code,{children:"sys_register_server"}),"\u3002\u8be5\u7cfb\u7edf\u8c03\u7528\u5b9e\u73b0\u5728",(0,t.jsx)(n.code,{children:"kernel/ipc/connection.c"}),"\u5f53\u4e2d\uff0c\u8be5\u7cfb\u7edf\u8c03\u7528\u4f1a\u5206\u914d\u5e76\u521d\u59cb\u5316\u4e00\u4e2a",(0,t.jsx)(n.code,{children:"struct ipc_server_config"}),"\u548c\u4e00\u4e2a",(0,t.jsx)(n.code,{children:"struct ipc_server_register_cb_config"}),"\u3002\u4e4b\u540e\u5c06\u8c03\u7528\u8005\u7ebf\u7a0b\uff08\u5373\u4e3b\u7ebf\u7a0b\uff09\u7684general_ipc_config\u5b57\u6bb5\u8bbe\u7f6e\u4e3a\u521b\u5efa\u7684",(0,t.jsx)(n.code,{children:"struct ipc_server_config"}),"\uff0c\u5176\u4e2d\u8bb0\u5f55\u4e86\u6ce8\u518c\u56de\u8c03\u7ebf\u7a0b\u548cIPC\u670d\u52a1\u7ebf\u7a0b\u7684\u5165\u53e3\u51fd\u6570\uff08\u5373\u56fe\u4e2d\u7684",(0,t.jsx)(n.code,{children:"ipc_dispatcher"}),"\uff09\u3002\u5c06\u6ce8\u518c\u56de\u8c03\u7ebf\u7a0b\u7684general_ipc_config\u5b57\u6bb5\u8bbe\u7f6e\u4e3a\u521b\u5efa\u7684",(0,t.jsx)(n.code,{children:"struct ipc_server_register_cb_config"}),"\uff0c\u5176\u4e2d\u8bb0\u5f55\u4e86\u6ce8\u518c\u56de\u8c03\u7ebf\u7a0b\u7684\u5165\u53e3\u51fd\u6570\u548c\u7528\u6237\u6001\u6808\u5730\u5740\u7b49\u4fe1\u606f\u3002"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'/*\n * Overall, a server thread that declares a serivce with this interface\n * should specify:\n * @ipc_routine (the real ipc service routine entry),\n * @register_thread_cap (another server thread for handling client\n * registration), and\n * @destructor (one routine invoked when some connnection is closed).\n */\nstatic int register_server(struct thread *server, unsigned long ipc_routine,\n                           cap_t register_thread_cap, unsigned long destructor)\n{\n        struct ipc_server_config *config;\n        struct thread *register_cb_thread;\n        struct ipc_server_register_cb_config *register_cb_config;\n\n        BUG_ON(server == NULL);\n        if (server->general_ipc_config != NULL) {\n                kdebug("A server thread can only invoke **register_server** once!\\n");\n                return -EINVAL;\n        }\n\n        /*\n         * Check the passive thread in server for handling\n         * client registration.\n         */\n        register_cb_thread =\n                obj_get(current_cap_group, register_thread_cap, TYPE_THREAD);\n        if (!register_cb_thread) {\n                kdebug("A register_cb_thread is required.\\n");\n                return -ECAPBILITY;\n        }\n\n        if (register_cb_thread->thread_ctx->type != TYPE_REGISTER) {\n                kdebug("The register_cb_thread should be TYPE_REGISTER!\\n");\n                obj_put(register_cb_thread);\n                return -EINVAL;\n        }\n\n        config = kmalloc(sizeof(*config));\n        if (!config) {\n                obj_put(register_cb_thread);\n                return -ENOMEM;\n        }\n\n        /*\n         * @ipc_routine will be the real ipc_routine_entry.\n         * No need to validate such address because the server just\n         * kill itself if the address is illegal.\n         */\n        config->declared_ipc_routine_entry = ipc_routine;\n\n        /* Record the registration cb thread */\n        config->register_cb_thread = register_cb_thread;\n\n        register_cb_config = kmalloc(sizeof(*register_cb_config));\n        if (!register_cb_config) {\n                kfree(config);\n                obj_put(register_cb_thread);\n                return -ENOMEM;\n        }\n        register_cb_thread->general_ipc_config = register_cb_config;\n\n        /*\n         * This lock will be used to prevent concurrent client threads\n         * from registering.\n         * In other words, a register_cb_thread can only serve\n         * registration requests one-by-one.\n         */\n        lock_init(&register_cb_config->register_lock);\n\n        /* Record PC as well as the thread\'s initial stack (SP). */\n        register_cb_config->register_cb_entry =\n                arch_get_thread_next_ip(register_cb_thread);\n        register_cb_config->register_cb_stack =\n                arch_get_thread_stack(register_cb_thread);\n        register_cb_config->destructor = destructor;\n        obj_put(register_cb_thread);\n\n#if defined(CHCORE_ARCH_AARCH64)\n        /* The following fence can ensure: the config related data,\n         * e.g., the register_lock, can been seen when\n         * server->general_ipc_config is set.\n         */\n        smp_mb();\n#else\n        /* TSO: the fence is not required. */\n#endif\n\n        /*\n         * The last step: fill the general_ipc_config.\n         * This field is also treated as the whether the server thread\n         * declares an IPC service (or makes the service ready).\n         */\n        server->general_ipc_config = config;\n\n        return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u4e4b\u540e\u662f\u5ba2\u6237\u7aef\u5efa\u7acb\u8fde\u63a5"}),"\n",(0,t.jsx)(n.p,{children:"\u5ba2\u6237\u7aef\u521b\u5efa\u5bf9\u5e94\u5171\u4eab\u5185\u5b58\uff0c\u5e76\u5206\u4eab\u7ed9server handler"}),"\n",(0,t.jsx)(n.p,{children:"\u8fd9\u91cc\u7528PMO_DATA\u800c\u4e0d\u7528PMO_SHM\u7684\u539f\u56e0\u662fPMO_DATA\u6ca1\u6709lazy alloc\uff0c\u800c\u9488\u5bf9ipc register\u8fd9\u6837\u7684\u5c0f\u5185\u5b58\u573a\u666f\uff0c\u6211\u4eec\u4e0d\u9700\u8981lazy alloc"}),"\n",(0,t.jsx)(n.p,{children:"usys_create_pmo, usys_yield\u540c\u7406\u53ea\u662fsyscall\u7684\u4e00\u4e2a\u7b80\u5355\u5305\u88c5"}),"\n",(0,t.jsx)(n.p,{children:"\u7136\u540e\u5ba2\u6237\u7aef\u5c1d\u8bd5\u53d1\u8d77\u6ce8\u518c\u7cfb\u7edf\u8c03\u7528"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'/*\n * A client thread can register itself for multiple times.\n *\n * The returned ipc_struct_t is from heap,\n * so the callee needs to free it.\n */\nipc_struct_t *ipc_register_client(cap_t server_thread_cap)\n{\n        cap_t conn_cap;\n        ipc_struct_t *client_ipc_struct;\n\n        struct client_shm_config shm_config;\n        cap_t shm_cap;\n\n        client_ipc_struct = malloc(sizeof(ipc_struct_t));\n        if (client_ipc_struct == NULL) {\n                return NULL;\n        }\n\n        /*\n         * Before registering client on the server,\n         * the client allocates the shm (and shares it with\n         * the server later).\n         *\n         * Now we used PMO_DATA instead of PMO_SHM because:\n         * - SHM (IPC_PER_SHM_SIZE) only contains one page and\n         *   PMO_DATA is thus more efficient.\n         *\n         * If the SHM becomes larger, we can use PMO_SHM instead.\n         * Both types are tested and can work well.\n         */\n\n        // shm_cap = usys_create_pmo(IPC_PER_SHM_SIZE, PMO_SHM);\n        shm_cap = usys_create_pmo(IPC_PER_SHM_SIZE, PMO_DATA);\n        if (shm_cap < 0) {\n                printf("usys_create_pmo ret %d\\n", shm_cap);\n                goto out_free_client_ipc_struct;\n        }\n\n        shm_config.shm_cap = shm_cap;\n        shm_config.shm_addr = chcore_alloc_vaddr(IPC_PER_SHM_SIZE); // 0x1000\n\n        // printf("%s: register_client with shm_addr 0x%lx\\n",\n        //      __func__, shm_config.shm_addr);\n\n        while (1) {\n                conn_cap = usys_register_client(server_thread_cap,\n                                                (unsigned long)&shm_config);\n\n                if (conn_cap == -EIPCRETRY) {\n                        // printf("client: Try to connect again ...\\n");\n                        /* The server IPC may be not ready. */\n                        usys_yield();\n                } else if (conn_cap < 0) {\n                        printf("client: %s failed (return %d), server_thread_cap is %d\\n",\n                               __func__,\n                               conn_cap,\n                               server_thread_cap);\n                        goto out_free_vaddr;\n                } else {\n                        /* Success */\n                        break;\n                }\n        }\n\n        client_ipc_struct->lock = 0;\n        client_ipc_struct->shared_buf = shm_config.shm_addr;\n        client_ipc_struct->shared_buf_len = IPC_PER_SHM_SIZE;\n        client_ipc_struct->conn_cap = conn_cap;\n\n        return client_ipc_struct;\n\nout_free_vaddr:\n        usys_revoke_cap(shm_cap, false);\n        chcore_free_vaddr(shm_config.shm_addr, IPC_PER_SHM_SIZE);\n\nout_free_client_ipc_struct:\n        free(client_ipc_struct);\n\n        return NULL;\n}\n\nint ipc_client_close_connection(ipc_struct_t *ipc_struct)\n{\n        int ret;\n        while (1) {\n                ret = usys_ipc_close_connection(ipc_struct->conn_cap);\n\n                if (ret == -EAGAIN) {\n                        usys_yield();\n                } else if (ret < 0) {\n                        goto out;\n                } else {\n                        break;\n                }\n        }\n\n        chcore_free_vaddr(ipc_struct->shared_buf, ipc_struct->shared_buf_len);\n        free(ipc_struct);\nout:\n        return ret;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u6ce8\u518c\u7cfb\u7edf\u8c03\u7528\u5bf9\u5e94\u7684\u5b9e\u9645\u51fd\u6570\u5982\u4e0b"}),"\n",(0,t.jsx)(n.p,{children:"\u5927\u4f53\u6d41\u7a0b\u662f"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u4ece\u5f53\u524dthread \u7684cap_group\u91cc\u9762\u627e\u5230\u4f20\u5165\u7684server_cap\u5bf9\u5e94\u7684slot\uff0c\u8fdb\u800c\u5f97\u5230server\u7ebf\u7a0b\u63a7\u5236\u5757"}),"\n",(0,t.jsx)(n.li,{children:"\u4eceserver\u83b7\u53d6\u5b83\u7684ipc config\uff0c\u62ff\u9501\u907f\u514d\u5e76\u53d1\u95ee\u9898"}),"\n",(0,t.jsx)(n.li,{children:"\u68c0\u67e5client\u58f0\u660e\u7684\u5171\u4eab\u5185\u5b58\u5730\u5740\u6ca1\u95ee\u9898\u4e4b\u540e\uff0c\u62f7\u8d1d\u5230\u5185\u6838\u6001\uff0c\u518d\u7ed9\u5b83\u53bb\u5b9e\u9645map\u5171\u4eab\u5185\u5b58"}),"\n",(0,t.jsx)(n.li,{children:"\u521b\u5efaconnection\u5bf9\u8c61\uff0c\u5e76\u628acap\u7ed9\u5230server\u548cclient"}),"\n",(0,t.jsx)(n.li,{children:"\u8bbe\u7f6e\u597d\u8c03\u7528\u53c2\u6570\uff0c\u6808\u5bc4\u5b58\u5668\uff0c\u5f02\u5e38\u5904\u7406\u5bc4\u5b58\u5668"}),"\n",(0,t.jsx)(n.li,{children:"\u7136\u540e\u8c03\u7528sched\u5207\u6362\u63a7\u5236\u6743\u7ed9\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570"}),"\n",(0,t.jsx)(n.li,{children:"(\u4e5f\u53ef\u4ee5\u770b\u5230\u6574\u4e2a\u6d41\u7a0b\u4e0d\u6d89\u53ca\u5230IPI)"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"cap_t sys_register_client(cap_t server_cap, unsigned long shm_config_ptr)\n{\n        struct thread *client;\n        struct thread *server;\n\n        /*\n         * No need to initialize actually.\n         * However, fbinfer will complain without zeroing because\n         * it cannot tell copy_from_user.\n         */\n        struct client_shm_config shm_config = {0};\n        int r;\n        struct client_connection_result res;\n\n        struct ipc_server_config *server_config;\n        struct thread *register_cb_thread;\n        struct ipc_server_register_cb_config *register_cb_config;\n\n        client = current_thread;\n\n        server = obj_get(current_cap_group, server_cap, TYPE_THREAD);\n        if (!server) {\n                r = -ECAPBILITY;\n                goto out_fail;\n        }\n\n        server_config =\n                (struct ipc_server_config *)(server->general_ipc_config);\n        if (!server_config) {\n                r = -EIPCRETRY;\n                goto out_fail;\n        }\n\n        /*\n         * Locate the register_cb_thread first.\n         * And later, directly transfer the control flow to it\n         * for finishing the registration.\n         *\n         * The whole registration procedure:\n         * client thread -> server register_cb_thread -> client threrad\n         */\n        register_cb_thread = server_config->register_cb_thread;\n        register_cb_config =\n                (struct ipc_server_register_cb_config\n                         *)(register_cb_thread->general_ipc_config);\n\n        /* Acquiring register_lock: avoid concurrent client registration.\n         *\n         * Use try_lock instead of lock since the unlock operation is done by\n         * another thread and ChCore does not support mutex.\n         * Otherwise, dead lock may happen.\n         */\n        if (try_lock(&register_cb_config->register_lock) != 0) {\n                r = -EIPCRETRY;\n                goto out_fail;\n        }\n\n        /* Validate the user addresses before accessing them */\n        if (check_user_addr_range(shm_config_ptr, sizeof(shm_config) != 0)) {\n                r = -EINVAL;\n                goto out_fail_unlock;\n        }\n\n        r = copy_from_user((void *)&shm_config,\n                           (void *)shm_config_ptr,\n                           sizeof(shm_config));\n        if (r) {\n                r = -EINVAL;\n                goto out_fail_unlock;\n        }\n\n        /* Map the pmo of the shared memory */\n        r = map_pmo_in_current_cap_group(\n                shm_config.shm_cap, shm_config.shm_addr, VMR_READ | VMR_WRITE);\n        if (r != 0) {\n                goto out_fail_unlock;\n        }\n\n        /* Create the ipc_connection object */\n        r = create_connection(\n                client, server, shm_config.shm_cap, shm_config.shm_addr, &res);\n\n        if (r != 0) {\n                goto out_fail_unlock;\n        }\n\n        /* Record the connection cap of the client process */\n        register_cb_config->conn_cap_in_client = res.client_conn_cap;\n        register_cb_config->conn_cap_in_server = res.server_conn_cap;\n        /* Record the server_shm_cap for current connection */\n        register_cb_config->shm_cap_in_server = res.server_shm_cap;\n\n        /* Mark current_thread as TS_BLOCKING */\n        thread_set_ts_blocking(current_thread);\n\n        /* Set target thread SP/IP/arg */\n        arch_set_thread_stack(register_cb_thread,\n                              register_cb_config->register_cb_stack);\n        arch_set_thread_next_ip(register_cb_thread,\n                                register_cb_config->register_cb_entry);\n        arch_set_thread_arg0(register_cb_thread,\n                             server_config->declared_ipc_routine_entry);\n        obj_put(server);\n\n        /* Pass the scheduling context */\n        register_cb_thread->thread_ctx->sc = current_thread->thread_ctx->sc;\n\n        /* On success: switch to the cb_thread of server  */\n        sched_to_thread(register_cb_thread);\n\n        /* Never return */\n        BUG_ON(1);\n\nout_fail_unlock:\n        unlock(&register_cb_config->register_lock);\nout_fail: /* Maybe EAGAIN */\n        if (server)\n                obj_put(server);\n        return r;\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"\u8fd9\u4e2a\u6ce8\u518c\u7684\u56de\u8c03\u51fd\u6570\u5c31\u662fserver register\u65f6\u5019\u8bbe\u7f6e\u7684\u51fd\u6570\uff0c\u4e5f\u5c31\u662fserver\u7ebf\u7a0b\u4f20\u9012\u7684\u51fd\u6570(\u4ee3\u7801)\uff0c\u4e00\u822c\u800c\u8a00\uff0c\u8fd9\u4e2a\u51fd\u6570\u91c7\u7528\u9ed8\u8ba4\u503cregister_cb"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:" #define DEFAULT_CLIENT_REGISTER_HANDLER register_cb\n"})}),"\n",(0,t.jsx)(n.p,{children:"register_cb\u51fd\u6570\u5982\u4e0b"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u8be5\u51fd\u6570\u9996\u5148\u5206\u914d\u4e00\u4e2a\u7528\u6765\u6620\u5c04\u5171\u4eab\u5185\u5b58\u7684\u865a\u62df\u5730\u5740\uff0c\u968f\u540e\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u7ebf\u7a0b\u3002"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["\u968f\u540e\u8c03\u7528",(0,t.jsx)(n.code,{children:"sys_ipc_register_cb_return"}),"\u7cfb\u7edf\u8c03\u7528\u8fdb\u5165\u5185\u6838\uff0c\u8be5\u7cfb\u7edf\u8c03\u7528\u5c06\u5171\u4eab\u5185\u5b58\u6620\u5c04\u5230\u521a\u624d\u5206\u914d\u7684\u865a\u62df\u5730\u5740\u4e0a\uff0c\u8865\u5168",(0,t.jsx)(n.code,{children:"struct ipc_connection"}),"\u5185\u6838\u5bf9\u8c61\u4e2d\u7684\u4e00\u4e9b\u5143\u6570\u636e\u4e4b\u540e\u5207\u6362\u56de\u5ba2\u6237\u7aef\u7ebf\u7a0b\u7ee7\u7eed\u8fd0\u884c\uff0c\u5ba2\u6237\u7aef\u7ebf\u7a0b\u4ece",(0,t.jsx)(n.code,{children:"ipc_register_client"}),"\u8fd4\u56de\uff0c\u5b8c\u6210IPC\u5efa\u7acb\u8fde\u63a5\u7684\u8fc7\u7a0b\u3002"]}),"\n",(0,t.jsx)(n.blockquote,{children:"\n"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'/* A register_callback thread uses this to finish a registration */\nvoid ipc_register_cb_return(cap_t server_thread_cap,\n                            unsigned long server_thread_exit_routine,\n                            unsigned long server_shm_addr)\n{\n        usys_ipc_register_cb_return(\n                server_thread_cap, server_thread_exit_routine, server_shm_addr);\n}\n\n/* A register_callback thread is passive (never proactively run) */\nvoid *register_cb(void *ipc_handler)\n{\n        cap_t server_thread_cap = 0;\n        unsigned long shm_addr;\n\n        shm_addr = chcore_alloc_vaddr(IPC_PER_SHM_SIZE);\n\n        // printf("[server]: A new client comes in! ipc_handler: 0x%lx\\n",\n        // ipc_handler);\n\n        /*\n         * Create a passive thread for serving IPC requests.\n         * Besides, reusing an existing thread is also supported.\n         */\n        pthread_t handler_tid;\n        server_thread_cap = chcore_pthread_create_shadow(\n                &handler_tid, NULL, ipc_handler, (void *)NO_ARG);\n        BUG_ON(server_thread_cap < 0);\n#ifndef CHCORE_ARCH_X86_64\n        ipc_register_cb_return(server_thread_cap,\n                               (unsigned long)ipc_shadow_thread_exit_routine,\n                               shm_addr);\n#else\n        ipc_register_cb_return(\n                server_thread_cap,\n                (unsigned long)ipc_shadow_thread_exit_routine_naked,\n                shm_addr);\n#endif\n\n        return NULL;\n}\n\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"int sys_ipc_register_cb_return(cap_t server_handler_thread_cap,\n                               unsigned long server_thread_exit_routine,\n                               unsigned long server_shm_addr)\n{\n        struct ipc_server_register_cb_config *config;\n        struct ipc_connection *conn;\n        struct thread *client_thread;\n\n        struct thread *ipc_server_handler_thread;\n        struct ipc_server_handler_config *handler_config;\n        int r = -ECAPBILITY;\n\n        config = (struct ipc_server_register_cb_config *)\n                         current_thread->general_ipc_config;\n\n        if (!config)\n                goto out_fail;\n\n        conn = obj_get(\n                current_cap_group, config->conn_cap_in_server, TYPE_CONNECTION);\n\n        if (!conn)\n                goto out_fail;\n\n        /*\n         * @server_handler_thread_cap from server.\n         * Server uses this handler_thread to serve ipc requests.\n         */\n        ipc_server_handler_thread = (struct thread *)obj_get(\n                current_cap_group, server_handler_thread_cap, TYPE_THREAD);\n\n        if (!ipc_server_handler_thread)\n                goto out_fail_put_conn;\n\n        /* Map the shm of the connection in server */\n        r = map_pmo_in_current_cap_group(config->shm_cap_in_server,\n                                         server_shm_addr,\n                                         VMR_READ | VMR_WRITE);\n        if (r != 0)\n                goto out_fail_put_thread;\n\n        /* Get the client_thread that issues this registration */\n        client_thread = conn->current_client_thread;\n        /*\n         * Set the return value (conn_cap) for the client here\n         * because the server has approved the registration.\n         */\n        arch_set_thread_return(client_thread, config->conn_cap_in_client);\n\n        /*\n         * Initialize the ipc configuration for the handler_thread (begin)\n         *\n         * When the handler_config isn't NULL, it means this server handler\n         * thread has been initialized before. If so, skip the initialization.\n         * This will happen when a server uses one server handler thread for\n         * serving multiple client threads.\n         */\n        if (!ipc_server_handler_thread->general_ipc_config) {\n                handler_config = (struct ipc_server_handler_config *)kmalloc(\n                        sizeof(*handler_config));\n                if (!handler_config) {\n                        r = -ENOMEM;\n                        goto out_fail_put_thread;\n                }\n                ipc_server_handler_thread->general_ipc_config = handler_config;\n                lock_init(&handler_config->ipc_lock);\n\n                /*\n                 * Record the initial PC & SP for the handler_thread.\n                 * For serving each IPC, the handler_thread starts from the\n                 * same PC and SP.\n                 */\n                handler_config->ipc_routine_entry =\n                        arch_get_thread_next_ip(ipc_server_handler_thread);\n                handler_config->ipc_routine_stack =\n                        arch_get_thread_stack(ipc_server_handler_thread);\n                handler_config->ipc_exit_routine_entry =\n                        server_thread_exit_routine;\n                handler_config->destructor = config->destructor;\n        }\n        obj_put(ipc_server_handler_thread);\n        /* Initialize the ipc configuration for the handler_thread (end) */\n\n        /* Fill the server information in the IPC connection. */\n        conn->shm.server_shm_uaddr = server_shm_addr;\n        conn->server_handler_thread = ipc_server_handler_thread;\n        conn->state = CONN_VALID;\n        conn->current_client_thread = NULL;\n        conn->conn_cap_in_client = config->conn_cap_in_client;\n        conn->conn_cap_in_server = config->conn_cap_in_server;\n        obj_put(conn);\n\n        /*\n         * Return control flow (sched-context) back later.\n         * Set current_thread state to TS_WAITING again.\n         */\n        thread_set_ts_waiting(current_thread);\n\n        unlock(&config->register_lock);\n\n        /* Register thread should not any more use the client's scheduling\n         * context. */\n        current_thread->thread_ctx->sc = NULL;\n\n        /* Finish the registration: switch to the original client_thread */\n        sched_to_thread(client_thread);\n        /* Nerver return */\n\nout_fail_put_thread:\n        obj_put(ipc_server_handler_thread);\nout_fail_put_conn:\n        obj_put(conn);\nout_fail:\n        return r;\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"\u603b\u7ed3\u4ee5\u4e0a\u7684\u6d41\u7a0b\uff1a"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"server\u7aef\u6ce8\u518c\u56de\u8c03\uff0c\u6307\u660e\u5f53client\u7aef\u8fde\u63a5\u65f6\u5e94\u8be5\u8c03\u7528\u51fd\u6570f\u5904\u7406\uff0c\u521b\u5efa\u4e86\u8fd9\u4e2a\u51fd\u6570f\u76f8\u5173\u7684\u5185\u6838\u5bf9\u8c61\uff08\u5982\u80fd\u529b\u7ec4\uff0c\u4e0a\u4e0b\u6587\u7b49\uff0c\u8fd9\u4e2a\u51fd\u6570\u5b9e\u8d28\u4e0a\u662f\u4e00\u4e2a\u4e0d\u4f1a\u88ab\u4e3b\u52a8\u8c03\u5ea6\u5230\u7684\u7ebf\u7a0b\uff08\u56e0\u4e3a\u6ca1\u6709sc\u8c03\u5ea6\u4e0a\u4e0b\u6587\uff09\uff09"}),"\n",(0,t.jsx)(n.li,{children:"client\u7aef\u6ce8\u518c\uff0c\u7533\u8bf7\u5171\u4eab\u5185\u5b58\uff0c\u6307\u5b9a\u8c03\u7528\u53c2\u6570\uff0c\u7136\u540esyscall, \u5185\u6838\u6821\u9a8c\u540e\u4f20\u9012\u7ed9f"}),"\n",(0,t.jsx)(n.li,{children:"f\u5904\u7406\u5e76\u8fd4\u56de"}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},56908:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/image-19a22de2238a737e76d030566d017673.png"},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>_});var t=r(96540);const c={},i=t.createContext(c);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function _(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);